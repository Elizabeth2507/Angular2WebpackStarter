webpackJsonp([1],{

/***/ 140:
/* exports provided: RESOURCE_CACHE_PROVIDER, platformBrowserDynamic, VERSION, ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS, ɵResourceLoaderImpl */
/* exports used: platformBrowserDynamic */
/*!**************************************************************************************!*\
  !*** ./~/@angular/platform-browser-dynamic/@angular/platform-browser-dynamic.es5.js ***!
  \**************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_compiler__ = __webpack_require__(/*! @angular/compiler */ 170);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common__ = __webpack_require__(/*! @angular/common */ 62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__(/*! @angular/platform-browser */ 63);\n/* unused harmony export RESOURCE_CACHE_PROVIDER */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return platformBrowserDynamic; });\n/* unused harmony export VERSION */\n/* unused harmony export ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS */\n/* unused harmony export ɵResourceLoaderImpl */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.0.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResourceLoaderImpl = (function (_super) {\n    __extends(ResourceLoaderImpl, _super);\n    function ResourceLoaderImpl() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourceLoaderImpl.prototype.get = function (url) {\n        var resolve;\n        var reject;\n        var promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'text';\n        xhr.onload = function () {\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n            // by IE10)\n            var response = xhr.response || xhr.responseText;\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            var status = xhr.status === 1223 ? 204 : xhr.status;\n            // fix status code when it is 0 (0 status is undocumented).\n            // Occurs when accessing file resources or on Android 4.1 stock browser\n            // while retrieving files from application cache.\n            if (status === 0) {\n                status = response ? 200 : 0;\n            }\n            if (200 <= status && status <= 300) {\n                resolve(response);\n            }\n            else {\n                reject(\"Failed to load \" + url);\n            }\n        };\n        xhr.onerror = function () { reject(\"Failed to load \" + url); };\n        xhr.send();\n        return promise;\n    };\n    return ResourceLoaderImpl;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\nResourceLoaderImpl.decorators = [\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"e\" /* Injectable */] },\n];\n/** @nocollapse */\nResourceLoaderImpl.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [\n    __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"b\" /* ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS */],\n    {\n        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Y\" /* COMPILER_OPTIONS */],\n        useValue: { providers: [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: ResourceLoaderImpl }] },\n        multi: true\n    },\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"r\" /* PLATFORM_ID */], useValue: __WEBPACK_IMPORTED_MODULE_2__angular_common__[\"b\" /* ɵPLATFORM_BROWSER_ID */] },\n];\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An implementation of ResourceLoader that uses a template cache to avoid doing an actual\n * ResourceLoader.\n *\n * The template cache needs to be built and loaded into window.$templateCache\n * via a separate mechanism.\n */\nvar CachedResourceLoader = (function (_super) {\n    __extends(CachedResourceLoader, _super);\n    function CachedResourceLoader() {\n        var _this = _super.call(this) || this;\n        _this._cache = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"c\" /* ɵglobal */].$templateCache;\n        if (_this._cache == null) {\n            throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');\n        }\n        return _this;\n    }\n    CachedResourceLoader.prototype.get = function (url) {\n        if (this._cache.hasOwnProperty(url)) {\n            return Promise.resolve(this._cache[url]);\n        }\n        else {\n            return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);\n        }\n    };\n    return CachedResourceLoader;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * @stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"C\" /* Version */]('4.0.3');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @experimental\n */\nvar RESOURCE_CACHE_PROVIDER = [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: CachedResourceLoader }];\n/**\n * @stable\n */\nvar platformBrowserDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"u\" /* createPlatformFactory */])(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"b\" /* platformCoreDynamic */], 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser-dynamic package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=platform-browser-dynamic.es5.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLmVzNS5qcz9hMWIzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY0LjAuM1xuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbmltcG9ydCB7IFJlc291cmNlTG9hZGVyLCBwbGF0Zm9ybUNvcmVEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0IHsgQ09NUElMRVJfT1BUSU9OUywgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIFZlcnNpb24sIGNyZWF0ZVBsYXRmb3JtRmFjdG9yeSwgybVnbG9iYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IMm1UExBVEZPUk1fQlJPV1NFUl9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyDJtUlOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUmVzb3VyY2VMb2FkZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc291cmNlTG9hZGVySW1wbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIHJlc29sdmU7XG4gICAgICAgIHZhciByZWplY3Q7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXG4gICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gYnkgSUUxMClcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7IH07XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc291cmNlTG9hZGVySW1wbDtcbn0oUmVzb3VyY2VMb2FkZXIpKTtcblJlc291cmNlTG9hZGVySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVzb3VyY2VMb2FkZXJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICDJtUlOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgdXNlVmFsdWU6IHsgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBSZXNvdXJjZUxvYWRlciwgdXNlQ2xhc3M6IFJlc291cmNlTG9hZGVySW1wbCB9XSB9LFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH0sXG4gICAgeyBwcm92aWRlOiBQTEFURk9STV9JRCwgdXNlVmFsdWU6IMm1UExBVEZPUk1fQlJPV1NFUl9JRCB9LFxuXTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgUmVzb3VyY2VMb2FkZXIgdGhhdCB1c2VzIGEgdGVtcGxhdGUgY2FjaGUgdG8gYXZvaWQgZG9pbmcgYW4gYWN0dWFsXG4gKiBSZXNvdXJjZUxvYWRlci5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY2FjaGUgbmVlZHMgdG8gYmUgYnVpbHQgYW5kIGxvYWRlZCBpbnRvIHdpbmRvdy4kdGVtcGxhdGVDYWNoZVxuICogdmlhIGEgc2VwYXJhdGUgbWVjaGFuaXNtLlxuICovXG52YXIgQ2FjaGVkUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWNoZWRSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhY2hlID0gybVnbG9iYWwuJHRlbXBsYXRlQ2FjaGU7XG4gICAgICAgIGlmIChfdGhpcy5fY2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhY2hlZFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXNPd25Qcm9wZXJ0eSh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbn0oUmVzb3VyY2VMb2FkZXIpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAc3RhYmxlXG4gKi9cbnZhciBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzQuMC4zJyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbi8qKlxuICogQHN0YWJsZVxuICovXG52YXIgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShwbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBwbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbmV4cG9ydCB7IFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSLCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljLCBWRVJTSU9OLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTIGFzIMm1SU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUywgUmVzb3VyY2VMb2FkZXJJbXBsIGFzIMm1UmVzb3VyY2VMb2FkZXJJbXBsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 142:
/* exports provided: AppModule */
/* exports used: AppModule */
/*!***************************************!*\
  !*** ./angular2App/app/app.module.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(/*! @angular/platform-browser */ 63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_component__ = __webpack_require__(/*! ./app.component */ 172);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AppModule; });\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\nvar AppModule = (function () {\r\n    function AppModule() {\r\n    }\r\n    return AppModule;\r\n}());\r\nAppModule = __decorate([\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */])({\r\n        imports: [__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__[\"a\" /* BrowserModule */]],\r\n        declarations: [__WEBPACK_IMPORTED_MODULE_2__app_component__[\"a\" /* AppComponent */]],\r\n        bootstrap: [__WEBPACK_IMPORTED_MODULE_2__app_component__[\"a\" /* AppComponent */]]\r\n    })\r\n], AppModule);\r\n\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYW5ndWxhcjJBcHAvYXBwL2FwcC5tb2R1bGUudHM/NjQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcblxyXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuXHJcbiAgICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV0sXHJcblxyXG4gICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcclxuXHJcbiAgICBib290c3RyYXA6IFtBcHBDb21wb25lbnRdXHJcblxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FuZ3VsYXIyQXBwL2FwcC9hcHAubW9kdWxlLnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBO0FBWUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVkE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 170:
/* exports provided: VERSION, TEMPLATE_TRANSFORMS, CompilerConfig, JitCompiler, DirectiveResolver, PipeResolver, NgModuleResolver, DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, NgModuleCompiler, ViewCompiler, isSyntaxError, syntaxError, TextAst, BoundTextAst, AttrAst, BoundElementPropertyAst, BoundEventAst, ReferenceAst, VariableAst, ElementAst, EmbeddedTemplateAst, BoundDirectivePropertyAst, DirectiveAst, ProviderAst, ProviderAstType, NgContentAst, PropertyBindingType, templateVisitAll, CompileAnimationEntryMetadata, CompileAnimationStateMetadata, CompileAnimationStateDeclarationMetadata, CompileAnimationStateTransitionMetadata, CompileAnimationMetadata, CompileAnimationKeyframesSequenceMetadata, CompileAnimationStyleMetadata, CompileAnimationAnimateMetadata, CompileAnimationWithStepsMetadata, CompileAnimationSequenceMetadata, CompileAnimationGroupMetadata, identifierName, identifierModuleUrl, viewClassName, rendererTypeName, hostViewClassName, dirWrapperClassName, componentFactoryName, CompileSummaryKind, tokenName, tokenReference, CompileStylesheetMetadata, CompileTemplateMetadata, CompileDirectiveMetadata, createHostComponentMeta, CompilePipeMetadata, CompileNgModuleMetadata, TransitiveCompileNgModuleMetadata, ProviderMeta, flatten, sourceUrl, templateSourceUrl, sharedStylesheetJitUrl, ngModuleJitUrl, templateJitUrl, createAotCompiler, AotCompiler, analyzeNgModules, analyzeAndValidateNgModules, extractProgramSymbols, GeneratedFile, StaticReflector, StaticAndDynamicReflectionCapabilities, StaticSymbol, StaticSymbolCache, ResolvedStaticSymbol, StaticSymbolResolver, unescapeIdentifier, AotSummaryResolver, SummaryResolver, COMPILER_PROVIDERS, JitCompilerFactory, platformCoreDynamic, createUrlResolverWithoutPackagePrefix, createOfflineCompileUrlResolver, DEFAULT_PACKAGE_URL_PROVIDER, UrlResolver, getUrlScheme, ResourceLoader, ElementSchemaRegistry, Extractor, I18NHtmlParser, MessageBundle, Serializer, Xliff, Xliff2, Xmb, Xtb, DirectiveNormalizer, ParserError, ParseSpan, AST, Quote, EmptyExpr, ImplicitReceiver, Chain, Conditional, PropertyRead, PropertyWrite, SafePropertyRead, KeyedRead, KeyedWrite, BindingPipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, PrefixNot, MethodCall, SafeMethodCall, FunctionCall, ASTWithSource, TemplateBinding, RecursiveAstVisitor, AstTransformer, TokenType, Lexer, Token, EOF, isIdentifier, isQuote, SplitInterpolation, TemplateBindingParseResult, Parser, _ParseAST, ERROR_COLLECTOR_TOKEN, CompileMetadataResolver, componentModuleUrl, Text, Expansion, ExpansionCase, Attribute, Element, Comment, visitAll, ParseTreeResult, TreeError, HtmlParser, HtmlTagDefinition, getHtmlTagDefinition, TagContentType, splitNsName, getNsPrefix, mergeNsAndName, NAMED_ENTITIES, ImportResolver, debugOutputAstAsTypeScript, TypeScriptEmitter, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseErrorLevel, ParseError, typeSourceSpan, DomElementSchemaRegistry, CssSelector, SelectorMatcher, SelectorListContext, SelectorContext, StylesCompileDependency, StylesCompileResult, CompiledStylesheet, StyleCompiler, TemplateParseError, TemplateParseResult, TemplateParser, splitClasses, createElementCssSelector, removeSummaryDuplicates */
/* exports used: ResourceLoader, platformCoreDynamic */
/*!******************************************************!*\
  !*** ./~/@angular/compiler/@angular/compiler.es5.js ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* unused harmony export VERSION */\n/* unused harmony export TEMPLATE_TRANSFORMS */\n/* unused harmony export CompilerConfig */\n/* unused harmony export JitCompiler */\n/* unused harmony export DirectiveResolver */\n/* unused harmony export PipeResolver */\n/* unused harmony export NgModuleResolver */\n/* unused harmony export DEFAULT_INTERPOLATION_CONFIG */\n/* unused harmony export InterpolationConfig */\n/* unused harmony export NgModuleCompiler */\n/* unused harmony export ViewCompiler */\n/* unused harmony export isSyntaxError */\n/* unused harmony export syntaxError */\n/* unused harmony export TextAst */\n/* unused harmony export BoundTextAst */\n/* unused harmony export AttrAst */\n/* unused harmony export BoundElementPropertyAst */\n/* unused harmony export BoundEventAst */\n/* unused harmony export ReferenceAst */\n/* unused harmony export VariableAst */\n/* unused harmony export ElementAst */\n/* unused harmony export EmbeddedTemplateAst */\n/* unused harmony export BoundDirectivePropertyAst */\n/* unused harmony export DirectiveAst */\n/* unused harmony export ProviderAst */\n/* unused harmony export ProviderAstType */\n/* unused harmony export NgContentAst */\n/* unused harmony export PropertyBindingType */\n/* unused harmony export templateVisitAll */\n/* unused harmony export CompileAnimationEntryMetadata */\n/* unused harmony export CompileAnimationStateMetadata */\n/* unused harmony export CompileAnimationStateDeclarationMetadata */\n/* unused harmony export CompileAnimationStateTransitionMetadata */\n/* unused harmony export CompileAnimationMetadata */\n/* unused harmony export CompileAnimationKeyframesSequenceMetadata */\n/* unused harmony export CompileAnimationStyleMetadata */\n/* unused harmony export CompileAnimationAnimateMetadata */\n/* unused harmony export CompileAnimationWithStepsMetadata */\n/* unused harmony export CompileAnimationSequenceMetadata */\n/* unused harmony export CompileAnimationGroupMetadata */\n/* unused harmony export identifierName */\n/* unused harmony export identifierModuleUrl */\n/* unused harmony export viewClassName */\n/* unused harmony export rendererTypeName */\n/* unused harmony export hostViewClassName */\n/* unused harmony export dirWrapperClassName */\n/* unused harmony export componentFactoryName */\n/* unused harmony export CompileSummaryKind */\n/* unused harmony export tokenName */\n/* unused harmony export tokenReference */\n/* unused harmony export CompileStylesheetMetadata */\n/* unused harmony export CompileTemplateMetadata */\n/* unused harmony export CompileDirectiveMetadata */\n/* unused harmony export createHostComponentMeta */\n/* unused harmony export CompilePipeMetadata */\n/* unused harmony export CompileNgModuleMetadata */\n/* unused harmony export TransitiveCompileNgModuleMetadata */\n/* unused harmony export ProviderMeta */\n/* unused harmony export flatten */\n/* unused harmony export sourceUrl */\n/* unused harmony export templateSourceUrl */\n/* unused harmony export sharedStylesheetJitUrl */\n/* unused harmony export ngModuleJitUrl */\n/* unused harmony export templateJitUrl */\n/* unused harmony export createAotCompiler */\n/* unused harmony export AotCompiler */\n/* unused harmony export analyzeNgModules */\n/* unused harmony export analyzeAndValidateNgModules */\n/* unused harmony export extractProgramSymbols */\n/* unused harmony export GeneratedFile */\n/* unused harmony export StaticReflector */\n/* unused harmony export StaticAndDynamicReflectionCapabilities */\n/* unused harmony export StaticSymbol */\n/* unused harmony export StaticSymbolCache */\n/* unused harmony export ResolvedStaticSymbol */\n/* unused harmony export StaticSymbolResolver */\n/* unused harmony export unescapeIdentifier */\n/* unused harmony export AotSummaryResolver */\n/* unused harmony export SummaryResolver */\n/* unused harmony export COMPILER_PROVIDERS */\n/* unused harmony export JitCompilerFactory */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return platformCoreDynamic; });\n/* unused harmony export createUrlResolverWithoutPackagePrefix */\n/* unused harmony export createOfflineCompileUrlResolver */\n/* unused harmony export DEFAULT_PACKAGE_URL_PROVIDER */\n/* unused harmony export UrlResolver */\n/* unused harmony export getUrlScheme */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ResourceLoader; });\n/* unused harmony export ElementSchemaRegistry */\n/* unused harmony export Extractor */\n/* unused harmony export I18NHtmlParser */\n/* unused harmony export MessageBundle */\n/* unused harmony export Serializer */\n/* unused harmony export Xliff */\n/* unused harmony export Xliff2 */\n/* unused harmony export Xmb */\n/* unused harmony export Xtb */\n/* unused harmony export DirectiveNormalizer */\n/* unused harmony export ParserError */\n/* unused harmony export ParseSpan */\n/* unused harmony export AST */\n/* unused harmony export Quote */\n/* unused harmony export EmptyExpr */\n/* unused harmony export ImplicitReceiver */\n/* unused harmony export Chain */\n/* unused harmony export Conditional */\n/* unused harmony export PropertyRead */\n/* unused harmony export PropertyWrite */\n/* unused harmony export SafePropertyRead */\n/* unused harmony export KeyedRead */\n/* unused harmony export KeyedWrite */\n/* unused harmony export BindingPipe */\n/* unused harmony export LiteralPrimitive */\n/* unused harmony export LiteralArray */\n/* unused harmony export LiteralMap */\n/* unused harmony export Interpolation */\n/* unused harmony export Binary */\n/* unused harmony export PrefixNot */\n/* unused harmony export MethodCall */\n/* unused harmony export SafeMethodCall */\n/* unused harmony export FunctionCall */\n/* unused harmony export ASTWithSource */\n/* unused harmony export TemplateBinding */\n/* unused harmony export RecursiveAstVisitor */\n/* unused harmony export AstTransformer */\n/* unused harmony export TokenType */\n/* unused harmony export Lexer */\n/* unused harmony export Token */\n/* unused harmony export EOF */\n/* unused harmony export isIdentifier */\n/* unused harmony export isQuote */\n/* unused harmony export SplitInterpolation */\n/* unused harmony export TemplateBindingParseResult */\n/* unused harmony export Parser */\n/* unused harmony export _ParseAST */\n/* unused harmony export ERROR_COLLECTOR_TOKEN */\n/* unused harmony export CompileMetadataResolver */\n/* unused harmony export componentModuleUrl */\n/* unused harmony export Text */\n/* unused harmony export Expansion */\n/* unused harmony export ExpansionCase */\n/* unused harmony export Attribute */\n/* unused harmony export Element */\n/* unused harmony export Comment */\n/* unused harmony export visitAll */\n/* unused harmony export ParseTreeResult */\n/* unused harmony export TreeError */\n/* unused harmony export HtmlParser */\n/* unused harmony export HtmlTagDefinition */\n/* unused harmony export getHtmlTagDefinition */\n/* unused harmony export TagContentType */\n/* unused harmony export splitNsName */\n/* unused harmony export getNsPrefix */\n/* unused harmony export mergeNsAndName */\n/* unused harmony export NAMED_ENTITIES */\n/* unused harmony export ImportResolver */\n/* unused harmony export debugOutputAstAsTypeScript */\n/* unused harmony export TypeScriptEmitter */\n/* unused harmony export ParseLocation */\n/* unused harmony export ParseSourceFile */\n/* unused harmony export ParseSourceSpan */\n/* unused harmony export ParseErrorLevel */\n/* unused harmony export ParseError */\n/* unused harmony export typeSourceSpan */\n/* unused harmony export DomElementSchemaRegistry */\n/* unused harmony export CssSelector */\n/* unused harmony export SelectorMatcher */\n/* unused harmony export SelectorListContext */\n/* unused harmony export SelectorContext */\n/* unused harmony export StylesCompileDependency */\n/* unused harmony export StylesCompileResult */\n/* unused harmony export CompiledStylesheet */\n/* unused harmony export StyleCompiler */\n/* unused harmony export TemplateParseError */\n/* unused harmony export TemplateParseResult */\n/* unused harmony export TemplateParser */\n/* unused harmony export splitClasses */\n/* unused harmony export createElementCssSelector */\n/* unused harmony export removeSummaryDuplicates */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.0.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"C\" /* Version */]('4.0.3');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A segment of text within the template.\n */\nvar TextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n    return AttrAst;\n}());\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[\\@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} type\n     * @param {?} securityContext\n     * @param {?} value\n     * @param {?} unit\n     * @param {?} sourceSpan\n     */\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    Object.defineProperty(BoundElementPropertyAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === PropertyBindingType.Animation; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(\\@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @param {?} handler\n     * @param {?} sourceSpan\n     */\n    function BoundEventAst(name, target, phase, handler, sourceSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @return {?}\n     */\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        else if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        else {\n            return name;\n        }\n    };\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundEventAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return !!this.phase; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ReferenceAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function VariableAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     * @param {?} endSourceSpan\n     */\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = (function () {\n    /**\n     * @param {?} attrs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} variables\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = (function () {\n    /**\n     * @param {?} directiveName\n     * @param {?} templateName\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = (function () {\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} hostProperties\n     * @param {?} hostEvents\n     * @param {?} contentQueryStartId\n     * @param {?} sourceSpan\n     */\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = (function () {\n    /**\n     * @param {?} token\n     * @param {?} multiProvider\n     * @param {?} eager\n     * @param {?} providers\n     * @param {?} providerType\n     * @param {?} lifecycleHooks\n     * @param {?} sourceSpan\n     */\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType = {};\nProviderAstType.PublicService = 0;\nProviderAstType.PrivateService = 1;\nProviderAstType.Component = 2;\nProviderAstType.Directive = 3;\nProviderAstType.Builtin = 4;\nProviderAstType[ProviderAstType.PublicService] = \"PublicService\";\nProviderAstType[ProviderAstType.PrivateService] = \"PrivateService\";\nProviderAstType[ProviderAstType.Component] = \"Component\";\nProviderAstType[ProviderAstType.Directive] = \"Directive\";\nProviderAstType[ProviderAstType.Builtin] = \"Builtin\";\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = (function () {\n    /**\n     * @param {?} index\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\nvar PropertyBindingType = {};\nPropertyBindingType.Property = 0;\nPropertyBindingType.Attribute = 1;\nPropertyBindingType.Class = 2;\nPropertyBindingType.Style = 3;\nPropertyBindingType.Animation = 4;\nPropertyBindingType[PropertyBindingType.Property] = \"Property\";\nPropertyBindingType[PropertyBindingType.Attribute] = \"Attribute\";\nPropertyBindingType[PropertyBindingType.Class] = \"Class\";\nPropertyBindingType[PropertyBindingType.Style] = \"Style\";\nPropertyBindingType[PropertyBindingType.Animation] = \"Animation\";\n/**\n * Visit every node in a list of {\\@link TemplateAst}s with the given {\\@link TemplateAstVisitor}.\n * @param {?} visitor\n * @param {?} asts\n * @param {?=} context\n * @return {?}\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = (function () {\n    /**\n     * @param {?} filePath\n     * @param {?} name\n     * @param {?} members\n     */\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    /**\n     * @return {?}\n     */\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    /**\n     * @param {?} declarationFile\n     * @param {?} name\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var /** @type {?} */ memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var /** @type {?} */ key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var /** @type {?} */ result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\nvar TagContentType = {};\nTagContentType.RAW_TEXT = 0;\nTagContentType.ESCAPABLE_RAW_TEXT = 1;\nTagContentType.PARSABLE_DATA = 2;\nTagContentType[TagContentType.RAW_TEXT] = \"RAW_TEXT\";\nTagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTagContentType[TagContentType.PARSABLE_DATA] = \"PARSABLE_DATA\";\n/**\n * @param {?} elementName\n * @return {?}\n */\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var /** @type {?} */ colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n/**\n * @param {?} fullName\n * @return {?}\n */\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\n/**\n * @param {?} prefix\n * @param {?} localName\n * @return {?}\n */\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function HtmlTagDefinition(_a) {\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        var _this = this;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        if (requiredParents && requiredParents.length > 0) {\n            this.requiredParents = {};\n            // The first parent is the list is automatically when none of the listed parents are present\n            this.parentToAdd = requiredParents[0];\n            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\n        }\n        this.implicitNamespacePrefix = implicitNamespacePrefix;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n        if (!this.requiredParents) {\n            return false;\n        }\n        if (!currentParent) {\n            return true;\n        }\n        var /** @type {?} */ lcParent = currentParent.toLowerCase();\n        var /** @type {?} */ isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n        return !isParentTemplate && this.requiredParents[lcParent] != true;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS = {\n    'base': new HtmlTagDefinition({ isVoid: true }),\n    'meta': new HtmlTagDefinition({ isVoid: true }),\n    'area': new HtmlTagDefinition({ isVoid: true }),\n    'embed': new HtmlTagDefinition({ isVoid: true }),\n    'link': new HtmlTagDefinition({ isVoid: true }),\n    'img': new HtmlTagDefinition({ isVoid: true }),\n    'input': new HtmlTagDefinition({ isVoid: true }),\n    'param': new HtmlTagDefinition({ isVoid: true }),\n    'hr': new HtmlTagDefinition({ isVoid: true }),\n    'br': new HtmlTagDefinition({ isVoid: true }),\n    'source': new HtmlTagDefinition({ isVoid: true }),\n    'track': new HtmlTagDefinition({ isVoid: true }),\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\n    'p': new HtmlTagDefinition({\n        closedByChildren: [\n            'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n            'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n        ],\n        closedByParent: true\n    }),\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n    'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        requiredParents: ['tbody', 'tfoot', 'thead'],\n        closedByParent: true\n    }),\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n    'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n};\nvar _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getHtmlTagDefinition(tagName) {\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n    '([-\\\\w]+)|' +\n    '(?:\\\\.([-\\\\w]+))|' +\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' +\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CssSelector.parse = function (selector) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var /** @type {?} */ cssSelector = new CssSelector();\n        var /** @type {?} */ match;\n        var /** @type {?} */ current = cssSelector;\n        var /** @type {?} */ inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n    /**\n     * @param {?=} element\n     * @return {?}\n     */\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /**\n     * Gets a template string for an element that matches the selector.\n     * @return {?}\n     */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var /** @type {?} */ tagName = this.element || 'div';\n        var /** @type {?} */ classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var /** @type {?} */ attrs = '';\n        for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n            var /** @type {?} */ attrName = this.attrs[i];\n            var /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.toString = function () {\n        var /** @type {?} */ res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n                var /** @type {?} */ name = this.attrs[i];\n                var /** @type {?} */ value = this.attrs[i + 1];\n                res += \"[\" + name + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    /**\n     * @param {?} notSelectors\n     * @return {?}\n     */\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var /** @type {?} */ notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    /**\n     * @param {?} cssSelectors\n     * @param {?=} callbackCtxt\n     * @return {?}\n     */\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var /** @type {?} */ listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param {?} cssSelector A css selector\n     * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n     * @param {?} listContext\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var /** @type {?} */ matcher = this;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        var /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var /** @type {?} */ className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ isTerminal = i === attrs.length - 2;\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                if (isTerminal) {\n                    var /** @type {?} */ terminalMap = matcher._attrValueMap;\n                    var /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n                    var /** @type {?} */ partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @param {?} selectable\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var /** @type {?} */ terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var /** @type {?} */ matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param {?} cssSelector A css selector\n     * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return {?} boolean true if a match was found\n     */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var /** @type {?} */ result = false;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        for (var /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                var /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ selectables = map.get(name) || [];\n        var /** @type {?} */ starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var /** @type {?} */ selectable;\n        var /** @type {?} */ result = false;\n        for (var /** @type {?} */ i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = (function () {\n    /**\n     * @param {?} selectors\n     */\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\nvar SelectorContext = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} cbContext\n     * @param {?} listContext\n     */\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    /**\n     * @param {?} cssSelector\n     * @param {?} callback\n     * @return {?}\n     */\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var /** @type {?} */ result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar MODULE_SUFFIX = '';\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\n/**\n * @param {?} input\n * @return {?}\n */\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input, character, defaultValues) {\n    var /** @type {?} */ characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(/** @type {?} */ (value), context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(/** @type {?} */ (value), context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\nvar ValueTransformer = (function () {\n    function ValueTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n        return result;\n    };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n    return ValueTransformer;\n}());\nvar SyncAsyncResult = (function () {\n    /**\n     * @param {?} syncResult\n     * @param {?=} asyncResult\n     */\n    function SyncAsyncResult(syncResult, asyncResult) {\n        if (asyncResult === void 0) { asyncResult = null; }\n        this.syncResult = syncResult;\n        this.asyncResult = asyncResult;\n        if (!asyncResult) {\n            this.asyncResult = Promise.resolve(syncResult);\n        }\n    }\n    return SyncAsyncResult;\n}());\n/**\n * @param {?} msg\n * @return {?}\n */\nfunction syntaxError(msg) {\n    var /** @type {?} */ error = Error(msg);\n    ((error))[ERROR_SYNTAX_ERROR] = true;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isSyntaxError(error) {\n    return ((error))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction utf8Encode(str) {\n    var /** @type {?} */ encoded = '';\n    for (var /** @type {?} */ index = 0; index < str.length; index++) {\n        var /** @type {?} */ codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var /** @type {?} */ low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nvar CompileAnimationEntryMetadata = (function () {\n    /**\n     * @param {?=} name\n     * @param {?=} definitions\n     */\n    function CompileAnimationEntryMetadata(name, definitions) {\n        if (name === void 0) { name = null; }\n        if (definitions === void 0) { definitions = null; }\n        this.name = name;\n        this.definitions = definitions;\n    }\n    return CompileAnimationEntryMetadata;\n}());\n/**\n * @abstract\n */\nvar CompileAnimationStateMetadata = (function () {\n    function CompileAnimationStateMetadata() {\n    }\n    return CompileAnimationStateMetadata;\n}());\nvar CompileAnimationStateDeclarationMetadata = (function (_super) {\n    __extends(CompileAnimationStateDeclarationMetadata, _super);\n    /**\n     * @param {?} stateNameExpr\n     * @param {?} styles\n     */\n    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {\n        var _this = _super.call(this) || this;\n        _this.stateNameExpr = stateNameExpr;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStateDeclarationMetadata;\n}(CompileAnimationStateMetadata));\nvar CompileAnimationStateTransitionMetadata = (function (_super) {\n    __extends(CompileAnimationStateTransitionMetadata, _super);\n    /**\n     * @param {?} stateChangeExpr\n     * @param {?} steps\n     */\n    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {\n        var _this = _super.call(this) || this;\n        _this.stateChangeExpr = stateChangeExpr;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationStateTransitionMetadata;\n}(CompileAnimationStateMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationMetadata = (function () {\n    function CompileAnimationMetadata() {\n    }\n    return CompileAnimationMetadata;\n}());\nvar CompileAnimationKeyframesSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationKeyframesSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationKeyframesSequenceMetadata(steps) {\n        if (steps === void 0) { steps = []; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationKeyframesSequenceMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationStyleMetadata = (function (_super) {\n    __extends(CompileAnimationStyleMetadata, _super);\n    /**\n     * @param {?} offset\n     * @param {?=} styles\n     */\n    function CompileAnimationStyleMetadata(offset, styles) {\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.offset = offset;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStyleMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationAnimateMetadata = (function (_super) {\n    __extends(CompileAnimationAnimateMetadata, _super);\n    /**\n     * @param {?=} timings\n     * @param {?=} styles\n     */\n    function CompileAnimationAnimateMetadata(timings, styles) {\n        if (timings === void 0) { timings = 0; }\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.timings = timings;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationAnimateMetadata;\n}(CompileAnimationMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationWithStepsMetadata = (function (_super) {\n    __extends(CompileAnimationWithStepsMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationWithStepsMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationWithStepsMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationSequenceMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationSequenceMetadata;\n}(CompileAnimationWithStepsMetadata));\nvar CompileAnimationGroupMetadata = (function (_super) {\n    __extends(CompileAnimationGroupMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationGroupMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationGroupMetadata;\n}(CompileAnimationWithStepsMetadata));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var /** @type {?} */ identifier = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = _sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierModuleUrl(compileIdentifier) {\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].importUri(ref);\n}\n/**\n * @param {?} compType\n * @param {?} embeddedTemplateIndex\n * @return {?}\n */\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} dirType\n * @return {?}\n */\nfunction dirWrapperClassName(dirType) {\n    return \"Wrapper_\" + identifierName({ reference: dirType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind = {};\nCompileSummaryKind.Pipe = 0;\nCompileSummaryKind.Directive = 1;\nCompileSummaryKind.NgModule = 2;\nCompileSummaryKind.Injectable = 3;\nCompileSummaryKind[CompileSummaryKind.Pipe] = \"Pipe\";\nCompileSummaryKind[CompileSummaryKind.Directive] = \"Directive\";\nCompileSummaryKind[CompileSummaryKind.NgModule] = \"NgModule\";\nCompileSummaryKind[CompileSummaryKind.Injectable] = \"Injectable\";\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenName(token) {\n    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileTemplateMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation, isInline = _b.isInline;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n    }\n    /**\n     * @return {?}\n     */\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            animations: this.animations.map(function (anim) { return anim.name; }),\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileDirectiveMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template, componentViewType = _b.componentViewType, rendererType = _b.rendererType, componentFactory = _b.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    /**\n     * @param {?=} __0\n     * @return {?}\n     */\n    CompileDirectiveMetadata.create = function (_a) {\n        var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template, componentViewType = _b.componentViewType, rendererType = _b.rendererType, componentFactory = _b.componentFactory;\n        var /** @type {?} */ hostListeners = {};\n        var /** @type {?} */ hostProperties = {};\n        var /** @type {?} */ hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var /** @type {?} */ value = host[key];\n                var /** @type {?} */ matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var /** @type {?} */ inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var /** @type {?} */ outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\n/**\n * Construct {\\@link CompileDirectiveMetadata} from {\\@link ComponentTypeMetadata} and a selector.\n * @param {?} hostTypeReference\n * @param {?} compMeta\n * @param {?} hostViewType\n * @return {?}\n */\nfunction createHostComponentMeta(hostTypeReference, compMeta, hostViewType) {\n    var /** @type {?} */ template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n    return CompileDirectiveMetadata.create({\n        isHost: true,\n        type: { reference: hostTypeReference, diDeps: [], lifecycleHooks: [] },\n        template: new CompileTemplateMetadata({\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None,\n            template: template,\n            templateUrl: '',\n            styles: [],\n            styleUrls: [],\n            ngContentSelectors: [],\n            animations: [],\n            isInline: true,\n        }),\n        changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */].Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: { id: '__Host__', encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None, styles: [], data: {} }\n    });\n}\nvar CompilePipeMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilePipeMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    /**\n     * @return {?}\n     */\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileNgModuleMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;\n        this.type = type;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id;\n        this.transitiveModule = transitiveModule;\n    }\n    /**\n     * @return {?}\n     */\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: this.transitiveModule.entryComponents,\n            providers: this.transitiveModule.providers,\n            modules: this.transitiveModule.modules,\n            exportedDirectives: this.transitiveModule.exportedDirectives,\n            exportedPipes: this.transitiveModule.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    /**\n     * @param {?} provider\n     * @param {?} module\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    /**\n     * @param {?} ec\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = (function () {\n    /**\n     * @param {?} token\n     * @param {?} __1\n     */\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory;\n        this.dependencies = deps;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;\n        return ((flat)).concat(flatItem);\n    }, []);\n}\n/**\n * @param {?} url\n * @return {?}\n */\nfunction sourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @param {?} templateMeta\n * @return {?}\n */\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var /** @type {?} */ url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = templateMeta.templateUrl;\n    }\n    // always prepend ng:// to make angular resources easy to find and not clobber\n    // user resources.\n    return sourceUrl(url);\n}\n/**\n * @param {?} meta\n * @param {?} id\n * @return {?}\n */\nfunction sharedStylesheetJitUrl(meta, id) {\n    var /** @type {?} */ pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n    var /** @type {?} */ baseName = pathParts[pathParts.length - 1];\n    return sourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\n/**\n * @param {?} moduleMeta\n * @return {?}\n */\nfunction ngModuleJitUrl(moduleMeta) {\n    return sourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @return {?}\n */\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return sourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, missingTranslation = _b.missingTranslation, enableLegacyTemplate = _b.enableLegacyTemplate;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = useJit;\n        this.missingTranslation = missingTranslation;\n        this.enableLegacyTemplate = enableLegacyTemplate !== false;\n    }\n    return CompilerConfig;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = (function () {\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     */\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return ParseSpan;\n}());\nvar AST = (function () {\n    /**\n     * @param {?} span\n     */\n    function AST(span) {\n        this.span = span;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    /**\n     * @return {?}\n     */\n    AST.prototype.toString = function () { return 'AST'; };\n    return AST;\n}());\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = (function (_super) {\n    __extends(Quote, _super);\n    /**\n     * @param {?} span\n     * @param {?} prefix\n     * @param {?} uninterpretedExpression\n     * @param {?} location\n     */\n    function Quote(span, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    /**\n     * @return {?}\n     */\n    Quote.prototype.toString = function () { return 'Quote'; };\n    return Quote;\n}(AST));\nvar EmptyExpr = (function (_super) {\n    __extends(EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = (function (_super) {\n    __extends(ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = (function (_super) {\n    __extends(Chain, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function Chain(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = (function (_super) {\n    __extends(Conditional, _super);\n    /**\n     * @param {?} span\n     * @param {?} condition\n     * @param {?} trueExp\n     * @param {?} falseExp\n     */\n    function Conditional(span, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = (function (_super) {\n    __extends(PropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function PropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(AST));\nvar PropertyWrite = (function (_super) {\n    __extends(PropertyWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     */\n    function PropertyWrite(span, receiver, name, value) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(AST));\nvar SafePropertyRead = (function (_super) {\n    __extends(SafePropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function SafePropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(AST));\nvar KeyedRead = (function (_super) {\n    __extends(KeyedRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     */\n    function KeyedRead(span, obj, key) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = (function (_super) {\n    __extends(KeyedWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     * @param {?} value\n     */\n    function KeyedWrite(span, obj, key, value) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = (function (_super) {\n    __extends(BindingPipe, _super);\n    /**\n     * @param {?} span\n     * @param {?} exp\n     * @param {?} name\n     * @param {?} args\n     */\n    function BindingPipe(span, exp, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(AST));\nvar LiteralPrimitive = (function (_super) {\n    __extends(LiteralPrimitive, _super);\n    /**\n     * @param {?} span\n     * @param {?} value\n     */\n    function LiteralPrimitive(span, value) {\n        var _this = _super.call(this, span) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = (function (_super) {\n    __extends(LiteralArray, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function LiteralArray(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = (function (_super) {\n    __extends(LiteralMap, _super);\n    /**\n     * @param {?} span\n     * @param {?} keys\n     * @param {?} values\n     */\n    function LiteralMap(span, keys, values) {\n        var _this = _super.call(this, span) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = (function (_super) {\n    __extends(Interpolation, _super);\n    /**\n     * @param {?} span\n     * @param {?} strings\n     * @param {?} expressions\n     */\n    function Interpolation(span, strings, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = (function (_super) {\n    __extends(Binary, _super);\n    /**\n     * @param {?} span\n     * @param {?} operation\n     * @param {?} left\n     * @param {?} right\n     */\n    function Binary(span, operation, left, right) {\n        var _this = _super.call(this, span) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = (function (_super) {\n    __extends(PrefixNot, _super);\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    function PrefixNot(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar MethodCall = (function (_super) {\n    __extends(MethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function MethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(AST));\nvar SafeMethodCall = (function (_super) {\n    __extends(SafeMethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function SafeMethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(AST));\nvar FunctionCall = (function (_super) {\n    __extends(FunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} target\n     * @param {?} args\n     */\n    function FunctionCall(span, target, args) {\n        var _this = _super.call(this, span) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\nvar ASTWithSource = (function (_super) {\n    __extends(ASTWithSource, _super);\n    /**\n     * @param {?} ast\n     * @param {?} source\n     * @param {?} location\n     * @param {?} errors\n     */\n    function ASTWithSource(ast, source, location, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return this.ast.visit(visitor, context);\n    };\n    /**\n     * @return {?}\n     */\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n    return ASTWithSource;\n}(AST));\nvar TemplateBinding = (function () {\n    /**\n     * @param {?} span\n     * @param {?} key\n     * @param {?} keyIsVar\n     * @param {?} name\n     * @param {?} expression\n     */\n    function TemplateBinding(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n    return TemplateBinding;\n}());\nvar RecursiveAstVisitor = (function () {\n    function RecursiveAstVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer = (function () {\n    function AstTransformer() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    AstTransformer.prototype.visitAll = function (asts) {\n        var /** @type {?} */ res = new Array(asts.length);\n        for (var /** @type {?} */ i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n/**\n * A replacement for \\@Injectable to be used in the compiler, so that\n * we don't try to evaluate the metadata in the compiler during AoT.\n * This decorator is enough to make the compiler work with the ReflectiveInjector though.\n * \\@Annotation\n * @return {?}\n */\nfunction CompilerInjectable() {\n    return function (x) { return x; };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])() || value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var /** @type {?} */ i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])() && value != null) {\n        var /** @type {?} */ start_1 = (value[0]);\n        var /** @type {?} */ end_1 = (value[1]);\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    /**\n     * @param {?} markers\n     * @return {?}\n     */\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    ;\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = (function () {\n    function Lexer() {\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    Lexer.prototype.tokenize = function (text) {\n        var /** @type {?} */ scanner = new _Scanner(text);\n        var /** @type {?} */ tokens = [];\n        var /** @type {?} */ token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nLexer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nLexer.ctorParameters = function () { return []; };\nvar Token = (function () {\n    /**\n     * @param {?} index\n     * @param {?} type\n     * @param {?} numValue\n     * @param {?} strValue\n     */\n    function Token(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isNumber = function () { return this.type == TokenType.Number; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isString = function () { return this.type == TokenType.String; };\n    /**\n     * @param {?} operater\n     * @return {?}\n     */\n    Token.prototype.isOperator = function (operater) {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordAs = function () { return this.type == TokenType.Keyword && this.strValue == 'as'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isError = function () { return this.type == TokenType.Error; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index, code) {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index, text) {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index, text) {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index, text) {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index, text) {\n    return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index, n) {\n    return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index, message) {\n    return new Token(index, TokenType.Error, 0, message);\n}\nvar EOF = new Token(-1, TokenType.Character, 0, '');\nvar _Scanner = (function () {\n    /**\n     * @param {?} input\n     */\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanToken = function () {\n        var /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n        var /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var /** @type {?} */ start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    /**\n     * @param {?} start\n     * @param {?} code\n     * @return {?}\n     */\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    };\n    /**\n     * @param {?} start\n     * @param {?} str\n     * @return {?}\n     */\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param {?} start start index in the expression\n     * @param {?} one first symbol (always part of the operator)\n     * @param {?} twoCode code point for the second symbol\n     * @param {?} two second symbol (part of the operator when the second code point matches)\n     * @param {?=} threeCode code point for the third symbol\n     * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n     * @return {?}\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var /** @type {?} */ str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanIdentifier = function () {\n        var /** @type {?} */ start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Scanner.prototype.scanNumber = function (start) {\n        var /** @type {?} */ simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        var /** @type {?} */ value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanString = function () {\n        var /** @type {?} */ start = this.index;\n        var /** @type {?} */ quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var /** @type {?} */ buffer = '';\n        var /** @type {?} */ marker = this.index;\n        var /** @type {?} */ input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var /** @type {?} */ unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var /** @type {?} */ i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var /** @type {?} */ last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    };\n    /**\n     * @param {?} message\n     * @param {?} offset\n     * @return {?}\n     */\n    _Scanner.prototype.error = function (message, offset) {\n        var /** @type {?} */ position = this.index + offset;\n        return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var /** @type {?} */ scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text) {\n    var /** @type {?} */ result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = (function () {\n    /**\n     * @param {?} strings\n     * @param {?} expressions\n     * @param {?} offsets\n     */\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = (function () {\n    /**\n     * @param {?} templateBindings\n     * @param {?} warnings\n     * @param {?} errors\n     */\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config) {\n    var /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser = (function () {\n    /**\n     * @param {?} _lexer\n     */\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseAction = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n        var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        var /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     * @return {?}\n     */\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var /** @type {?} */ quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype._parseQuote = function (input, location) {\n        if (input == null)\n            return null;\n        var /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {\n        var /** @type {?} */ tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            var /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift.apply(tokens, prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var /** @type {?} */ expressions = [];\n        for (var /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n            var /** @type {?} */ expressionText = split.expressions[i];\n            var /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n            var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var /** @type {?} */ strings = [];\n        var /** @type {?} */ expressions = [];\n        var /** @type {?} */ offsets = [];\n        var /** @type {?} */ offset = 0;\n        for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n            var /** @type {?} */ part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.wrapLiteralPrimitive = function (input, location) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._stripComments = function (input) {\n        var /** @type {?} */ i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._commentStart = function (input) {\n        var /** @type {?} */ outerQuote = null;\n        for (var /** @type {?} */ i = 0; i < input.length - 1; i++) {\n            var /** @type {?} */ char = input.charCodeAt(i);\n            var /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    /**\n     * @param {?} parts\n     * @param {?} partInErrIdx\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var /** @type {?} */ errLocation = '';\n        for (var /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nParser.ctorParameters = function () { return [\n    { type: Lexer, },\n]; };\nvar _ParseAST = (function () {\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} tokens\n     * @param {?} inputLength\n     * @param {?} parseAction\n     * @param {?} errors\n     * @param {?} offset\n     */\n    function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    _ParseAST.prototype.peek = function (offset) {\n        var /** @type {?} */ i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.peek(0); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                this.inputLength + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.advance = function () { this.index++; };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordAs = function () { return this.next.isKeywordAs(); };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    /**\n     * @param {?} op\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @param {?} operator\n     * @return {?}\n     */\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseChain = function () {\n        var /** @type {?} */ exprs = [];\n        var /** @type {?} */ start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePipe = function () {\n        var /** @type {?} */ result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var /** @type {?} */ name = this.expectIdentifierOrKeyword();\n                var /** @type {?} */ args = [];\n                while (this.optionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseConditional = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        var /** @type {?} */ result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            var /** @type {?} */ yes = this.parsePipe();\n            var /** @type {?} */ no = void 0;\n            if (!this.optionalCharacter($COLON)) {\n                var /** @type {?} */ end = this.inputIndex;\n                var /** @type {?} */ expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var /** @type {?} */ result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            var /** @type {?} */ right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var /** @type {?} */ result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            var /** @type {?} */ right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var /** @type {?} */ result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var /** @type {?} */ result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var /** @type {?} */ result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var /** @type {?} */ result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var /** @type {?} */ right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ operator = this.next.strValue;\n            var /** @type {?} */ result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallChain = function () {\n        var /** @type {?} */ result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var /** @type {?} */ key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.optionalOperator('=')) {\n                    var /** @type {?} */ value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var /** @type {?} */ args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrimary = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var /** @type {?} */ elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var /** @type {?} */ value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            var /** @type {?} */ literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start));\n        }\n    };\n    /**\n     * @param {?} terminator\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var /** @type {?} */ result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var /** @type {?} */ keys = [];\n        var /** @type {?} */ values = [];\n        var /** @type {?} */ start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.optionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n                keys.push(key);\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    };\n    /**\n     * @param {?} receiver\n     * @param {?=} isSafe\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var /** @type {?} */ start = receiver.span.start;\n        var /** @type {?} */ id = this.expectIdentifierOrKeyword();\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var /** @type {?} */ span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    var /** @type {?} */ value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var /** @type {?} */ positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter($COMMA));\n        return (positionals);\n    };\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     * @return {?}\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var /** @type {?} */ result = '';\n        var /** @type {?} */ operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseTemplateBindings = function () {\n        var /** @type {?} */ bindings = [];\n        var /** @type {?} */ prefix = null;\n        var /** @type {?} */ warnings = [];\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ keyIsVar = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            var /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n            var /** @type {?} */ key = rawKey;\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                }\n                else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter($COLON);\n            var /** @type {?} */ name = null;\n            var /** @type {?} */ expression = null;\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                }\n                else {\n                    name = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                name = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                keyIsVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                var /** @type {?} */ start_2 = this.inputIndex;\n                var /** @type {?} */ ast = this.parsePipe();\n                var /** @type {?} */ source = this.input.substring(start_2 - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (this.peekKeywordAs() && !keyIsVar) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                var /** @type {?} */ letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null));\n            }\n            if (!this.optionalCharacter($SEMICOLON)) {\n                this.optionalCharacter($COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    /**\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.skip = function () {\n        var /** @type {?} */ n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    SimpleExpressionChecker.check = function (ast) {\n        var /** @type {?} */ s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = (function () {\n    /**\n     * @param {?} file\n     * @param {?} offset\n     * @param {?} line\n     * @param {?} col\n     */\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    /**\n     * @return {?}\n     */\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    /**\n     * @param {?} delta\n     * @return {?}\n     */\n    ParseLocation.prototype.moveBy = function (delta) {\n        var /** @type {?} */ source = this.file.content;\n        var /** @type {?} */ len = source.length;\n        var /** @type {?} */ offset = this.offset;\n        var /** @type {?} */ line = this.line;\n        var /** @type {?} */ col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    /**\n     * @param {?} maxChars\n     * @param {?} maxLines\n     * @return {?}\n     */\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var /** @type {?} */ content = this.file.content;\n        var /** @type {?} */ startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var /** @type {?} */ endOffset = startOffset;\n            var /** @type {?} */ ctxChars = 0;\n            var /** @type {?} */ ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = (function () {\n    /**\n     * @param {?} content\n     * @param {?} url\n     */\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?=} details\n     */\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    /**\n     * @return {?}\n     */\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar ParseErrorLevel = {};\nParseErrorLevel.WARNING = 0;\nParseErrorLevel.ERROR = 1;\nParseErrorLevel[ParseErrorLevel.WARNING] = \"WARNING\";\nParseErrorLevel[ParseErrorLevel.ERROR] = \"ERROR\";\nvar ParseError = (function () {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     * @param {?=} level\n     */\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    /**\n     * @return {?}\n     */\n    ParseError.prototype.toString = function () {\n        var /** @type {?} */ ctx = this.span.start.getContext(100, 3);\n        var /** @type {?} */ contextStr = ctx ? \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" : '';\n        var /** @type {?} */ details = this.span.details ? \", \" + this.span.details : '';\n        return \"\" + this.msg + contextStr + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\n/**\n * @param {?} kind\n * @param {?} type\n * @return {?}\n */\nfunction typeSourceSpan(kind, type) {\n    var /** @type {?} */ moduleUrl = identifierModuleUrl(type);\n    var /** @type {?} */ sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\nvar Expansion = (function () {\n    /**\n     * @param {?} switchValue\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     * @param {?} switchValueSourceSpan\n     */\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n    return Expansion;\n}());\nvar ExpansionCase = (function () {\n    /**\n     * @param {?} value\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} valueSourceSpan\n     * @param {?} expSourceSpan\n     */\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n    return ExpansionCase;\n}());\nvar Attribute$1 = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?=} valueSpan\n     */\n    function Attribute$1(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Attribute$1.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n    return Attribute$1;\n}());\nvar Element = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} children\n     * @param {?} sourceSpan\n     * @param {?} startSourceSpan\n     * @param {?} endSourceSpan\n     */\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n    return Element;\n}());\nvar Comment = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n    return Comment;\n}());\n/**\n * @param {?} visitor\n * @param {?} nodes\n * @param {?=} context\n * @return {?}\n */\nfunction visitAll(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1 = {};\nTokenType$1.TAG_OPEN_START = 0;\nTokenType$1.TAG_OPEN_END = 1;\nTokenType$1.TAG_OPEN_END_VOID = 2;\nTokenType$1.TAG_CLOSE = 3;\nTokenType$1.TEXT = 4;\nTokenType$1.ESCAPABLE_RAW_TEXT = 5;\nTokenType$1.RAW_TEXT = 6;\nTokenType$1.COMMENT_START = 7;\nTokenType$1.COMMENT_END = 8;\nTokenType$1.CDATA_START = 9;\nTokenType$1.CDATA_END = 10;\nTokenType$1.ATTR_NAME = 11;\nTokenType$1.ATTR_VALUE = 12;\nTokenType$1.DOC_TYPE = 13;\nTokenType$1.EXPANSION_FORM_START = 14;\nTokenType$1.EXPANSION_CASE_VALUE = 15;\nTokenType$1.EXPANSION_CASE_EXP_START = 16;\nTokenType$1.EXPANSION_CASE_EXP_END = 17;\nTokenType$1.EXPANSION_FORM_END = 18;\nTokenType$1.EOF = 19;\nTokenType$1[TokenType$1.TAG_OPEN_START] = \"TAG_OPEN_START\";\nTokenType$1[TokenType$1.TAG_OPEN_END] = \"TAG_OPEN_END\";\nTokenType$1[TokenType$1.TAG_OPEN_END_VOID] = \"TAG_OPEN_END_VOID\";\nTokenType$1[TokenType$1.TAG_CLOSE] = \"TAG_CLOSE\";\nTokenType$1[TokenType$1.TEXT] = \"TEXT\";\nTokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTokenType$1[TokenType$1.RAW_TEXT] = \"RAW_TEXT\";\nTokenType$1[TokenType$1.COMMENT_START] = \"COMMENT_START\";\nTokenType$1[TokenType$1.COMMENT_END] = \"COMMENT_END\";\nTokenType$1[TokenType$1.CDATA_START] = \"CDATA_START\";\nTokenType$1[TokenType$1.CDATA_END] = \"CDATA_END\";\nTokenType$1[TokenType$1.ATTR_NAME] = \"ATTR_NAME\";\nTokenType$1[TokenType$1.ATTR_VALUE] = \"ATTR_VALUE\";\nTokenType$1[TokenType$1.DOC_TYPE] = \"DOC_TYPE\";\nTokenType$1[TokenType$1.EXPANSION_FORM_START] = \"EXPANSION_FORM_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = \"EXPANSION_CASE_VALUE\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = \"EXPANSION_CASE_EXP_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = \"EXPANSION_CASE_EXP_END\";\nTokenType$1[TokenType$1.EXPANSION_FORM_END] = \"EXPANSION_FORM_END\";\nTokenType$1[TokenType$1.EOF] = \"EOF\";\nvar Token$1 = (function () {\n    /**\n     * @param {?} type\n     * @param {?} parts\n     * @param {?} sourceSpan\n     */\n    function Token$1(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token$1;\n}());\nvar TokenError = (function (_super) {\n    __extends(TokenError, _super);\n    /**\n     * @param {?} errorMsg\n     * @param {?} tokenType\n     * @param {?} span\n     */\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} errors\n     */\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\n/**\n * @param {?} source\n * @param {?} url\n * @param {?} getTagDefinition\n * @param {?=} tokenizeExpansionForms\n * @param {?=} interpolationConfig\n * @return {?}\n */\nfunction tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {\n    if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n        .tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n/**\n * @param {?} charCode\n * @return {?}\n */\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var /** @type {?} */ char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\n/**\n * @param {?} entitySrc\n * @return {?}\n */\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = (function () {\n    /**\n     * @param {?} error\n     */\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\nvar _Tokenizer = (function () {\n    /**\n     * @param {?} _file The html source\n     * @param {?} _getTagDefinition\n     * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n     * @param {?=} _interpolationConfig\n     */\n    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {\n        if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._file = _file;\n        this._getTagDefinition = _getTagDefinition;\n        this._tokenizeIcu = _tokenizeIcu;\n        this._interpolationConfig = _interpolationConfig;\n        this._peek = -1;\n        this._nextPeek = -1;\n        this._index = -1;\n        this._line = 0;\n        this._column = -1;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._input = _file.content;\n        this._length = _file.content.length;\n        this._advance();\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._peek !== $EOF) {\n            var /** @type {?} */ start = this._getLocation();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                if (e instanceof _ControlFlowError) {\n                    this.errors.push(e.error);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        this._beginToken(TokenType$1.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._peek === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._getLocation = function () {\n        return new ParseLocation(this._file, this._index, this._line, this._column);\n    };\n    /**\n     * @param {?=} start\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._getSpan = function (start, end) {\n        if (start === void 0) { start = this._getLocation(); }\n        if (end === void 0) { end = this._getLocation(); }\n        return new ParseSourceSpan(start, end);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._getLocation(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    /**\n     * @param {?} parts\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (end === void 0) { end = this._getLocation(); }\n        var /** @type {?} */ token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    };\n    /**\n     * @param {?} msg\n     * @param {?} span\n     * @return {?}\n     */\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._advance = function () {\n        if (this._index >= this._length) {\n            throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());\n        }\n        if (this._peek === $LF) {\n            this._line++;\n            this._column = 0;\n        }\n        else if (this._peek !== $LF && this._peek !== $CR) {\n            this._column++;\n        }\n        this._index++;\n        this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);\n        this._nextPeek =\n            this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._peek === charCode) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n        }\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var /** @type {?} */ len = chars.length;\n        if (this._index + len > this._length) {\n            return false;\n        }\n        var /** @type {?} */ initialPosition = this._savePosition();\n        for (var /** @type {?} */ i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._restorePosition(initialPosition);\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var /** @type {?} */ i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._peek)) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @param {?} len\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var /** @type {?} */ start = this._getLocation();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._index - start.offset < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n        }\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._peek !== char) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._peek === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            var /** @type {?} */ index = this._index;\n            this._advance();\n            return this._input[index];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._decodeEntity = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._advance();\n        if (this._attemptCharCode($HASH)) {\n            var /** @type {?} */ isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var /** @type {?} */ numberStart = this._getLocation().offset;\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            this._advance();\n            var /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);\n            try {\n                var /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (e) {\n                var /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);\n                throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n            }\n        }\n        else {\n            var /** @type {?} */ startPosition = this._savePosition();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                this._restorePosition(startPosition);\n                return '&';\n            }\n            this._advance();\n            var /** @type {?} */ name = this._input.substring(start.offset + 1, this._index - 1);\n            var /** @type {?} */ char = NAMED_ENTITIES[name];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n            }\n            return char;\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @param {?} firstCharOfEnd\n     * @param {?} attemptEndRest\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\n        var /** @type {?} */ tagCloseStart;\n        var /** @type {?} */ textStart = this._getLocation();\n        this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);\n        var /** @type {?} */ parts = [];\n        while (true) {\n            tagCloseStart = this._getLocation();\n            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                break;\n            }\n            if (this._index > tagCloseStart.offset) {\n                // add the characters consumed by the previous if statement to the output\n                parts.push(this._input.substring(tagCloseStart.offset, this._index));\n            }\n            while (this._peek !== firstCharOfEnd) {\n                parts.push(this._readChar(decodeEntities));\n            }\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });\n        this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });\n        this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType$1.DOC_TYPE, start);\n        this._attemptUntilChar($GT);\n        this._advance();\n        this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var /** @type {?} */ nameOrPrefixStart = this._index;\n        var /** @type {?} */ prefix = null;\n        while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {\n            this._advance();\n        }\n        var /** @type {?} */ nameStart;\n        if (this._peek === $COLON) {\n            this._advance();\n            prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n            nameStart = this._index;\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n        var /** @type {?} */ name = this._input.substring(nameStart, this._index);\n        return [prefix, name];\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var /** @type {?} */ savedPos = this._savePosition();\n        var /** @type {?} */ tagName;\n        var /** @type {?} */ lowercaseTagName;\n        try {\n            if (!isAsciiLetter(this._peek)) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            var /** @type {?} */ nameStart = this._index;\n            this._consumeTagOpenStart(start);\n            tagName = this._input.substring(nameStart, this._index);\n            lowercaseTagName = tagName.toLowerCase();\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._peek !== $SLASH && this._peek !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid, assume we want a \"<\"\n                this._restorePosition(savedPos);\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType$1.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\n        }\n    };\n    /**\n     * @param {?} lowercaseTagName\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\n        var _this = this;\n        var /** @type {?} */ textToken = this._consumeRawText(decodeEntities, $LT, function () {\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(lowercaseTagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);\n        this._endToken([null, lowercaseTagName]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType$1.TAG_OPEN_START, start);\n        var /** @type {?} */ parts = this._consumePrefixAndName();\n        this._endToken(parts);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        this._beginToken(TokenType$1.ATTR_NAME);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        this._beginToken(TokenType$1.ATTR_VALUE);\n        var /** @type {?} */ value;\n        if (this._peek === $SQ || this._peek === $DQ) {\n            var /** @type {?} */ quoteChar = this._peek;\n            this._advance();\n            var /** @type {?} */ parts = [];\n            while (this._peek !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._advance();\n        }\n        else {\n            var /** @type {?} */ valueStart = this._index;\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._input.substring(valueStart, this._index);\n        }\n        this._endToken([this._processCarriageReturns(value)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var /** @type {?} */ tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType$1.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ condition = this._readUntil($COMMA);\n        this._endToken([condition], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ type = this._readUntil($COMMA);\n        this._endToken([type], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());\n        var /** @type {?} */ value = this._readUntil($LBRACE).trim();\n        this._endToken([value], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeText = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._beginToken(TokenType$1.TEXT, start);\n        var /** @type {?} */ parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._peek === $LT || this._peek === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._peek === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._savePosition = function () {\n        return [this._peek, this._index, this._column, this._line, this.tokens.length];\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._readUntil = function (char) {\n        var /** @type {?} */ start = this._index;\n        this._attemptUntilChar(char);\n        return this._input.substring(start, this._index);\n    };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    _Tokenizer.prototype._restorePosition = function (position) {\n        this._peek = position[0];\n        this._index = position[1];\n        this._column = position[2];\n        this._line = position[3];\n        var /** @type {?} */ nbTokens = position[4];\n        if (nbTokens < this.tokens.length) {\n            // remove any extra tokens\n            this.tokens = this.tokens.slice(0, nbTokens);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_CASE_EXP_START;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_FORM_START;\n    };\n    return _Tokenizer;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n/**\n * @param {?} input\n * @param {?} offset\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction isExpansionFormStart(input, offset, interpolationConfig) {\n    var /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n    return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;\n}\n/**\n * @param {?} peek\n * @return {?}\n */\nfunction isExpansionCaseStart(peek) {\n    return peek === $EQ || isAsciiLetter(peek);\n}\n/**\n * @param {?} code1\n * @param {?} code2\n * @return {?}\n */\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\n/**\n * @param {?} srcTokens\n * @return {?}\n */\nfunction mergeTextTokens(srcTokens) {\n    var /** @type {?} */ dstTokens = [];\n    var /** @type {?} */ lastDstToken;\n    for (var /** @type {?} */ i = 0; i < srcTokens.length; i++) {\n        var /** @type {?} */ token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = (function (_super) {\n    __extends(TreeError, _super);\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     */\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     * @return {?}\n     */\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = (function () {\n    /**\n     * @param {?} rootNodes\n     * @param {?} errors\n     */\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser$1 = (function () {\n    /**\n     * @param {?} getTagDefinition\n     */\n    function Parser$1(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser$1.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n        var /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));\n    };\n    return Parser$1;\n}());\nvar _TreeBuilder = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} getTagDefinition\n     */\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType$1.EOF) {\n            if (this._peek.type === TokenType$1.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||\n                this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advance = function () {\n        var /** @type {?} */ prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    /**\n     * @param {?} startToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType$1.CDATA_END);\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var /** @type {?} */ text = this._advanceIf(TokenType$1.RAW_TEXT);\n        this._advanceIf(TokenType$1.COMMENT_END);\n        var /** @type {?} */ value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var /** @type {?} */ switchValue = this._advance();\n        var /** @type {?} */ type = this._advance();\n        var /** @type {?} */ cases = [];\n        // read =\n        while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {\n            var /** @type {?} */ expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var /** @type {?} */ value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var /** @type {?} */ start = this._advance();\n        var /** @type {?} */ exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var /** @type {?} */ end = this._advance();\n        exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));\n            return null;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var /** @type {?} */ exp = [];\n        var /** @type {?} */ expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||\n                this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var /** @type {?} */ text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var /** @type {?} */ parent = this._getParentElement();\n            if (parent != null && parent.children.length == 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text(text, token.sourceSpan));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ el = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(el.name).isVoid) {\n                this._elementStack.pop();\n            }\n        }\n    };\n    /**\n     * @param {?} startTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var /** @type {?} */ prefix = startTagToken.parts[0];\n        var /** @type {?} */ name = startTagToken.parts[1];\n        var /** @type {?} */ attrs = [];\n        while (this._peek.type === TokenType$1.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var /** @type {?} */ selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var /** @type {?} */ tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType$1.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var /** @type {?} */ end = this._peek.sourceSpan.start;\n        var /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var /** @type {?} */ el = new Element(fullName, attrs, [], span, span, null);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _TreeBuilder.prototype._pushElement = function (el) {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ parentEl = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n                this._elementStack.pop();\n            }\n        }\n        var /** @type {?} */ tagDef = this.getTagDefinition(el.name);\n        var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;\n        if (parent && tagDef.requireExtraParent(parent.name)) {\n            var /** @type {?} */ newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n            this._insertBeforeContainer(parent, container, newParent);\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    /**\n     * @param {?} endTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var /** @type {?} */ errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    /**\n     * @param {?} fullName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var /** @type {?} */ el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var /** @type {?} */ end = attrName.sourceSpan.end;\n        var /** @type {?} */ value = '';\n        var /** @type {?} */ valueSpan;\n        if (this._peek.type === TokenType$1.ATTR_VALUE) {\n            var /** @type {?} */ valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var /** @type {?} */ container = null;\n        for (var /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {\n            if (this._elementStack[i].name !== 'ng-container') {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: this._elementStack[this._elementStack.length - 1], container: container };\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var /** @type {?} */ parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * \\@internal\n     * @param {?} parent\n     * @param {?} container\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var /** @type {?} */ index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    /**\n     * @param {?} prefix\n     * @param {?} localName\n     * @param {?} parentElement\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix == null) {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix;\n            if (prefix == null && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\n/**\n * @param {?} stack\n * @param {?} element\n * @return {?}\n */\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = (function () {\n    /**\n     * @param {?} nodes message AST\n     * @param {?} placeholders maps placeholder names to static content\n     * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n    }\n    return Message;\n}());\nvar Text$1 = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text$1(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Text$1.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text$1;\n}());\nvar Container = (function () {\n    /**\n     * @param {?} children\n     * @param {?} sourceSpan\n     */\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n    return Container;\n}());\nvar Icu = (function () {\n    /**\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     */\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n    return Icu;\n}());\nvar TagPlaceholder = (function () {\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} startName\n     * @param {?} closeName\n     * @param {?} children\n     * @param {?} isVoid\n     * @param {?} sourceSpan\n     */\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n    return TagPlaceholder;\n}());\nvar Placeholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n    return Placeholder;\n}());\nvar IcuPlaceholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n    return IcuPlaceholder;\n}());\nvar CloneVisitor = (function () {\n    function CloneVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var /** @type {?} */ msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\nvar RecurseVisitor = (function () {\n    function RecurseVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    ;\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    ;\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    ;\n    return RecurseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * \\@internal\n */\nvar PlaceholderRegistry = (function () {\n    function PlaceholderRegistry() {\n        this._placeHolderNameCounts = {};\n        this._signatureToName = {};\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var /** @type {?} */ signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} name\n     * @param {?} content\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var /** @type {?} */ upperName = name.toUpperCase();\n        var /** @type {?} */ signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var /** @type {?} */ start = \"<\" + tag;\n        var /** @type {?} */ strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var /** @type {?} */ end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n    /**\n     * @param {?} base\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var /** @type {?} */ id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, id) { return visitor.toI18nMessage(nodes, meaning, description, id); };\n}\nvar _I18nVisitor = (function () {\n    /**\n     * @param {?} _expressionParser\n     * @param {?} _interpolationConfig\n     */\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     * @return {?}\n     */\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, id) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        var /** @type {?} */ i18nodes = visitAll(this, nodes, {});\n        return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var /** @type {?} */ children = visitAll(this, el.children);\n        var /** @type {?} */ attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = el.sourceSpan.toString();\n        var /** @type {?} */ closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        this._icuDepth++;\n        var /** @type {?} */ i18nIcuCases = {};\n        var /** @type {?} */ i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return i18nIcu;\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        var /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Unreachable code');\n    };\n    /**\n     * @param {?} text\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n        var /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var /** @type {?} */ nodes = [];\n        var /** @type {?} */ container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var /** @type {?} */ expression = splitInterpolation.expressions[i];\n            var /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = (function (_super) {\n    __extends(I18nError, _super);\n    /**\n     * @param {?} span\n     * @param {?} msg\n     */\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\n/**\n * Extract translatable messages from an html AST\n * @param {?} nodes\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\n/**\n * @param {?} nodes\n * @param {?} translations\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = (function () {\n    /**\n     * @param {?} messages\n     * @param {?} errors\n     */\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode = {};\n_VisitorMode.Extract = 0;\n_VisitorMode.Merge = 1;\n_VisitorMode[_VisitorMode.Extract] = \"Extract\";\n_VisitorMode[_VisitorMode.Merge] = \"Merge\";\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * \\@internal\n */\nvar _Visitor = (function () {\n    /**\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     */\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     * @param {?} nodes\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     * @param {?} nodes\n     * @param {?} translations\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var /** @type {?} */ wrapper = new Element('wrapper', [], nodes, null, null, null);\n        var /** @type {?} */ translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var /** @type {?} */ expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var /** @type {?} */ wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var /** @type {?} */ cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var /** @type {?} */ isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var /** @type {?} */ isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var /** @type {?} */ message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        var /** @type {?} */ nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var /** @type {?} */ wasInI18nNode = this._inI18nNode;\n        var /** @type {?} */ wasInImplicitNode = this._inImplicitNode;\n        var /** @type {?} */ childNodes = [];\n        var /** @type {?} */ translatedChildNodes;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var /** @type {?} */ i18nAttr = _getI18nAttr(el);\n        var /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var /** @type {?} */ isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var /** @type {?} */ message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var /** @type {?} */ visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    /**\n     * @param {?} mode\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = void 0;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var /** @type {?} */ explicitAttrNameToValue = {};\n        var /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?=} msgMeta\n     * @return {?}\n     */\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {\n            // Do not create empty messages\n            return;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var /** @type {?} */ message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    /**\n     * @param {?} el\n     * @param {?} message\n     * @return {?}\n     */\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var /** @type {?} */ attributes = el.attrs;\n        var /** @type {?} */ i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var /** @type {?} */ translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var /** @type {?} */ message = _this._createI18nMessage([attr], meaning, description, id);\n                var /** @type {?} */ nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        var /** @type {?} */ value = ((nodes[0])).value;\n                        translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         * @return {?}\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     * @param {?} node\n     * @param {?} directChildren\n     * @return {?}\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var /** @type {?} */ startIndex = this._msgCountAtSectionStart;\n        var /** @type {?} */ significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var /** @type {?} */ i = this._messages.length - 1; i >= startIndex; i--) {\n                var /** @type {?} */ ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = void 0;\n    };\n    /**\n     * @param {?} node\n     * @param {?} msg\n     * @return {?}\n     */\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    };\n    return _Visitor;\n}());\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isOpeningComment(n) {\n    return n instanceof Comment && n.value && n.value.startsWith('i18n');\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isClosingComment(n) {\n    return n instanceof Comment && n.value && n.value === '/i18n';\n}\n/**\n * @param {?} p\n * @return {?}\n */\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\n/**\n * @param {?} i18n\n * @return {?}\n */\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var /** @type {?} */ idIndex = i18n.indexOf(ID_SEPARATOR);\n    var /** @type {?} */ descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], meaningAndDesc = _a[0], id = _a[1];\n    var _b = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = (function (_super) {\n    __extends(XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @return {?}\n     */\n    XmlParser.prototype.parse = function (source, url, parseExpansionForms) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);\n    };\n    return XmlParser;\n}(Parser$1));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\n/**\n * @param {?} message\n * @return {?}\n */\nfunction decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    var /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();\n    var /** @type {?} */ parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * \\@internal\n */\nvar _SerializerVisitor = (function () {\n    function _SerializerVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * \\@internal\n */\nvar _SerializerIgnoreIcuExpVisitor = (function (_super) {\n    __extends(_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n * @param {?} str\n * @return {?}\n */\nfunction sha1(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);\n    var /** @type {?} */ len = utf8.length * 8;\n    var /** @type {?} */ w = new Array(80);\n    var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var /** @type {?} */ i = 0; i < words32.length; i += 16) {\n        var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];\n        for (var /** @type {?} */ j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var _c = fk(j, b, c, d), f = _c[0], k = _c[1];\n            var /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];\n        }\n        _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n    var _d, _e;\n}\n/**\n * @param {?} index\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n * @param {?} str\n * @return {?}\n */\nfunction fingerprint(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var _a = [hash32(utf8, 0), hash32(utf8, 102072)], hi = _a[0], lo = _a[1];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\n/**\n * @param {?} msg\n * @param {?} meaning\n * @return {?}\n */\nfunction computeMsgId(msg, meaning) {\n    var _a = fingerprint(msg), hi = _a[0], lo = _a[1];\n    if (meaning) {\n        var _b = fingerprint(meaning), him = _b[0], lom = _b[1];\n        _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n    var _c;\n}\n/**\n * @param {?} str\n * @param {?} c\n * @return {?}\n */\nfunction hash32(str, c) {\n    var _a = [0x9e3779b9, 0x9e3779b9], a = _a[0], b = _a[1];\n    var /** @type {?} */ i;\n    var /** @type {?} */ len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n    var _b;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction mix(_a) {\n    var a = _a[0], b = _a[1], c = _a[2];\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\nvar Endian = {};\nEndian.Little = 0;\nEndian.Big = 1;\nEndian[Endian.Little] = \"Little\";\nEndian[Endian.Big] = \"Big\";\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32to64(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);\n    var /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n/**\n * @param {?} __0\n * @param {?} __1\n * @return {?}\n */\nfunction add64(_a, _b) {\n    var ah = _a[0], al = _a[1];\n    var bh = _b[0], bl = _b[1];\n    var _c = add32to64(al, bl), carry = _c[0], l = _c[1];\n    var /** @type {?} */ h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sub32(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);\n    var /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n/**\n * @param {?} a\n * @param {?} count\n * @return {?}\n */\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n/**\n * @param {?} __0\n * @param {?} count\n * @return {?}\n */\nfunction rol64(_a, count) {\n    var hi = _a[0], lo = _a[1];\n    var /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));\n    var /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\n/**\n * @param {?} str\n * @param {?} endian\n * @return {?}\n */\nfunction stringToWords32(str, endian) {\n    var /** @type {?} */ words32 = Array((str.length + 3) >>> 2);\n    for (var /** @type {?} */ i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @return {?}\n */\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @param {?} endian\n * @return {?}\n */\nfunction wordAt(str, index, endian) {\n    var /** @type {?} */ word = 0;\n    if (endian === Endian.Big) {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * @param {?} words32\n * @return {?}\n */\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\n/**\n * @param {?} word\n * @return {?}\n */\nfunction word32ToByteString(word) {\n    var /** @type {?} */ str = '';\n    for (var /** @type {?} */ i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToHexString(str) {\n    var /** @type {?} */ hex = '';\n    for (var /** @type {?} */ i = 0; i < str.length; i++) {\n        var /** @type {?} */ b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToDecString(str) {\n    var /** @type {?} */ decimal = '';\n    var /** @type {?} */ toThePower = '1';\n    for (var /** @type {?} */ i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n/**\n * @param {?} x\n * @param {?} y\n * @return {?}\n */\nfunction addBigInt(x, y) {\n    var /** @type {?} */ sum = '';\n    var /** @type {?} */ len = Math.max(x.length, y.length);\n    for (var /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {\n        var /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\n/**\n * @param {?} num\n * @param {?} b\n * @return {?}\n */\nfunction numberTimesBigInt(num, b) {\n    var /** @type {?} */ product = '';\n    var /** @type {?} */ bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar Serializer = (function () {\n    function Serializer() {\n    }\n    /**\n     * @abstract\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Serializer.prototype.write = function (messages, locale) { };\n    /**\n     * @abstract\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Serializer.prototype.load = function (content, url) { };\n    /**\n     * @abstract\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.digest = function (message) { };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.createNameMapper = function (message) { return null; };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = (function (_super) {\n    __extends(SimplePlaceholderMapper, _super);\n    /**\n     * @param {?} message\n     * @param {?} mapName\n     */\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    /**\n     * @param {?} publicName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) { return null; };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) { this.visitPlaceholderName(ph.name); };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var /** @type {?} */ publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var /** @type {?} */ nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor$1 = (function () {\n    function _Visitor$1() {\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitTag = function (tag) {\n        var _this = this;\n        var /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var /** @type {?} */ strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitText = function (text) { return text.value; };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    /**\n     * @param {?} attrs\n     * @return {?}\n     */\n    _Visitor$1.prototype._serializeAttributes = function (attrs) {\n        var /** @type {?} */ strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor$1;\n}());\nvar _visitor = new _Visitor$1();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = (function () {\n    /**\n     * @param {?} unescapedAttrs\n     */\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n    return Declaration;\n}());\nvar Doctype = (function () {\n    /**\n     * @param {?} rootTag\n     * @param {?} dtd\n     */\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n    return Doctype;\n}());\nvar Tag = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} unescapedAttrs\n     * @param {?=} children\n     */\n    function Tag(name, unescapedAttrs, children) {\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        var _this = this;\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n    return Tag;\n}());\nvar Text$2 = (function () {\n    /**\n     * @param {?} unescapedValue\n     */\n    function Text$2(unescapedValue) {\n        this.value = _escapeXml(unescapedValue);\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Text$2.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text$2;\n}());\nvar CR = (function (_super) {\n    __extends(CR, _super);\n    /**\n     * @param {?=} ws\n     */\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n/**\n * @param {?} text\n * @return {?}\n */\nfunction _escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG = 'x';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG = 'source';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar Xliff = (function (_super) {\n    __extends(Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor();\n        var /** @type {?} */ transUnits = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        var /** @type {?} */ body = new Tag('body', {}, transUnits.concat([new CR(4)]));\n        var /** @type {?} */ file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var /** @type {?} */ xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, mlNodesByMsgId = _a.mlNodesByMsgId, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(mlNodesByMsgId).forEach(function (msgId) {\n            var _a = converter.convert(mlNodesByMsgId[msgId]), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff.prototype.digest = function (message) { return digest(message); };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = (function () {\n    function _WriteVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        if (this._isInIcu) {\n            // nested ICU is not supported\n            throw new Error('xliff does not support nested ICU messages');\n        }\n        this._isInIcu = true;\n        // TODO(vicb): support ICU messages\n        // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html\n        // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html\n        var /** @type {?} */ nodes = [];\n        this._isInIcu = false;\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ ctype = getCtypeForTag(ph.tag);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._isInIcu = false;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor;\n}());\nvar XliffParser = (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlNodes = [];\n        this._mlNodesByMsgId = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            mlNodesByMsgId: this._mlNodesByMsgId,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlNodes = null;\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._mlNodesByMsgId.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (this._unitMlNodes) {\n                            this._mlNodesByMsgId[id] = this._unitMlNodes;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                this._unitMlNodes = element.children;\n                break;\n            case _FILE_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XliffParser;\n}());\nvar XmlToI18n = (function () {\n    function XmlToI18n() {\n    }\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    XmlToI18n.prototype.convert = function (nodes) {\n        this._errors = [];\n        return {\n            i18nNodes: visitAll(this, nodes),\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"id\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansion = function (icu, context) { };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$1 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$1 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit';\nvar Xliff2 = (function (_super) {\n    __extends(Xliff2, _super);\n    function Xliff2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff2.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor$1();\n        var /** @type {?} */ units = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ unit = new Tag(_UNIT_TAG$1, { id: message.id });\n            if (message.description || message.meaning) {\n                var /** @type {?} */ notes = new Tag('notes');\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\n                }\n                notes.children.push(new CR(6));\n                unit.children.push(new CR(6), notes);\n            }\n            var /** @type {?} */ segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        var /** @type {?} */ file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, units.concat([new CR(2)]));\n        var /** @type {?} */ xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliff2Parser = new Xliff2Parser();\n        var _a = xliff2Parser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff2 parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2.prototype.digest = function (message) { return decimalDigest(message); };\n    return Xliff2;\n}(Serializer));\nvar _WriteVisitor$1 = (function () {\n    function _WriteVisitor$1() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            var /** @type {?} */ tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: \"<\" + ph.tag + \"/>\",\n            });\n            return [tagPh];\n        }\n        var /** @type {?} */ tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: \"<\" + ph.tag + \">\",\n            dispEnd: \"</\" + ph.tag + \">\",\n        });\n        var /** @type {?} */ nodes = [].concat.apply([], ph.children.map(function (node) { return node.visit(_this); }));\n        if (nodes.length) {\n            nodes.forEach(function (node) { return tagPc.children.push(node); });\n        }\n        else {\n            tagPc.children.push(new Text$2(''));\n        }\n        return [tagPc];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.name,\n                disp: \"{{\" + ph.value + \"}}\",\n            })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: (this._nextPlaceholderId++).toString() })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._nextPlaceholderId = 0;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor$1;\n}());\nvar Xliff2Parser = (function () {\n    function Xliff2Parser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2Parser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG$1:\n                // ignore source message\n                break;\n            case _TARGET_TAG$1:\n                var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'trgLang'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                var /** @type {?} */ versionAttr = element.attrs.find(function (attr) { return attr.name === 'version'; });\n                if (versionAttr) {\n                    var /** @type {?} */ version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, \"The XLIFF file version \" + version + \" is not compatible with XLIFF 2.0 serializer\");\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2Parser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return Xliff2Parser;\n}());\nvar XmlToI18n$1 = (function () {\n    function XmlToI18n$1() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitElement = function (el, context) {\n        var _this = this;\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'equiv'; });\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equiv\\\" attribute\");\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                var /** @type {?} */ startAttr = el.attrs.find(function (attr) { return attr.name === 'equivStart'; });\n                var /** @type {?} */ endAttr = el.attrs.find(function (attr) { return attr.name === 'equivEnd'; });\n                if (!startAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivStart\\\" attribute\");\n                }\n                else if (!endAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivEnd\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ startId = startAttr.value;\n                    var /** @type {?} */ endId = endAttr.value;\n                    var /** @type {?} */ nodes = [];\n                    return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(el.children.map(function (node) { return node.visit(_this, null); }), [new Placeholder('', endId, el.sourceSpan)]));\n                }\n                break;\n            default:\n                this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat.apply([], visitAll(this, icuCase.expression)),\n        };\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$1.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n$1;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _EXEMPLE_TAG = 'ex';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = (function (_super) {\n    __extends(Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xmb.prototype.write = function (messages, locale) {\n        var /** @type {?} */ exampleVisitor = new ExampleVisitor();\n        var /** @type {?} */ visitor = new _Visitor$2();\n        var /** @type {?} */ rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var /** @type {?} */ attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$2 = (function () {\n    function _Visitor$2() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"<\" + ph.tag + \">\")]);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.startName }, [startEx]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"</\" + ph.tag + \">\")]);\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.closeName }, [closeEx]);\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _Visitor$2.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _Visitor$2;\n}());\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\nvar ExampleVisitor = (function () {\n    function ExampleVisitor() {\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG$2) {\n            if (!tag.children || tag.children.length == 0) {\n                var /** @type {?} */ exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitText = function (text) { };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n/**\n * @param {?} internalName\n * @return {?}\n */\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\nvar Xtb = (function (_super) {\n    __extends(Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xtb.prototype.write = function (messages, locale) { throw new Error('Unsupported'); };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var /** @type {?} */ xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$2();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var /** @type {?} */ valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\n/**\n * @param {?} messages\n * @param {?} id\n * @param {?} valueFn\n * @return {?}\n */\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var /** @type {?} */ value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\nvar XtbParser = (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xtb\n     * @param {?} url\n     * @return {?}\n     */\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var /** @type {?} */ xml = new XmlParser().parse(xtb, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var /** @type {?} */ langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var /** @type {?} */ innerTextStart = element.startSourceSpan.end.offset;\n                        var /** @type {?} */ innerTextEnd = element.endSourceSpan.start.offset;\n                        var /** @type {?} */ content = element.startSourceSpan.start.file.content;\n                        var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XtbParser;\n}());\nvar XmlToI18n$2 = (function () {\n    function XmlToI18n$2() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$3) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$3 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$2.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n$2;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = (function (_super) {\n    __extends(HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);\n    };\n    return HtmlParser;\n}(Parser$1));\nHtmlParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nHtmlParser.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} locale\n     * @param {?=} digest\n     * @param {?=} mapperFactory\n     * @param {?=} missingTranslationStrategy\n     * @param {?=} console\n     */\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @param {?} serializer\n     * @param {?} missingTranslationStrategy\n     * @param {?=} console\n     * @return {?}\n     */\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var /** @type {?} */ digestFn = function (m) { return serializer.digest(m); };\n        var /** @type {?} */ mapperFactory = function (m) { return serializer.createNameMapper(m); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} _locale\n     * @param {?=} _digest\n     * @param {?=} _mapperFactory\n     * @param {?=} _missingTranslationStrategy\n     * @param {?=} _console\n     */\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var /** @type {?} */ text = this._convertToText(srcMsg);\n        // text to html\n        var /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var /** @type {?} */ html = new HtmlParser().parse(text, url, true);\n        return {\n            nodes: html.rootNodes,\n            errors: this._errors.concat(html.errors),\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var /** @type {?} */ phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ tag = \"\" + ph.tag;\n        var /** @type {?} */ attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var /** @type {?} */ children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var /** @type {?} */ id = this._digest(srcMsg);\n        var /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var /** @type {?} */ nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? mapper.toInternalName(name) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Error) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var /** @type {?} */ text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var /** @type {?} */ context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} msg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?=} translations\n     * @param {?=} translationsFormat\n     * @param {?=} missingTranslation\n     * @param {?=} console\n     */\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n        if (!this._translationBundle) {\n            // Do not enable i18n when no translation bundle is provided\n            return parseResult;\n        }\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\n/**\n * @param {?=} format\n * @return {?}\n */\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = assetUrl('core');\nvar Identifiers = (function () {\n    function Identifiers() {\n    }\n    return Identifiers;\n}());\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_2\" /* ANALYZE_FOR_ENTRY_COMPONENTS */]\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"K\" /* ElementRef */] };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"N\" /* NgModuleRef */] };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"P\" /* ViewContainerRef */] };\nIdentifiers.ChangeDetectorRef = { name: 'ChangeDetectorRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"X\" /* ChangeDetectorRef */] };\nIdentifiers.QueryList = { name: 'QueryList', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_3\" /* QueryList */] };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Q\" /* TemplateRef */] };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'ɵCodegenComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_4\" /* ɵCodegenComponentFactoryResolver */]\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"O\" /* ComponentFactoryResolver */]\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_5\" /* ComponentFactory */] };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_6\" /* ComponentRef */] };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_7\" /* NgModuleFactory */] };\nIdentifiers.NgModuleInjector = {\n    name: 'ɵNgModuleInjector',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_8\" /* ɵNgModuleInjector */],\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'ɵregisterModuleFactory',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_9\" /* ɵregisterModuleFactory */],\n};\nIdentifiers.Injector = { name: 'Injector', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_10\" /* Injector */] };\nIdentifiers.ViewEncapsulation = { name: 'ViewEncapsulation', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */] };\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */]\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */],\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"E\" /* LOCALE_ID */] };\nIdentifiers.TRANSLATIONS_FORMAT = { name: 'TRANSLATIONS_FORMAT', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_11\" /* TRANSLATIONS_FORMAT */] };\nIdentifiers.inlineInterpolate = { name: 'ɵinlineInterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_12\" /* ɵinlineInterpolate */] };\nIdentifiers.interpolate = { name: 'ɵinterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_13\" /* ɵinterpolate */] };\nIdentifiers.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_14\" /* ɵEMPTY_ARRAY */] };\nIdentifiers.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_15\" /* ɵEMPTY_MAP */] };\nIdentifiers.Renderer = { name: 'Renderer', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"L\" /* Renderer */] };\nIdentifiers.viewDef = { name: 'ɵvid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵvid */] };\nIdentifiers.elementDef = { name: 'ɵeld', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */] };\nIdentifiers.anchorDef = { name: 'ɵand', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_18\" /* ɵand */] };\nIdentifiers.textDef = { name: 'ɵted', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_19\" /* ɵted */] };\nIdentifiers.directiveDef = { name: 'ɵdid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_20\" /* ɵdid */] };\nIdentifiers.providerDef = { name: 'ɵprd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_21\" /* ɵprd */] };\nIdentifiers.queryDef = { name: 'ɵqud', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_22\" /* ɵqud */] };\nIdentifiers.pureArrayDef = { name: 'ɵpad', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_23\" /* ɵpad */] };\nIdentifiers.pureObjectDef = { name: 'ɵpod', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_24\" /* ɵpod */] };\nIdentifiers.purePipeDef = { name: 'ɵppd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_25\" /* ɵppd */] };\nIdentifiers.pipeDef = { name: 'ɵpid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_26\" /* ɵpid */] };\nIdentifiers.nodeValue = { name: 'ɵnov', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_27\" /* ɵnov */] };\nIdentifiers.ngContentDef = { name: 'ɵncd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_28\" /* ɵncd */] };\nIdentifiers.unwrapValue = { name: 'ɵunv', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵunv */] };\nIdentifiers.createRendererType2 = { name: 'ɵcrt', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_30\" /* ɵcrt */] };\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.ViewDefinition = {\n    name: 'ɵViewDefinition',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.createComponentFactory = { name: 'ɵccf', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_31\" /* ɵccf */] };\n/**\n * @param {?} pkg\n * @param {?=} path\n * @param {?=} type\n * @return {?}\n */\nfunction assetUrl(pkg, path, type) {\n    if (path === void 0) { path = null; }\n    if (type === void 0) { type = 'src'; }\n    if (path == null) {\n        return \"@angular/\" + pkg;\n    }\n    else {\n        return \"@angular/\" + pkg + \"/\" + type + \"/\" + path;\n    }\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction resolveIdentifier(identifier) {\n    var /** @type {?} */ name = identifier.name;\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].resolveIdentifier(name, identifier.moduleUrl, null, identifier.runtime);\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifier(identifier) {\n    return { reference: resolveIdentifier(identifier) };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction identifierToken(identifier) {\n    return { identifier: identifier };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifierToken(identifier) {\n    return identifierToken(createIdentifier(identifier));\n}\n/**\n * @param {?} enumType\n * @param {?} name\n * @return {?}\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n * @param {?} nodes\n * @return {?}\n */\nfunction expandNodes(nodes) {\n    var /** @type {?} */ expander = new _Expander();\n    return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = (function () {\n    /**\n     * @param {?} nodes\n     * @param {?} expanded\n     * @param {?} errors\n     */\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = (function (_super) {\n    __extends(ExpansionError, _super);\n    /**\n     * @param {?} span\n     * @param {?} errorMsg\n     */\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * \\@internal\n */\nvar _Expander = (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitText = function (text, context) { return text; };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitComment = function (comment, context) { return comment; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandPluralForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n        }\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        return new Element(\"ng-template\", [new Attribute$1('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandDefaultForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element(\"ng-template\", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element(\"ng-template\", [new Attribute$1('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = (function (_super) {\n    __extends(ProviderError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     */\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = (function () {\n    /**\n     * @param {?} component\n     */\n    function ProviderViewContext(component) {\n        var _this = this;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = (function () {\n    /**\n     * @param {?} viewContext\n     * @param {?} _parent\n     * @param {?} _isViewRoot\n     * @param {?} _directiveAsts\n     * @param {?} attrs\n     * @param {?} refs\n     * @param {?} isTemplate\n     * @param {?} contentQueryStartId\n     * @param {?} _sourceSpan\n     */\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._hasViewContainer = false;\n        this._queriedTokens = new Map();\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createIdentifierToken(Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value || createIdentifierToken(Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(resolveIdentifier(Identifiers.ViewContainerRef))) {\n            this._hasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return Array.from(this._transformedProviders.values());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var /** @type {?} */ sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedHasViewContainer\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._hasViewContainer; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ allMatches = [];\n            this._queriedTokens.forEach(function (matches) { allMatches.push.apply(allMatches, matches); });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} token\n     * @param {?} defaultValue\n     * @param {?} queryReadTokens\n     * @return {?}\n     */\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var /** @type {?} */ queryValue = query.meta.read || defaultValue;\n            var /** @type {?} */ tokenRef = tokenReference(queryValue);\n            var /** @type {?} */ queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var /** @type {?} */ result = [];\n        var /** @type {?} */ currentEl = this;\n        var /** @type {?} */ distance = 0;\n        var /** @type {?} */ queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, queries);\n        }\n        return result;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = provider.useExisting;\n            var /** @type {?} */ transformedDeps;\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = null; }\n        if (dep.isAttribute) {\n            var /** @type {?} */ attrValue = this._attrs[dep.token.value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Renderer) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                    this._hasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = null; }\n        var /** @type {?} */ currElement = this;\n        var /** @type {?} */ currEager = eager;\n        var /** @type {?} */ result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var /** @type {?} */ prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(dep.token) ||\n                    this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? result = { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = (function () {\n    /**\n     * @param {?} ngModule\n     * @param {?} extraProviders\n     * @param {?} sourceSpan\n     */\n    function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n    }\n    /**\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var /** @type {?} */ errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        return Array.from(this._transformedProviders.values());\n    };\n    /**\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = provider.useExisting;\n            var /** @type {?} */ transformedDeps;\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} dep\n     * @param {?=} eager\n     * @param {?=} requestorSourceSpan\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = null; }\n        var /** @type {?} */ foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector) ||\n                tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        var /** @type {?} */ result = dep;\n        if (dep.isSelf && !foundLocal) {\n            if (dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n            else {\n                this._errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), requestorSourceSpan));\n            }\n        }\n        return result;\n    };\n    return NgModuleProviderAnalyzer;\n}());\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n}\n/**\n * @param {?} directives\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @return {?}\n */\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var /** @type {?} */ providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var /** @type {?} */ directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n    });\n    return providersByToken;\n}\n/**\n * @param {?} providers\n * @param {?} providerType\n * @param {?} eager\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @param {?} targetProvidersByToken\n * @return {?}\n */\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n    providers.forEach(function (provider) {\n        var /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var /** @type {?} */ lifecycleHooks = provider.token.identifier &&\n                ((provider.token.identifier)).lifecycleHooks ?\n                ((provider.token.identifier)).lifecycleHooks :\n                [];\n            var /** @type {?} */ isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var /** @type {?} */ viewQueryId = 1;\n    var /** @type {?} */ viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\n/**\n * @param {?} contentQueryStartId\n * @param {?} directives\n * @return {?}\n */\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var /** @type {?} */ contentQueryId = contentQueryStartId;\n    var /** @type {?} */ contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\n/**\n * @param {?} map\n * @param {?} query\n * @return {?}\n */\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var /** @type {?} */ entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar ElementSchemaRegistry = (function () {\n    function ElementSchemaRegistry() {\n    }\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} elementName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.allKnownElementNames = function () { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateProperty = function (name) { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateAttribute = function (name) { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };\n    /**\n     * @abstract\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };\n    return ElementSchemaRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = (function () {\n    /**\n     * @param {?} style\n     * @param {?} styleUrls\n     */\n    function StyleWithImports(style$$1, styleUrls) {\n        this.style = style$$1;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\n/**\n * @param {?} url\n * @return {?}\n */\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the \\@import urls that\n * are either relative or don't have a `package:` scheme\n * @param {?} resolver\n * @param {?} baseUrl\n * @param {?} cssText\n * @return {?}\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var /** @type {?} */ foundUrls = [];\n    var /** @type {?} */ modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_COMMENT_REGEXP = /\\/\\*.+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar ANIMATE_PROP_PREFIX = 'animate-';\nvar BoundPropertyType = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n/**\n * Represents a parsed property.\n */\nvar BoundProperty = (function () {\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} sourceSpan\n     */\n    function BoundProperty(name, expression, type, sourceSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    Object.defineProperty(BoundProperty.prototype, \"isLiteral\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundProperty.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.ANIMATION; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundProperty;\n}());\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = (function () {\n    /**\n     * @param {?} _exprParser\n     * @param {?} _interpolationConfig\n     * @param {?} _schemaRegistry\n     * @param {?} pipes\n     * @param {?} _targetErrors\n     */\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n        var _this = this;\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this._targetErrors = _targetErrors;\n        this.pipesByName = new Map();\n        this._usedPipes = new Map();\n        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\n    }\n    /**\n     * @return {?}\n     */\n    BindingParser.prototype.getUsedPipes = function () { return Array.from(this._usedPipes.values()); };\n    /**\n     * @param {?} dirMeta\n     * @param {?} elementSelector\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var /** @type {?} */ boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(elementSelector, prop); });\n        }\n    };\n    /**\n     * @param {?} dirMeta\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var /** @type {?} */ targetEventAsts_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEventAsts_1;\n        }\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetVars\n     * @return {?}\n     */\n    BindingParser.prototype.parseInlineTemplateBinding = function (prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n        var /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n        for (var /** @type {?} */ i = 0; i < bindings.length; i++) {\n            var /** @type {?} */ binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.expression) {\n                    _this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        if (_isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} isHost\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (_isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n    };\n    /**\n     * @param {?} value\n     * @param {?} isHostBinding\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} elementSelector\n     * @param {?} boundProp\n     * @return {?}\n     */\n    BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {\n        if (boundProp.isAnimation) {\n            return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE, boundProp.expression, null, boundProp.sourceSpan);\n        }\n        var /** @type {?} */ unit = null;\n        var /** @type {?} */ bindingType;\n        var /** @type {?} */ boundPropertyName = null;\n        var /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var /** @type {?} */ securityContexts;\n        // Check check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = PropertyBindingType.Attribute;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Class;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Style;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n            bindingType = PropertyBindingType.Property;\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n        }\n        return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        if (_isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n        }\n        else {\n            this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {\n        var /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n        var /** @type {?} */ eventName = matches[0];\n        var /** @type {?} */ phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n                    targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];\n        var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    /**\n     * @param {?} errors\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n            var error = errors_1[_i];\n            this._reportError(error.message, sourceSpan);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast) {\n            var /** @type {?} */ collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var /** @type {?} */ pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} propName the name of the property / attribute\n     * @param {?} sourceSpan\n     * @param {?} isAttr true when binding to an attribute\n     * @return {?}\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = (function (_super) {\n    __extends(PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name) {\n    return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var /** @type {?} */ ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var /** @type {?} */ possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));\n    });\n    return ctxs.length === 0 ? [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar NG_CONTENT_ELEMENT = 'ng-content';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction preparseElement(ast) {\n    var /** @type {?} */ selectAttr = null;\n    var /** @type {?} */ hrefAttr = null;\n    var /** @type {?} */ relAttr = null;\n    var /** @type {?} */ nonBindable = false;\n    var /** @type {?} */ projectAs = null;\n    ast.attrs.forEach(function (attr) {\n        var /** @type {?} */ lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var /** @type {?} */ nodeName = ast.name.toLowerCase();\n    var /** @type {?} */ type = PreparsedElementType.OTHER;\n    if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType = {};\nPreparsedElementType.NG_CONTENT = 0;\nPreparsedElementType.STYLE = 1;\nPreparsedElementType.STYLESHEET = 2;\nPreparsedElementType.SCRIPT = 3;\nPreparsedElementType.OTHER = 4;\nPreparsedElementType[PreparsedElementType.NG_CONTENT] = \"NG_CONTENT\";\nPreparsedElementType[PreparsedElementType.STYLE] = \"STYLE\";\nPreparsedElementType[PreparsedElementType.STYLESHEET] = \"STYLESHEET\";\nPreparsedElementType[PreparsedElementType.SCRIPT] = \"SCRIPT\";\nPreparsedElementType[PreparsedElementType.OTHER] = \"OTHER\";\nvar PreparsedElement = (function () {\n    /**\n     * @param {?} type\n     * @param {?} selectAttr\n     * @param {?} hrefAttr\n     * @param {?} nonBindable\n     * @param {?} projectAs\n     */\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\n/**\n * @param {?} selectAttr\n * @return {?}\n */\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\nvar NG_TEMPLATE_ELEMENT = 'ng-template';\n// deprecated in 4.x\nvar TEMPLATE_ELEMENT = 'template';\n// deprecated in 4.x\nvar TEMPLATE_ATTR = 'template';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar CLASS_ATTR = 'class';\nvar TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\nvar TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';\nvar TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';\nvar warningCounts = {};\n/**\n * @param {?} warnings\n * @return {?}\n */\nfunction warnOnlyOnce(warnings) {\n    return function (error) {\n        if (warnings.indexOf(error.msg) !== -1) {\n            warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;\n            return warningCounts[error.msg] <= 1;\n        }\n        return true;\n    };\n}\n/**\n * Provides an array of {@link TemplateAstVisitor}s which will be used to transform\n * parsed templates before compilation is invoked, allowing custom expression syntax\n * and other advanced transformations.\n *\n * This is currently an internal-only feature and not meant for general use.\n */\nvar TEMPLATE_TRANSFORMS = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('TemplateTransforms');\nvar TemplateParseError = (function (_super) {\n    __extends(TemplateParseError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     * @param {?} level\n     */\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = (function () {\n    /**\n     * @param {?=} templateAst\n     * @param {?=} usedPipes\n     * @param {?=} errors\n     */\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _exprParser\n     * @param {?} _schemaRegistry\n     * @param {?} _htmlParser\n     * @param {?} _console\n     * @param {?} transforms\n     */\n    function TemplateParser(_config, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {\n        var /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);\n        var /** @type {?} */ warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; }).filter(warnOnlyOnce([\n            TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING\n        ]));\n        var /** @type {?} */ errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var /** @type {?} */ errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        return { template: result.templateAst, pipes: result.usedPipes };\n    };\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {\n        return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, directives, pipes, schemas);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?} component\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        var /** @type {?} */ usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);\n            var /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);\n            var /** @type {?} */ providerViewContext = new ProviderViewContext(component);\n            var /** @type {?} */ interpolationConfig = void 0;\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var /** @type {?} */ bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n            var /** @type {?} */ parseVisitor = new TemplateParseVisitor(this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, providerViewContext.errors);\n            usedPipes.push.apply(usedPipes, bindingParser.getUsedPipes());\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?=} forced\n     * @return {?}\n     */\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, expandedHtmlAst.errors);\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n    };\n    /**\n     * \\@internal\n     * @param {?} result\n     * @param {?} errors\n     * @return {?}\n     */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var /** @type {?} */ existingReferences = [];\n        result.filter(function (element) { return !!((element)).references; })\n            .forEach(function (element) { return ((element)).references.forEach(function (reference) {\n            var /** @type {?} */ name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var /** @type {?} */ error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nTemplateParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nTemplateParser.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: Parser, },\n    { type: ElementSchemaRegistry, },\n    { type: I18NHtmlParser, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [TEMPLATE_TRANSFORMS,] },] },\n]; };\nvar TemplateParseVisitor = (function () {\n    /**\n     * @param {?} config\n     * @param {?} providerViewContext\n     * @param {?} directives\n     * @param {?} _bindingParser\n     * @param {?} _schemaRegistry\n     * @param {?} _schemas\n     * @param {?} _targetErrors\n     */\n    function TemplateParseVisitor(config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n        var /** @type {?} */ expr = this._bindingParser.parseInterpolation(text.value, text.sourceSpan);\n        return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n            new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var /** @type {?} */ queryStartIndex = this.contentQueryStartId;\n        var /** @type {?} */ nodeName = element.name;\n        var /** @type {?} */ preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ matchableAttrs = [];\n        var /** @type {?} */ elementOrDirectiveProps = [];\n        var /** @type {?} */ elementOrDirectiveRefs = [];\n        var /** @type {?} */ elementVars = [];\n        var /** @type {?} */ events = [];\n        var /** @type {?} */ templateElementOrDirectiveProps = [];\n        var /** @type {?} */ templateMatchableAttrs = [];\n        var /** @type {?} */ templateElementVars = [];\n        var /** @type {?} */ hasInlineTemplates = false;\n        var /** @type {?} */ attrs = [];\n        var /** @type {?} */ isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, function (m, span) { return _this._reportError(m, span, ParseErrorLevel.WARNING); });\n        element.attrs.forEach(function (attr) {\n            var /** @type {?} */ hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            var /** @type {?} */ templateBindingsSource;\n            var /** @type {?} */ prefixToken;\n            var /** @type {?} */ normalizedName = _this._normalizeAttributeName(attr.name);\n            if (_this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {\n                _this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);\n                templateBindingsSource = attr.value;\n            }\n            else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateBindingsSource = attr.value;\n                prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';\n            }\n            var /** @type {?} */ hasTemplateBinding = templateBindingsSource != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                _this._bindingParser.parseInlineTemplateBinding(prefixToken, templateBindingsSource, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var /** @type {?} */ references = [];\n        var /** @type {?} */ boundDirectivePropNames = new Set();\n        var /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n        var /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n        var /** @type {?} */ children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var /** @type {?} */ projectionSelector = preparsedElement.projectAs != null ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(projectionSelector);\n        var /** @type {?} */ parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else if (isTemplateElement) {\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else {\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n            var /** @type {?} */ ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);\n        }\n        if (hasInlineTemplates) {\n            var /** @type {?} */ templateQueryStartIndex = this.contentQueryStartId;\n            var /** @type {?} */ templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n            var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var /** @type {?} */ templateBoundDirectivePropNames = new Set();\n            var /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n            var /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n            var /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n        }\n        return parsedElement;\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} attr\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetEvents\n     * @param {?} targetRefs\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var /** @type {?} */ name = this._normalizeAttributeName(attr.name);\n        var /** @type {?} */ value = attr.value;\n        var /** @type {?} */ srcSpan = attr.sourceSpan;\n        var /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n        var /** @type {?} */ hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        return hasBinding;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetRefs\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\n    };\n    /**\n     * @param {?} selectorMatcher\n     * @param {?} elementCssSelector\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var /** @type {?} */ directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var /** @type {?} */ matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[_this.directivesIndex.get(directive)] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} elementName\n     * @param {?} directives\n     * @param {?} props\n     * @param {?} elementOrDirectiveRefs\n     * @param {?} elementSourceSpan\n     * @param {?} targetReferences\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ matchedReferences = new Set();\n        var /** @type {?} */ component = null;\n        var /** @type {?} */ directiveAsts = directives.map(function (directive) {\n            var /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var /** @type {?} */ directiveProperties = [];\n            var /** @type {?} */ hostProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var /** @type {?} */ hostEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (directive.exportAs == elOrDirRef.value)) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var /** @type {?} */ contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var /** @type {?} */ refToken = null;\n                if (isTemplateElement) {\n                    refToken = createIdentifierToken(Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    /**\n     * @param {?} directiveProperties\n     * @param {?} boundProps\n     * @param {?} targetBoundDirectiveProps\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var /** @type {?} */ boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var /** @type {?} */ prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var /** @type {?} */ elProp = directiveProperties[dirProp];\n                var /** @type {?} */ boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} props\n     * @param {?} boundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return identifierName(directive.directive.type); });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param {?} matchElement Whether any directive has matched on the tag name\n     * @param {?} element the html element\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var /** @type {?} */ errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg +=\n                \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, element.sourceSpan);\n        }\n    };\n    /**\n     * @param {?} directives\n     * @param {?} elementProps\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} events\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var /** @type {?} */ allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var /** @type {?} */ eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} boundProps\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === PropertyBindingType.Property &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var /** @type {?} */ errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = (function () {\n    function NonBindableVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);\n        var /** @type {?} */ children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n        return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return NonBindableVisitor;\n}());\nvar ElementOrDirectiveRef = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    return ElementOrDirectiveRef;\n}());\n/**\n * @param {?} classAttrValue\n * @return {?}\n */\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = (function () {\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} _ngContentIndexMatcher\n     * @param {?} _wildcardNgContentIndex\n     * @param {?} providerContext\n     */\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} directives\n     * @param {?} providerContext\n     * @return {?}\n     */\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var /** @type {?} */ matcher = new SelectorMatcher();\n        var /** @type {?} */ wildcardNgContentIndex = null;\n        var /** @type {?} */ component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var /** @type {?} */ ngContentSelectors = component.directive.template.ngContentSelectors;\n            for (var /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {\n                var /** @type {?} */ selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var /** @type {?} */ ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\n/**\n * @param {?} elementName\n * @param {?} attributes\n * @return {?}\n */\nfunction createElementCssSelector(elementName, attributes) {\n    var /** @type {?} */ cssSelector = new CssSelector();\n    var /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var /** @type {?} */ i = 0; i < attributes.length; i++) {\n        var /** @type {?} */ attrName = attributes[i][0];\n        var /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];\n        var /** @type {?} */ attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var /** @type {?} */ classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n/**\n * @param {?} node\n * @return {?}\n */\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\n/**\n * @template T\n * @param {?} items\n * @return {?}\n */\nfunction removeSummaryDuplicates(items) {\n    var /** @type {?} */ map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n/**\n * @param {?} el\n * @param {?} enableLegacyTemplate\n * @param {?} reportDeprecation\n * @return {?}\n */\nfunction isTemplate(el, enableLegacyTemplate, reportDeprecation) {\n    var /** @type {?} */ tagNoNs = splitNsName(el.name)[1];\n    // `<ng-template>` is an angular construct and is lower case\n    if (tagNoNs === NG_TEMPLATE_ELEMENT)\n        return true;\n    // `<template>` is HTML and case insensitive\n    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n        if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n            reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, el.sourceSpan);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = (function () {\n    function ResourceLoader() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    ResourceLoader.prototype.get = function (url) { return null; };\n    return ResourceLoader;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {\\@link UrlResolver} with no package prefix.\n * @return {?}\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\n/**\n * @return {?}\n */\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\n/**\n * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.\n */\nvar DEFAULT_PACKAGE_URL_PROVIDER = {\n    provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* PACKAGE_ROOT_URL */],\n    useValue: '/'\n};\n/**\n * Used by the {\\@link Compiler} when resolving HTML and CSS template URLs.\n *\n * This class can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n *\n * ## Example\n *\n * {\\@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\n *\n * \\@security When compiling templates at runtime, you must\n * ensure that the entire template comes from a trusted source.\n * Attacker-controlled data introduced by a template could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar UrlResolver = (function () {\n    /**\n     * @param {?=} _packagePrefix\n     */\n    function UrlResolver(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     * @param {?} baseUrl\n     * @param {?} url\n     * @return {?}\n     */\n    UrlResolver.prototype.resolve = function (baseUrl, url) {\n        var /** @type {?} */ resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var /** @type {?} */ resolvedParts = _split(resolvedUrl);\n        var /** @type {?} */ prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolver;\n}());\nUrlResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nUrlResolver.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* PACKAGE_ROOT_URL */],] },] },\n]; };\n/**\n * Extract the scheme of a URL.\n * @param {?} url\n * @return {?}\n */\nfunction getUrlScheme(url) {\n    var /** @type {?} */ match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?=} opt_scheme The scheme such as 'http'.\n * @param {?=} opt_userInfo The user name before the '\\@'.\n * @param {?=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {?=} opt_port The port number.\n * @param {?=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?=} opt_queryData The URI-encoded query data.\n * @param {?=} opt_fragment The URI-encoded fragment identifier.\n * @return {?} The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var /** @type {?} */ out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {\\@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * \\@internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' +\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' +\n    ')?' +\n    '([^?#]+)?' +\n    '(?:\\\\?([^#]*))?' +\n    '(?:#(.*))?' +\n    '$');\nvar _ComponentIndex = {};\n_ComponentIndex.Scheme = 1;\n_ComponentIndex.UserInfo = 2;\n_ComponentIndex.Domain = 3;\n_ComponentIndex.Port = 4;\n_ComponentIndex.Path = 5;\n_ComponentIndex.QueryData = 6;\n_ComponentIndex.Fragment = 7;\n_ComponentIndex[_ComponentIndex.Scheme] = \"Scheme\";\n_ComponentIndex[_ComponentIndex.UserInfo] = \"UserInfo\";\n_ComponentIndex[_ComponentIndex.Domain] = \"Domain\";\n_ComponentIndex[_ComponentIndex.Port] = \"Port\";\n_ComponentIndex[_ComponentIndex.Path] = \"Path\";\n_ComponentIndex[_ComponentIndex.QueryData] = \"QueryData\";\n_ComponentIndex[_ComponentIndex.Fragment] = \"Fragment\";\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {?} uri The URI string to examine.\n * @return {?} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return uri.match(_splitRe);\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {?} path A non-empty path component.\n * @return {?} Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';\n    var /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var /** @type {?} */ segments = path.split('/');\n    var /** @type {?} */ out = [];\n    var /** @type {?} */ up = 0;\n    for (var /** @type {?} */ pos = 0; pos < segments.length; pos++) {\n        var /** @type {?} */ segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n * @param {?} parts\n * @return {?}\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var /** @type {?} */ path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param {?} base The URL acting as the base URL.\n * @param {?} url\n * @return {?}\n */\nfunction _resolveUrl(base, url) {\n    var /** @type {?} */ parts = _split(encodeURI(url));\n    var /** @type {?} */ baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var /** @type {?} */ i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var /** @type {?} */ path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var /** @type {?} */ index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = (function () {\n    /**\n     * @param {?} _resourceLoader\n     * @param {?} _urlResolver\n     * @param {?} _htmlParser\n     * @param {?} _config\n     */\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n    /**\n     * @param {?} normalizedDirective\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);\n        normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });\n    };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var /** @type {?} */ result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    /**\n     * @param {?} prenormData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        var /** @type {?} */ normalizedTemplateSync = null;\n        var /** @type {?} */ normalizedTemplateAsync;\n        if (prenormData.template != null) {\n            if (prenormData.templateUrl != null) {\n                throw syntaxError(\"'\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateSync = this.normalizeTemplateSync(prenormData);\n            normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);\n        }\n        else if (prenormData.templateUrl) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateAsync = this.normalizeTemplateAsync(prenormData);\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType));\n        }\n        if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {\n            // sync case\n            return new SyncAsyncResult(normalizedTemplateSync);\n        }\n        else {\n            // async case\n            return new SyncAsyncResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); }));\n        }\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateSync = function (prenomData) {\n        return this.normalizeLoadedTemplate(prenomData, prenomData.template, prenomData.moduleUrl);\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateAsync = function (prenomData) {\n        var _this = this;\n        var /** @type {?} */ templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n        return this._fetch(templateUrl)\n            .then(function (value) { return _this.normalizeLoadedTemplate(prenomData, value, templateUrl); });\n    };\n    /**\n     * @param {?} prenormData\n     * @param {?} template\n     * @param {?} templateAbsUrl\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var /** @type {?} */ isInline = !!prenormData.template;\n        var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\n        var /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl }), true, interpolationConfig);\n        if (rootNodesAndErrors.errors.length > 0) {\n            var /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var /** @type {?} */ templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({\n            styles: prenormData.styles,\n            styleUrls: prenormData.styleUrls,\n            moduleUrl: prenormData.moduleUrl\n        }));\n        var /** @type {?} */ visitor = new TemplatePreparseVisitor();\n        visitAll(visitor, rootNodesAndErrors.rootNodes);\n        var /** @type {?} */ templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var /** @type {?} */ encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        var /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var /** @type {?} */ styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        if (encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: template,\n            templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation, isInline: isInline\n        });\n    };\n    /**\n     * @param {?} templateMeta\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {\n        return this._loadMissingExternalStylesheets(templateMeta.styleUrls)\n            .then(function (externalStylesheets) { return new CompileTemplateMetadata({\n            encapsulation: templateMeta.encapsulation,\n            template: templateMeta.template,\n            templateUrl: templateMeta.templateUrl,\n            styles: templateMeta.styles,\n            styleUrls: templateMeta.styleUrls,\n            externalStylesheets: externalStylesheets,\n            ngContentSelectors: templateMeta.ngContentSelectors,\n            animations: templateMeta.animations,\n            interpolation: templateMeta.interpolation,\n            isInline: templateMeta.isInline,\n        }); });\n    };\n    /**\n     * @param {?} styleUrls\n     * @param {?=} loadedStylesheets\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return Promise\n            .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {\n            var /** @type {?} */ stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); }))\n            .then(function (_) { return Array.from(loadedStylesheets.values()); });\n    };\n    /**\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });\n        var /** @type {?} */ allStyles = stylesheet.styles.map(function (style$$1) {\n            var /** @type {?} */ styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style$$1);\n            allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nDirectiveNormalizer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveNormalizer.ctorParameters = function () { return [\n    { type: ResourceLoader, },\n    { type: UrlResolver, },\n    { type: HtmlParser, },\n    { type: CompilerConfig, },\n]; };\nvar TemplatePreparseVisitor = (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var /** @type {?} */ textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll(this, ast.cases); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll(this, ast.expression);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n    return TemplatePreparseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar DirectiveResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function DirectiveResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    /**\n     * Return {\\@link Directive} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        if (typeMetadata) {\n            var /** @type {?} */ metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type));\n        }\n        return null;\n    };\n    /**\n     * @param {?} dm\n     * @param {?} propertyMetadata\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {\n        var /** @type {?} */ inputs = [];\n        var /** @type {?} */ outputs = [];\n        var /** @type {?} */ host = {};\n        var /** @type {?} */ queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var /** @type {?} */ input = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"M\" /* Input */]; });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var /** @type {?} */ output = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_35\" /* Output */]; });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var /** @type {?} */ hostBindings = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_36\" /* HostBinding */]; });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var /** @type {?} */ startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var /** @type {?} */ hostListeners = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* HostListener */]; });\n            hostListeners.forEach(function (hostListener) {\n                var /** @type {?} */ args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var /** @type {?} */ query = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_38\" /* Query */]; });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, directiveType);\n    };\n    /**\n     * @param {?} def\n     * @return {?}\n     */\n    DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };\n    /**\n     * @param {?} bindings\n     * @return {?}\n     */\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var /** @type {?} */ names = new Set();\n        var /** @type {?} */ reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {\n            var /** @type {?} */ binding = bindings[i];\n            var /** @type {?} */ name = this._extractPublicName(binding);\n            if (!names.has(name)) {\n                names.add(name);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} host\n     * @param {?} queries\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {\n        var /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var /** @type {?} */ mergedHost = directive.host ? __assign({}, directive.host, host) : host;\n        var /** @type {?} */ mergedQueries = directive.queries ? __assign({}, directive.queries, queries) : queries;\n        if (directive instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                moduleId: directive.moduleId,\n                queries: mergedQueries,\n                changeDetection: directive.changeDetection,\n                providers: directive.providers,\n                viewProviders: directive.viewProviders,\n                entryComponents: directive.entryComponents,\n                template: directive.template,\n                templateUrl: directive.templateUrl,\n                styles: directive.styles,\n                styleUrls: directive.styleUrls,\n                encapsulation: directive.encapsulation,\n                animations: directive.animations,\n                interpolation: directive.interpolation\n            });\n        }\n        else {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nDirectiveResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isDirectiveMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */];\n}\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nfunction findLast(arr, condition) {\n    for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar NG_FACTORY = /\\.ngfactory\\./;\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction ngfactoryFilePath(filePath) {\n    var /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(filePath);\n    return urlWithSuffix[0] + \".ngfactory\" + urlWithSuffix[1];\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction stripNgFactory(filePath) {\n    return filePath.replace(NG_FACTORY, '.');\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction isNgFactoryFile(filePath) {\n    return NG_FACTORY.test(filePath);\n}\n/**\n * @param {?} path\n * @return {?}\n */\nfunction splitTypescriptSuffix(path) {\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), '.ts'];\n    }\n    var /** @type {?} */ lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\n/**\n * @param {?} fileName\n * @return {?}\n */\nfunction summaryFileName(fileName) {\n    var /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} hook\n * @param {?} token\n * @return {?}\n */\nfunction hasLifecycleHook(hook, token) {\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].hasLifecycleHook(token, getHookName(hook));\n}\n/**\n * @param {?} hook\n * @return {?}\n */\nfunction getHookName(hook) {\n    switch (hook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnInit:\n            return 'ngOnInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy:\n            return 'ngOnDestroy';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].DoCheck:\n            return 'ngDoCheck';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnChanges:\n            return 'ngOnChanges';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentInit:\n            return 'ngAfterContentInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewInit:\n            return 'ngAfterViewInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewChecked:\n            return 'ngAfterViewChecked';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _isNgModuleMetadata(obj) {\n    return obj instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */];\n}\n/**\n * Resolves types to {\\@link NgModule}.\n */\nvar NgModuleResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function NgModuleResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModuleMeta = findLast(this._reflector.annotations(type), _isNgModuleMetadata);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\nNgModuleResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isPipeMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */];\n}\n/**\n * Resolve a `Type` for {\\@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n */\nvar PipeResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function PipeResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    PipeResolver.prototype.isPipe = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        return typeMetadata && typeMetadata.some(_isPipeMetadata);\n    };\n    /**\n     * Return {\\@link Pipe} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ metas = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        if (metas) {\n            var /** @type {?} */ annotation = findLast(metas, _isPipeMetadata);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\nPipeResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nPipeResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SummaryResolver = (function () {\n    function SummaryResolver() {\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.isLibraryFile = function (fileName) { return false; };\n    ;\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.getLibraryFileName = function (fileName) { return null; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.resolveSummary = function (reference) { return null; };\n    ;\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    SummaryResolver.prototype.getSymbolsOf = function (filePath) { return []; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.getImportAs = function (reference) { return reference; };\n    return SummaryResolver;\n}());\nSummaryResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nSummaryResolver.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COLLECTOR_TOKEN = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('ErrorCollector');\nvar CompileMetadataResolver = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _ngModuleResolver\n     * @param {?} _directiveResolver\n     * @param {?} _pipeResolver\n     * @param {?} _summaryResolver\n     * @param {?} _schemaRegistry\n     * @param {?} _directiveNormalizer\n     * @param {?} _console\n     * @param {?} _staticSymbolCache\n     * @param {?=} _reflector\n     * @param {?=} _errorCollector\n     */\n    function CompileMetadataResolver(_config, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._config = _config;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    /**\n     * @param {?} baseType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var /** @type {?} */ delegate = null;\n        var /** @type {?} */ proxyClass = (function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        });\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            ((proxyClass)).prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        ((proxyClass)).overriddenName = name;\n        return proxyClass;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var /** @type {?} */ name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        else {\n            var /** @type {?} */ HostClass = (function HostClass() { });\n            HostClass.overriddenName = name;\n            return HostClass;\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return ({});\n        }\n    };\n    /**\n     * @param {?} selector\n     * @param {?} dirType\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var /** @type {?} */ hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_31\" /* ɵccf */])(selector, dirType, /** @type {?} */ (hostView), inputs, outputs, []);\n        }\n    };\n    /**\n     * @param {?} factory\n     * @param {?} ngContentSelectors\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, ngContentSelectors);\n        }\n        var _a;\n    };\n    /**\n     * @param {?} type\n     * @param {?} kind\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var /** @type {?} */ typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} directiveType\n     * @param {?} isSync\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return;\n        }\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(directiveType);\n        var _a = this.getNonNormalizedDirectiveMetadata(directiveType), annotation = _a.annotation, metadata = _a.metadata;\n        var /** @type {?} */ createDirectiveMetadata = function (templateMetadata) {\n            var /** @type {?} */ normalizedDirMeta = new CompileDirectiveMetadata({\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return normalizedDirMeta;\n        };\n        if (metadata.isComponent) {\n            var /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: componentModuleUrl(this._reflector, directiveType, annotation),\n                encapsulation: metadata.template.encapsulation,\n                template: metadata.template.template,\n                templateUrl: metadata.template.templateUrl,\n                styles: metadata.template.styles,\n                styleUrls: metadata.template.styleUrls,\n                animations: metadata.template.animations,\n                interpolation: metadata.template.interpolation\n            });\n            if (templateMeta.syncResult) {\n                createDirectiveMetadata(templateMeta.syncResult);\n                return null;\n            }\n            else {\n                if (isSync) {\n                    this._reportError(componentStillLoadingError(directiveType), directiveType);\n                    return null;\n                }\n                return templateMeta.asyncResult.then(createDirectiveMetadata);\n            }\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    /**\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var /** @type {?} */ cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var /** @type {?} */ nonNormalizedTemplateMetadata;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            // component\n            assertArrayOfStrings('styles', dirMeta.styles);\n            assertArrayOfStrings('styleUrls', dirMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', dirMeta.interpolation);\n            var /** @type {?} */ animations = dirMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: dirMeta.encapsulation,\n                template: dirMeta.template,\n                templateUrl: dirMeta.templateUrl,\n                styles: dirMeta.styles,\n                styleUrls: dirMeta.styleUrls,\n                animations: animations,\n                interpolation: dirMeta.interpolation,\n                isInline: !!dirMeta.template\n            });\n        }\n        var /** @type {?} */ changeDetectionStrategy = null;\n        var /** @type {?} */ viewProviders = [];\n        var /** @type {?} */ entryComponentMetadata = [];\n        var /** @type {?} */ selector = dirMeta.selector;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            // Component\n            changeDetectionStrategy = dirMeta.changeDetection;\n            if (dirMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (dirMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents)\n                    .map(function (type) { return _this._getEntryComponentMetadata(type); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(\"Directive \" + stringifyType(directiveType) + \" has no selector, please add it!\"), directiveType);\n                selector = 'error';\n            }\n        }\n        var /** @type {?} */ providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var /** @type {?} */ queries = [];\n        var /** @type {?} */ viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var /** @type {?} */ metadata = CompileDirectiveMetadata.create({\n            selector: selector,\n            exportAs: dirMeta.exportAs,\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs,\n            outputs: dirMeta.outputs,\n            host: dirMeta.host,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                undefined,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : undefined,\n            componentFactory: undefined\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(directiveType);\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isDirective = function (type) { return this._directiveResolver.isDirective(type); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isPipe = function (type) { return this._pipeResolver.isPipe(type); };\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType) {\n        var /** @type {?} */ moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));\n        if (!moduleSummary) {\n            var /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var /** @type {?} */ loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var /** @type {?} */ promise = _this._loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        moduleType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(moduleType);\n        var /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var /** @type {?} */ declaredDirectives = [];\n        var /** @type {?} */ exportedNonModuleIdentifiers = [];\n        var /** @type {?} */ declaredPipes = [];\n        var /** @type {?} */ importedModules = [];\n        var /** @type {?} */ exportedModules = [];\n        var /** @type {?} */ providers = [];\n        var /** @type {?} */ entryComponents = [];\n        var /** @type {?} */ bootstrapComponents = [];\n        var /** @type {?} */ schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var /** @type {?} */ importedModuleType;\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var /** @type {?} */ moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    var /** @type {?} */ importedModuleSummary = _this.getNgModuleSummary(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ exportedModuleSummary = _this.getNgModuleSummary(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this._directiveResolver.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this._pipeResolver.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var /** @type {?} */ exportedDirectives = [];\n        var /** @type {?} */ exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return _this._getEntryComponentMetadata(type); }));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, bootstrapComponents.map(function (type) { return _this._getEntryComponentMetadata(type.reference); }));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, compileMeta.type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?} importedModuleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (this._directiveResolver.isDirective(type)) {\n            return 'directive';\n        }\n        if (this._pipeResolver.isPipe(type)) {\n            return 'pipe';\n        }\n        if (this._ngModuleResolver.isNgModule(type)) {\n            return 'module';\n        }\n        if (((type)).provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    /**\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    /**\n     * @param {?} importedModules\n     * @param {?} exportedModules\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var /** @type {?} */ result = new TransitiveCompileNgModuleMetadata();\n        var /** @type {?} */ modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var /** @type {?} */ addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var /** @type {?} */ tokenRef = tokenReference(entry.provider.token);\n                var /** @type {?} */ prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var /** @type {?} */ moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type);\n        return { reference: type };\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var /** @type {?} */ annotations = this._reflector.annotations(type);\n        // Note: We need an exact check here as @Component / @Directive / ... inherit\n        // from @CompilerInjectable!\n        return annotations.some(function (ann) { return ann.constructor === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */]; });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getInjectableMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var /** @type {?} */ typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_41\" /* ɵLIFECYCLE_HOOKS_VALUES */].filter(function (hook) { return hasLifecycleHook(hook, identifier.reference); }),\n        };\n    };\n    /**\n     * @param {?} factory\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var /** @type {?} */ pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(pipeType);\n        var /** @type {?} */ pipeAnnotation = this._pipeResolver.resolve(pipeType);\n        var /** @type {?} */ pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @param {?} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ hasUnknownDeps = false;\n        var /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var /** @type {?} */ dependenciesMetadata = params.map(function (param) {\n            var /** @type {?} */ isAttribute = false;\n            var /** @type {?} */ isHost = false;\n            var /** @type {?} */ isSelf = false;\n            var /** @type {?} */ isSkipSelf = false;\n            var /** @type {?} */ isOptional = false;\n            var /** @type {?} */ token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]) {\n                        isHost = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]) {\n                        isSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]) {\n                        isSkipSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]) {\n                        isOptional = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"S\" /* Attribute */]) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */]) {\n                        token = paramEntry.token;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return null;\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var /** @type {?} */ depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringifyType(dep.token) : '?'; }).join(', ');\n            var /** @type {?} */ message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v5.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(token);\n        var /** @type {?} */ compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    /**\n     * @param {?} providers\n     * @param {?} targetEntryComponents\n     * @param {?=} debugInfo\n     * @param {?=} compileProviders\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(provider);\n                var /** @type {?} */ providerMeta = void 0;\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var /** @type {?} */ providersInfo = ((providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])))\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token === resolveIdentifier(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    /**\n     * @param {?} provider\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var /** @type {?} */ components = [];\n        var /** @type {?} */ collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var /** @type {?} */ entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };\n        }\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: dirSummary.componentFactory };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var /** @type {?} */ compileDeps;\n        var /** @type {?} */ compileTypeMetadata = null;\n        var /** @type {?} */ compileFactoryMetadata = null;\n        var /** @type {?} */ token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : null,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    /**\n     * @param {?} queries\n     * @param {?} isViewQuery\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var /** @type {?} */ res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var /** @type {?} */ query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n    /**\n     * @param {?} q\n     * @param {?} propertyName\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var /** @type {?} */ selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : null\n        };\n    };\n    /**\n     * @param {?} error\n     * @param {?=} type\n     * @param {?=} otherType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nCompileMetadataResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nCompileMetadataResolver.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: NgModuleResolver, },\n    { type: DirectiveResolver, },\n    { type: PipeResolver, },\n    { type: SummaryResolver, },\n    { type: ElementSchemaRegistry, },\n    { type: DirectiveNormalizer, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n    { type: StaticSymbolCache, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] },] },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [ERROR_COLLECTOR_TOKEN,] },] },\n]; };\n/**\n * @param {?} tree\n * @param {?=} out\n * @return {?}\n */\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var /** @type {?} */ i = 0; i < tree.length; i++) {\n            var /** @type {?} */ item = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\n/**\n * @param {?} array\n * @return {?}\n */\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\n/**\n * @param {?} tree\n * @return {?}\n */\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_43\" /* Type */]);\n}\n/**\n * @param {?} reflector\n * @param {?} type\n * @param {?} cmpMetadata\n * @return {?}\n */\nfunction componentModuleUrl(reflector, type, cmpMetadata) {\n    if (type instanceof StaticSymbol) {\n        return reflector.resourceUri(type);\n    }\n    var /** @type {?} */ moduleId = cmpMetadata.moduleId;\n    if (typeof moduleId === 'string') {\n        var /** @type {?} */ scheme = getUrlScheme(moduleId);\n        return scheme ? moduleId : \"package:\" + moduleId + MODULE_SUFFIX;\n    }\n    else if (moduleId !== null && moduleId !== void 0) {\n        throw syntaxError(\"moduleId should be a string in \\\"\" + stringifyType(type) + \"\\\". See https://goo.gl/wIDDiL for more information.\\n\" +\n            \"If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.\");\n    }\n    return reflector.importUri(type);\n}\n/**\n * @param {?} value\n * @param {?} targetIdentifiers\n * @return {?}\n */\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = (function (_super) {\n    __extends(_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} value\n     * @param {?} targetIdentifiers\n     * @return {?}\n     */\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\n/**\n * @param {?} type\n * @return {?}\n */\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n * @param {?} compType\n * @return {?}\n */\nfunction componentStillLoadingError(compType) {\n    var /** @type {?} */ error = Error(\"Can't compile synchronously as \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(compType) + \" is still being loaded!\");\n    ((error))[__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_44\" /* ɵERROR_COMPONENT_TYPE */]] = compType;\n    return error;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TypeModifier = {};\nTypeModifier.Const = 0;\nTypeModifier[TypeModifier.Const] = \"Const\";\n/**\n * @abstract\n */\nvar Type$1 = (function () {\n    /**\n     * @param {?=} modifiers\n     */\n    function Type$1(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Type$1.prototype.visitType = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Type$1.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Type$1;\n}());\nvar BuiltinTypeName = {};\nBuiltinTypeName.Dynamic = 0;\nBuiltinTypeName.Bool = 1;\nBuiltinTypeName.String = 2;\nBuiltinTypeName.Int = 3;\nBuiltinTypeName.Number = 4;\nBuiltinTypeName.Function = 5;\nBuiltinTypeName.Inferred = 6;\nBuiltinTypeName[BuiltinTypeName.Dynamic] = \"Dynamic\";\nBuiltinTypeName[BuiltinTypeName.Bool] = \"Bool\";\nBuiltinTypeName[BuiltinTypeName.String] = \"String\";\nBuiltinTypeName[BuiltinTypeName.Int] = \"Int\";\nBuiltinTypeName[BuiltinTypeName.Number] = \"Number\";\nBuiltinTypeName[BuiltinTypeName.Function] = \"Function\";\nBuiltinTypeName[BuiltinTypeName.Inferred] = \"Inferred\";\nvar BuiltinType = (function (_super) {\n    __extends(BuiltinType, _super);\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     */\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltintType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = (function (_super) {\n    __extends(ExpressionType, _super);\n    /**\n     * @param {?} value\n     * @param {?=} modifiers\n     */\n    function ExpressionType(value, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = (function (_super) {\n    __extends(ArrayType, _super);\n    /**\n     * @param {?} of\n     * @param {?=} modifiers\n     */\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = (function (_super) {\n    __extends(MapType, _super);\n    /**\n     * @param {?} valueType\n     * @param {?=} modifiers\n     */\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar BinaryOperator = {};\nBinaryOperator.Equals = 0;\nBinaryOperator.NotEquals = 1;\nBinaryOperator.Identical = 2;\nBinaryOperator.NotIdentical = 3;\nBinaryOperator.Minus = 4;\nBinaryOperator.Plus = 5;\nBinaryOperator.Divide = 6;\nBinaryOperator.Multiply = 7;\nBinaryOperator.Modulo = 8;\nBinaryOperator.And = 9;\nBinaryOperator.Or = 10;\nBinaryOperator.Lower = 11;\nBinaryOperator.LowerEquals = 12;\nBinaryOperator.Bigger = 13;\nBinaryOperator.BiggerEquals = 14;\nBinaryOperator[BinaryOperator.Equals] = \"Equals\";\nBinaryOperator[BinaryOperator.NotEquals] = \"NotEquals\";\nBinaryOperator[BinaryOperator.Identical] = \"Identical\";\nBinaryOperator[BinaryOperator.NotIdentical] = \"NotIdentical\";\nBinaryOperator[BinaryOperator.Minus] = \"Minus\";\nBinaryOperator[BinaryOperator.Plus] = \"Plus\";\nBinaryOperator[BinaryOperator.Divide] = \"Divide\";\nBinaryOperator[BinaryOperator.Multiply] = \"Multiply\";\nBinaryOperator[BinaryOperator.Modulo] = \"Modulo\";\nBinaryOperator[BinaryOperator.And] = \"And\";\nBinaryOperator[BinaryOperator.Or] = \"Or\";\nBinaryOperator[BinaryOperator.Lower] = \"Lower\";\nBinaryOperator[BinaryOperator.LowerEquals] = \"LowerEquals\";\nBinaryOperator[BinaryOperator.Bigger] = \"Bigger\";\nBinaryOperator[BinaryOperator.BiggerEquals] = \"BiggerEquals\";\n/**\n * @abstract\n */\nvar Expression = (function () {\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function Expression(type, sourceSpan) {\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expression.prototype.visitExpression = function (visitor, context) { };\n    /**\n     * @param {?} name\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    /**\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    /**\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    /**\n     * @return {?}\n     */\n    Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };\n    return Expression;\n}());\nvar BuiltinVar = {};\nBuiltinVar.This = 0;\nBuiltinVar.Super = 1;\nBuiltinVar.CatchError = 2;\nBuiltinVar.CatchStack = 3;\nBuiltinVar[BuiltinVar.This] = \"This\";\nBuiltinVar[BuiltinVar.Super] = \"Super\";\nBuiltinVar[BuiltinVar.CatchError] = \"CatchError\";\nBuiltinVar[BuiltinVar.CatchStack] = \"CatchStack\";\nvar ReadVarExpr = (function (_super) {\n    __extends(ReadVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadVarExpr(name, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadVarExpr.prototype.set = function (value) {\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar WriteVarExpr = (function (_super) {\n    __extends(WriteVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = (function (_super) {\n    __extends(WriteKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = (function (_super) {\n    __extends(WritePropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod = {};\nBuiltinMethod.ConcatArray = 0;\nBuiltinMethod.SubscribeObservable = 1;\nBuiltinMethod.Bind = 2;\nBuiltinMethod[BuiltinMethod.ConcatArray] = \"ConcatArray\";\nBuiltinMethod[BuiltinMethod.SubscribeObservable] = \"SubscribeObservable\";\nBuiltinMethod[BuiltinMethod.Bind] = \"Bind\";\nvar InvokeMethodExpr = (function (_super) {\n    __extends(InvokeMethodExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} method\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = (function (_super) {\n    __extends(InvokeFunctionExpr, _super);\n    /**\n     * @param {?} fn\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = (function (_super) {\n    __extends(InstantiateExpr, _super);\n    /**\n     * @param {?} classExpr\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = (function (_super) {\n    __extends(LiteralExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralExpr(value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar ExternalExpr = (function (_super) {\n    __extends(ExternalExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} typeParams\n     * @param {?=} sourceSpan\n     */\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ConditionalExpr = (function (_super) {\n    __extends(ConditionalExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = (function (_super) {\n    __extends(NotExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar CastExpr = (function (_super) {\n    __extends(CastExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     */\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    return FnParam;\n}());\nvar FunctionExpr = (function (_super) {\n    __extends(FunctionExpr, _super);\n    /**\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function FunctionExpr(params, statements, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = (function (_super) {\n    __extends(BinaryOperatorExpr, _super);\n    /**\n     * @param {?} operator\n     * @param {?} lhs\n     * @param {?} rhs\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.lhs = lhs;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = (function (_super) {\n    __extends(ReadPropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = (function (_super) {\n    __extends(ReadKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = (function (_super) {\n    __extends(LiteralArrayExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = (function () {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} quoted\n     */\n    function LiteralMapEntry(key, value, quoted) {\n        if (quoted === void 0) { quoted = false; }\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = (function (_super) {\n    __extends(LiteralMapExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = (function (_super) {\n    __extends(CommaExpr, _super);\n    /**\n     * @param {?} parts\n     * @param {?=} sourceSpan\n     */\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);\nvar NULL_EXPR = new LiteralExpr(null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE);\nvar StmtModifier = {};\nStmtModifier.Final = 0;\nStmtModifier.Private = 1;\nStmtModifier[StmtModifier.Final] = \"Final\";\nStmtModifier[StmtModifier.Private] = \"Private\";\n/**\n * @abstract\n */\nvar Statement = (function () {\n    /**\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function Statement(modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        this.sourceSpan = sourceSpan;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Statement.prototype.visitStatement = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Statement;\n}());\nvar DeclareVarStmt = (function (_super) {\n    __extends(DeclareVarStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || value.type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = (function (_super) {\n    __extends(DeclareFunctionStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = (function (_super) {\n    __extends(ExpressionStatement, _super);\n    /**\n     * @param {?} expr\n     * @param {?=} sourceSpan\n     */\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = (function (_super) {\n    __extends(ReturnStatement, _super);\n    /**\n     * @param {?} value\n     * @param {?=} sourceSpan\n     */\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = (function () {\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function AbstractClassPart(type, modifiers) {\n        if (type === void 0) { type = null; }\n        this.type = type;\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return AbstractClassPart;\n}());\nvar ClassField = (function (_super) {\n    __extends(ClassField, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassField(name, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    return ClassField;\n}(AbstractClassPart));\nvar ClassMethod = (function (_super) {\n    __extends(ClassMethod, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = (function (_super) {\n    __extends(ClassGetter, _super);\n    /**\n     * @param {?} name\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassGetter(name, body, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = (function (_super) {\n    __extends(ClassStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} parent\n     * @param {?} fields\n     * @param {?} getters\n     * @param {?} constructorMethod\n     * @param {?} methods\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = (function (_super) {\n    __extends(IfStmt, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     */\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar TryCatchStmt = (function (_super) {\n    __extends(TryCatchStmt, _super);\n    /**\n     * @param {?} bodyStmts\n     * @param {?} catchStmts\n     * @param {?=} sourceSpan\n     */\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = (function (_super) {\n    __extends(ThrowStmt, _super);\n    /**\n     * @param {?} error\n     * @param {?=} sourceSpan\n     */\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer$1 = (function () {\n    function AstTransformer$1() {\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformExpr = function (expr, context) { return expr; };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadVarExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var /** @type {?} */ method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var /** @type {?} */ mapType = new MapType(ast.valueType);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var /** @type {?} */ parent = stmt.parent.visitExpression(this, context);\n        var /** @type {?} */ getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var /** @type {?} */ ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var /** @type {?} */ methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer$1;\n}());\nvar RecursiveAstVisitor$1 = (function () {\n    function RecursiveAstVisitor$1() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteVarExpr = function (expr, context) {\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.index.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWritePropExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExternalExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        stmt.parent.visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor$1;\n}());\n/**\n * @param {?} stmts\n * @return {?}\n */\nfunction findReadVarNames(stmts) {\n    var /** @type {?} */ visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = (function (_super) {\n    __extends(_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        this.varNames.add(ast.name);\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor$1));\n/**\n * @param {?} stmt\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\n/**\n * @param {?} expr\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = (function (_super) {\n    __extends(_ApplySourceSpanTransformer, _super);\n    /**\n     * @param {?} sourceSpan\n     */\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var /** @type {?} */ clone = Object.create(obj.constructor.prototype);\n        for (var /** @type {?} */ prop in obj) {\n            clone[prop] = obj[prop];\n        }\n        return clone;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer$1));\n/**\n * @param {?} name\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction variable(name, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new ReadVarExpr(name, type, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams), typeModifiers) : null;\n}\n/**\n * @param {?} expr\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction expressionType(expr, typeModifiers) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return expr != null ? new ExpressionType(expr, typeModifiers) : null;\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literalArr(values, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} quoted\n * @return {?}\n */\nfunction literalMap(values, type, quoted) {\n    if (type === void 0) { type = null; }\n    if (quoted === void 0) { quoted = false; }\n    return new LiteralMapExpr(values.map(function (entry) { return new LiteralMapEntry(entry[0], entry[1], quoted); }), type);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\n/**\n * @param {?} params\n * @param {?} body\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction fn(params, body, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new FunctionExpr(params, body, type, sourceSpan);\n}\n/**\n * @param {?} value\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literal(value, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new LiteralExpr(value, type, sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a new class stmts based on the given data.\n * @param {?} config\n * @return {?}\n */\nfunction createClassStmt(config) {\n    var /** @type {?} */ parentArgs = config.parentArgs || [];\n    var /** @type {?} */ superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];\n    var /** @type {?} */ builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);\n    var /** @type {?} */ ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));\n    return new ClassStmt(config.name, config.parent, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || [], config.sourceSpan);\n}\n/**\n * @param {?} builders\n * @return {?}\n */\nfunction concatClassBuilderParts(builders) {\n    return {\n        fields: [].concat.apply([], builders.map(function (builder) { return builder.fields || []; })),\n        methods: [].concat.apply([], builders.map(function (builder) { return builder.methods || []; })),\n        getters: [].concat.apply([], builders.map(function (builder) { return builder.getters || []; })),\n        ctorStmts: [].concat.apply([], builders.map(function (builder) { return builder.ctorStmts || []; })),\n    };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\n/**\n * @param {?} value\n * @param {?=} type\n * @return {?}\n */\nfunction convertValueToOutputAst(value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(), type);\n}\nvar _ValueOutputAstTransformer = (function () {\n    function _ValueOutputAstTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var _this = this;\n        return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n    };\n    /**\n     * @param {?} map\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var /** @type {?} */ entries = [];\n        var /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return importExpr({ reference: value });\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This is currently not read, but will probably be used in the future.\n * We keep it as we already pass it through all the rigth places...\n */\nvar ComponentFactoryDependency = (function () {\n    /**\n     * @param {?} compType\n     */\n    function ComponentFactoryDependency(compType) {\n        this.compType = compType;\n    }\n    return ComponentFactoryDependency;\n}());\nvar NgModuleCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} ngModuleFactoryVar\n     * @param {?} dependencies\n     */\n    function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {\n        this.statements = statements;\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n        this.dependencies = dependencies;\n    }\n    return NgModuleCompileResult;\n}());\nvar NgModuleCompiler = (function () {\n    function NgModuleCompiler() {\n    }\n    /**\n     * @param {?} ngModuleMeta\n     * @param {?} extraProviders\n     * @return {?}\n     */\n    NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {\n        var /** @type {?} */ sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var /** @type {?} */ deps = [];\n        var /** @type {?} */ bootstrapComponentFactories = [];\n        var /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {\n            if (ngModuleMeta.bootstrapComponents.some(function (id) { return id.reference === entryComponent.componentType; })) {\n                bootstrapComponentFactories.push({ reference: entryComponent.componentFactory });\n            }\n            deps.push(new ComponentFactoryDependency(entryComponent.componentType));\n            return { reference: entryComponent.componentFactory };\n        });\n        var /** @type {?} */ builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);\n        var /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);\n        providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });\n        var /** @type {?} */ injectorClass = builder.build();\n        var /** @type {?} */ ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        var /** @type {?} */ ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.NgModuleFactory))\n            .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(createIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        var /** @type {?} */ stmts = [injectorClass, ngModuleFactoryStmt];\n        if (ngModuleMeta.id) {\n            var /** @type {?} */ registerFactoryStmt = importExpr(createIdentifier(Identifiers.RegisterModuleFactoryFn))\n                .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])\n                .toStmt();\n            stmts.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);\n    };\n    return NgModuleCompiler;\n}());\nNgModuleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleCompiler.ctorParameters = function () { return []; };\nvar _InjectorBuilder = (function () {\n    /**\n     * @param {?} _ngModuleMeta\n     * @param {?} _entryComponentFactories\n     * @param {?} _bootstrapComponentFactories\n     * @param {?} _sourceSpan\n     */\n    function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {\n        this._ngModuleMeta = _ngModuleMeta;\n        this._entryComponentFactories = _entryComponentFactories;\n        this._bootstrapComponentFactories = _bootstrapComponentFactories;\n        this._sourceSpan = _sourceSpan;\n        this.fields = [];\n        this.getters = [];\n        this.methods = [];\n        this.ctorStmts = [];\n        this._lazyProps = new Map();\n        this._tokens = [];\n        this._instances = new Map();\n        this._createStmts = [];\n        this._destroyStmts = [];\n    }\n    /**\n     * @param {?} resolvedProvider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {\n        var _this = this;\n        var /** @type {?} */ providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });\n        var /** @type {?} */ propName = \"_\" + tokenName(resolvedProvider.token) + \"_\" + this._instances.size;\n        var /** @type {?} */ instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);\n        if (resolvedProvider.lifecycleHooks.indexOf(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy) !== -1) {\n            var /** @type {?} */ callNgOnDestroy = instance.callMethod('ngOnDestroy', []);\n            if (!resolvedProvider.eager) {\n                callNgOnDestroy = this._lazyProps.get(instance.name).and(callNgOnDestroy);\n            }\n            this._destroyStmts.push(callNgOnDestroy.toStmt());\n        }\n        this._tokens.push(resolvedProvider.token);\n        this._instances.set(tokenReference(resolvedProvider.token), instance);\n    };\n    /**\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.build = function () {\n        var _this = this;\n        var /** @type {?} */ getMethodStmts = this._tokens.map(function (token) {\n            var /** @type {?} */ providerExpr = _this._instances.get(tokenReference(token));\n            return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);\n        });\n        var /** @type {?} */ methods = [\n            new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),\n            new ClassMethod('getInternal', [\n                new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),\n                new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)\n            ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars.notFoundResult)]), DYNAMIC_TYPE),\n            new ClassMethod('destroyInternal', [], this._destroyStmts),\n        ];\n        var /** @type {?} */ parentArgs = [\n            variable(InjectorProps.parent.name),\n            literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),\n            literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))\n        ];\n        var /** @type {?} */ injClassName = identifierName(this._ngModuleMeta.type) + \"Injector\";\n        return createClassStmt({\n            name: injClassName,\n            ctorParams: [new FnParam(InjectorProps.parent.name, importType(createIdentifier(Identifiers.Injector)))],\n            parent: importExpr(createIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]),\n            parentArgs: parentArgs,\n            builders: [{ methods: methods }, this]\n        });\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getProviderValue = function (provider) {\n        var _this = this;\n        var /** @type {?} */ result;\n        if (provider.useExisting != null) {\n            result = this._getDependency({ token: provider.useExisting });\n        }\n        else if (provider.useFactory != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result = importExpr(provider.useFactory).callFn(depsExpr);\n        }\n        else if (provider.useClass != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result =\n                importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));\n        }\n        else {\n            result = convertValueToOutputAst(provider.useValue);\n        }\n        return result;\n    };\n    /**\n     * @param {?} propName\n     * @param {?} provider\n     * @param {?} providerValueExpressions\n     * @param {?} isMulti\n     * @param {?} isEager\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {\n        var /** @type {?} */ resolvedProviderValueExpr;\n        var /** @type {?} */ type;\n        if (isMulti) {\n            resolvedProviderValueExpr = literalArr(providerValueExpressions);\n            type = new ArrayType(DYNAMIC_TYPE);\n        }\n        else {\n            resolvedProviderValueExpr = providerValueExpressions[0];\n            type = providerValueExpressions[0].type;\n        }\n        if (!type) {\n            type = DYNAMIC_TYPE;\n        }\n        if (isEager) {\n            this.fields.push(new ClassField(propName, type));\n            this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());\n        }\n        else {\n            var /** @type {?} */ internalFieldProp = THIS_EXPR.prop(\"_\" + propName);\n            this.fields.push(new ClassField(internalFieldProp.name, type));\n            // Note: Equals is important for JS so that it also checks the undefined case!\n            var /** @type {?} */ getterStmts = [\n                new IfStmt(internalFieldProp.isBlank(), [internalFieldProp.set(resolvedProviderValueExpr).toStmt()]),\n                new ReturnStatement(internalFieldProp)\n            ];\n            this.getters.push(new ClassGetter(propName, getterStmts, type));\n            this._lazyProps.set(propName, internalFieldProp);\n        }\n        return THIS_EXPR.prop(propName);\n    };\n    /**\n     * @param {?} dep\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getDependency = function (dep) {\n        var /** @type {?} */ result = null;\n        if (dep.isValue) {\n            result = literal(dep.value);\n        }\n        if (!dep.isSkipSelf) {\n            if (dep.token) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                    result = THIS_EXPR;\n                }\n                else if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                    result = THIS_EXPR.prop('componentFactoryResolver');\n                }\n            }\n            if (!result) {\n                result = this._instances.get(tokenReference(dep.token));\n            }\n        }\n        if (!result) {\n            var /** @type {?} */ args = [createDiTokenExpression(dep.token)];\n            if (dep.isOptional) {\n                args.push(NULL_EXPR);\n            }\n            result = InjectorProps.parent.callMethod('get', args);\n        }\n        return result;\n    };\n    return _InjectorBuilder;\n}());\n/**\n * @param {?} token\n * @return {?}\n */\nfunction createDiTokenExpression(token) {\n    if (token.value != null) {\n        return literal(token.value);\n    }\n    else {\n        return importExpr(token.identifier);\n    }\n}\nvar InjectorProps = (function () {\n    function InjectorProps() {\n    }\n    return InjectorProps;\n}());\nInjectorProps.parent = THIS_EXPR.prop('parent');\nvar InjectMethodVars = (function () {\n    function InjectMethodVars() {\n    }\n    return InjectMethodVars;\n}());\nInjectMethodVars.token = variable('token');\nInjectMethodVars.notFoundResult = variable('notFoundResult');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION$1 = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = (function () {\n    /**\n     * @param {?=} file\n     */\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    /**\n     * @param {?} url\n     * @param {?=} content\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    /**\n     * @param {?} col0\n     * @param {?=} sourceUrl\n     * @param {?=} sourceLine0\n     * @param {?=} sourceCol0\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.lines.slice(-1)[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var /** @type {?} */ sourcesIndex = new Map();\n        var /** @type {?} */ sources = [];\n        var /** @type {?} */ sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var /** @type {?} */ mappings = '';\n        var /** @type {?} */ lastCol0 = 0;\n        var /** @type {?} */ lastSourceIndex = 0;\n        var /** @type {?} */ lastSourceLine0 = 0;\n        var /** @type {?} */ lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the “sources” list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64String(value) {\n    var /** @type {?} */ b64 = '';\n    value = utf8Encode(value);\n    for (var /** @type {?} */ i = 0; i < value.length;) {\n        var /** @type {?} */ i1 = value.charCodeAt(i++);\n        var /** @type {?} */ i2 = value.charCodeAt(i++);\n        var /** @type {?} */ i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var /** @type {?} */ out = '';\n    do {\n        var /** @type {?} */ digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error');\nvar CATCH_STACK_VAR$1 = variable('stack');\n/**\n * @abstract\n */\nvar _EmittedLine = (function () {\n    /**\n     * @param {?} indent\n     */\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = (function () {\n    /**\n     * @param {?} _exportedVars\n     * @param {?} _indent\n     */\n    function EmitterVisitorContext(_exportedVars, _indent) {\n        this._exportedVars = _exportedVars;\n        this._indent = _indent;\n        this._classes = [];\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    EmitterVisitorContext.createRoot = function (exportedVars) {\n        return new EmitterVisitorContext(exportedVars, 0);\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._lines[this._lines.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} varName\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };\n    /**\n     * @param {?=} from\n     * @param {?=} lastPart\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from, lastPart, true);\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n    /**\n     * @param {?} from\n     * @param {?} part\n     * @param {?=} newLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @param {?} clazz\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    /**\n     * @param {?} sourceFilePath\n     * @param {?} genFilePath\n     * @param {?=} startsAtLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (sourceFilePath, genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var /** @type {?} */ map = new SourceMapGenerator(genFilePath);\n        var /** @type {?} */ firstOffsetMapped = false;\n        var /** @type {?} */ mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(sourceFilePath, ' ').addMapping(0, sourceFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var /** @type {?} */ i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var /** @type {?} */ spans = line.srcSpans;\n            var /** @type {?} */ parts = line.parts;\n            var /** @type {?} */ col0 = line.indent * _INDENT_WITH.length;\n            var /** @type {?} */ spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var /** @type {?} */ span = spans[spanIdx];\n                var /** @type {?} */ source = span.start.file;\n                var /** @type {?} */ sourceLine = span.start.line;\n                var /** @type {?} */ sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\n/**\n * @abstract\n */\nvar AbstractEmitterVisitor = (function () {\n    /**\n     * @param {?} _escapeDollarInStrings\n     */\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var /** @type {?} */ hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        var /** @type {?} */ lines = stmt.comment.split('\\n');\n        lines.forEach(function (line) { ctx.println(stmt, \"// \" + line); });\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$1.name;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$1.name;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var /** @type {?} */ opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"[\", useNewLine);\n        ctx.incIndent();\n        this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"]\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"{\", useNewLine);\n        ctx.incIndent();\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \": \");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"}\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {\n        var _this = this;\n        if (newLine === void 0) { newLine = false; }\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);\n    };\n    /**\n     * @template T\n     * @param {?} handler\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        for (var /** @type {?} */ i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                ctx.print(null, separator, newLine);\n            }\n            handler(expressions[i]);\n        }\n        if (newLine) {\n            ctx.println();\n        }\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\n/**\n * @param {?} input\n * @param {?} escapeDollar\n * @param {?=} alwaysQuote\n * @return {?}\n */\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\n/**\n * @param {?} count\n * @return {?}\n */\nfunction _createIndent(count) {\n    var /** @type {?} */ res = '';\n    for (var /** @type {?} */ i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _debugFilePath = '/debug/lib';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction debugOutputAstAsTypeScript(ast) {\n    var /** @type {?} */ converter = new _TsEmitterVisitor(_debugFilePath, {\n        /**\n         * @param {?} filePath\n         * @param {?} containingFilePath\n         * @return {?}\n         */\n        fileNameToModuleName: function (filePath, containingFilePath) { return filePath; },\n        /**\n         * @param {?} symbol\n         * @return {?}\n         */\n        getImportAs: function (symbol) { return null; },\n        getTypeArity: function (symbol) { return null; }\n    });\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot([]);\n    var /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = (function () {\n    /**\n     * @param {?} _importResolver\n     */\n    function TypeScriptEmitter(_importResolver) {\n        this._importResolver = _importResolver;\n    }\n    /**\n     * @param {?} srcFilePath\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?} exportedVars\n     * @param {?=} preamble\n     * @return {?}\n     */\n    TypeScriptEmitter.prototype.emitStatements = function (srcFilePath, genFilePath, stmts, exportedVars, preamble) {\n        var _this = this;\n        if (preamble === void 0) { preamble = ''; }\n        var /** @type {?} */ converter = new _TsEmitterVisitor(genFilePath, this._importResolver);\n        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(exportedVars);\n        converter.visitAllStatements(stmts, ctx);\n        var /** @type {?} */ preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedFilePath) {\n            var /** @type {?} */ reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + _this._importResolver.fileNameToModuleName(exportedFilePath, genFilePath) + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedFilePath) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + _this._importResolver.fileNameToModuleName(importedFilePath, genFilePath) + \"';\"));\n        });\n        var /** @type {?} */ sm = ctx.toSourceMapGenerator(srcFilePath, genFilePath, preambleLines.length).toJsComment();\n        var /** @type {?} */ lines = preambleLines.concat([ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        return lines.join('\\n');\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = (function (_super) {\n    __extends(_TsEmitterVisitor, _super);\n    /**\n     * @param {?} _genFilePath\n     * @param {?} _importResolver\n     */\n    function _TsEmitterVisitor(_genFilePath, _importResolver) {\n        var _this = _super.call(this, false) || this;\n        _this._genFilePath = _genFilePath;\n        _this._importResolver = _importResolver;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} t\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t != null) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var /** @type {?} */ result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name) && stmt.value instanceof ExternalExpr && !stmt.type) {\n            // check for a reexport\n            var _a = this._resolveStaticSymbol(stmt.value.value), name = _a.name, filePath = _a.filePath, members = _a.members;\n            if (members.length === 0 && filePath !== this._genFilePath) {\n                var /** @type {?} */ reexports = this.reexports.get(filePath);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(filePath, reexports);\n                }\n                reexports.push({ name: name, as: stmt.name });\n                return null;\n            }\n        }\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\");\n        ast.type.visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} field\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        ctx.println(null, \";\");\n    };\n    /**\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        ctx.println(ast, \" => {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {\n        var /** @type {?} */ typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._resolveStaticSymbol = function (value) {\n        var /** @type {?} */ reference = value.reference;\n        if (!(reference instanceof StaticSymbol)) {\n            throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(value));\n        }\n        var /** @type {?} */ arity = this._importResolver.getTypeArity(reference) || undefined;\n        var /** @type {?} */ importReference = this._importResolver.getImportAs(reference) || reference;\n        return {\n            name: importReference.name,\n            filePath: importReference.filePath,\n            members: importReference.members, arity: arity\n        };\n    };\n    /**\n     * @param {?} value\n     * @param {?} typeParams\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var _a = this._resolveStaticSymbol(value), name = _a.name, filePath = _a.filePath, members = _a.members, arity = _a.arity;\n        if (filePath != this._genFilePath) {\n            var /** @type {?} */ prefix = this.importsWithPrefixes.get(filePath);\n            if (prefix == null) {\n                prefix = \"import\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(filePath, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        if (members.length) {\n            ctx.print(null, name);\n            ctx.print(null, '.');\n            ctx.print(null, members.join('.'));\n        }\n        else {\n            ctx.print(null, name);\n        }\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var /** @type {?} */ suppliedParameters = (typeParams && typeParams.length) || 0;\n            var /** @type {?} */ additionalParameters = (arity || 0) - suppliedParameters;\n            if (suppliedParameters > 0 || additionalParameters > 0) {\n                ctx.print(null, \"<\");\n                if (suppliedParameters > 0) {\n                    this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');\n                }\n                if (additionalParameters > 0) {\n                    for (var /** @type {?} */ i = 0; i < additionalParameters; i++) {\n                        if (i > 0 || suppliedParameters > 0)\n                            ctx.print(null, ',');\n                        ctx.print(null, 'any');\n                    }\n                }\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\nvar SECURITY_SCHEMA = {};\n/**\n * @param {?} ctx\n * @param {?} specs\n * @return {?}\n */\nfunction registerContext(ctx, specs) {\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var spec = specs_1[_i];\n        SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n}\n// Case is insignificant below, all element and attribute names are lower-cased for lookup.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].HTML, [\n    'iframe|srcdoc',\n    '*|innerHTML',\n    '*|outerHTML',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].STYLE, ['*|style']);\n// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].URL, [\n    '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n    'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n    'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n    'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].RESOURCE_URL, [\n    'applet|code',\n    'applet|codebase',\n    'base|href',\n    'embed|src',\n    'frame|src',\n    'head|profile',\n    'html|manifest',\n    'iframe|src',\n    'link|href',\n    'media|src',\n    'object|codebase',\n    'object|data',\n    'script|src',\n]);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:cursor^:svg:|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = (function (_super) {\n    __extends(DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_45\" /* NO_ERRORS_SCHEMA */].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (tagName === 'ng-container' || tagName === 'ng-content') {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_46\" /* CUSTOM_ELEMENTS_SCHEMA */].name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    /**\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_45\" /* NO_ERRORS_SCHEMA */].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (tagName === 'ng-container' || tagName === 'ng-content') {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_46\" /* CUSTOM_ELEMENTS_SCHEMA */].name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n     * attack vectors are assigned their appropriate context.\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA['*|' + propName];\n        return ctx ? ctx : __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE;\n    };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    /**\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var /** @type {?} */ unit = '';\n        var /** @type {?} */ strVal = val.toString().trim();\n        var /** @type {?} */ errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nDomElementSchemaRegistry.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDomElementSchemaRegistry.ctorParameters = function () { return []; };\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\nvar ShadowCss = (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} selector\n     * @param {?=} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var /** @type {?} */ r = '';\n        var /** @type {?} */ m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} regExp\n     * @param {?} partReplacer\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var /** @type {?} */ parts = m[2].split(',');\n                var /** @type {?} */ r = [];\n                for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n                    var /** @type {?} */ p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var /** @type {?} */ selector = rule.selector;\n            var /** @type {?} */ content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @param {?} strict\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var shallowPart = deepParts[0], otherParts = deepParts.slice(1);\n            var /** @type {?} */ applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart)].concat(otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    /**\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var /** @type {?} */ lre = /\\[/g;\n        var /** @type {?} */ rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var /** @type {?} */ replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var /** @type {?} */ isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var /** @type {?} */ attrName = '[' + scopeSelector + ']';\n        var /** @type {?} */ _scopeSelectorPart = function (p) {\n            var /** @type {?} */ scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var /** @type {?} */ t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var /** @type {?} */ safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var /** @type {?} */ scopedSelector = '';\n        var /** @type {?} */ startIndex = 0;\n        var /** @type {?} */ res;\n        var /** @type {?} */ sep = /( |>|\\+|~(?!=))\\s*/g;\n        var /** @type {?} */ scopeAfter = selector.indexOf(_polyfillHostNoCombinator);\n        while ((res = sep.exec(selector)) !== null) {\n            var /** @type {?} */ separator = res[1];\n            var /** @type {?} */ part = selector.slice(startIndex, res.index).trim();\n            // if a selector appears before :host-context it should not be shimmed as it\n            // matches on ancestor elements and not on elements in the host's shadow\n            var /** @type {?} */ scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = (function () {\n    /**\n     * @param {?} selector\n     */\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    ;\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    /**\n     * @return {?}\n     */\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\n// all comments except inline source mapping\nvar _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction extractSourceMappingUrl(input) {\n    var /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);\n    return matcher ? matcher[0] : '';\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} content\n     */\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\n/**\n * @param {?} input\n * @param {?} ruleCallback\n * @return {?}\n */\nfunction processRules(input, ruleCallback) {\n    var /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);\n    var /** @type {?} */ nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ selector = m[2];\n        var /** @type {?} */ content = '';\n        var /** @type {?} */ suffix = m[4];\n        var /** @type {?} */ contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = (function () {\n    /**\n     * @param {?} escapedString\n     * @param {?} blocks\n     */\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\n/**\n * @param {?} input\n * @return {?}\n */\nfunction escapeBlocks(input) {\n    var /** @type {?} */ inputParts = input.split(_curlyRe);\n    var /** @type {?} */ resultParts = [];\n    var /** @type {?} */ escapedBlocks = [];\n    var /** @type {?} */ bracketCount = 0;\n    var /** @type {?} */ currentBlockParts = [];\n    for (var /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var /** @type {?} */ part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = (function () {\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} isShimmed\n     * @param {?} valuePlaceholder\n     */\n    function StylesCompileDependency(name, moduleUrl, isShimmed, valuePlaceholder) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.isShimmed = isShimmed;\n        this.valuePlaceholder = valuePlaceholder;\n    }\n    return StylesCompileDependency;\n}());\nvar StylesCompileResult = (function () {\n    /**\n     * @param {?} componentStylesheet\n     * @param {?} externalStylesheets\n     */\n    function StylesCompileResult(componentStylesheet, externalStylesheets) {\n        this.componentStylesheet = componentStylesheet;\n        this.externalStylesheets = externalStylesheets;\n    }\n    return StylesCompileResult;\n}());\nvar CompiledStylesheet = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} stylesVar\n     * @param {?} dependencies\n     * @param {?} isShimmed\n     * @param {?} meta\n     */\n    function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {\n        this.statements = statements;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = (function () {\n    /**\n     * @param {?} _urlResolver\n     */\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    StyleCompiler.prototype.compileComponent = function (comp) {\n        var _this = this;\n        var /** @type {?} */ externalStylesheets = [];\n        var /** @type {?} */ componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({\n            styles: comp.template.styles,\n            styleUrls: comp.template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), true);\n        comp.template.externalStylesheets.forEach(function (stylesheetMeta) {\n            var /** @type {?} */ compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);\n            externalStylesheets.push(compiledStylesheet);\n        });\n        return new StylesCompileResult(componentStylesheet, externalStylesheets);\n    };\n    /**\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?} isComponentStylesheet\n     * @return {?}\n     */\n    StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {\n        var _this = this;\n        var /** @type {?} */ shim = comp.template.encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated;\n        var /** @type {?} */ styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var /** @type {?} */ dependencies = [];\n        for (var /** @type {?} */ i = 0; i < stylesheet.styleUrls.length; i++) {\n            var /** @type {?} */ identifier = { reference: null };\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), stylesheet.styleUrls[i], shim, identifier));\n            styleExpressions.push(new ExternalExpr(identifier));\n        }\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var /** @type {?} */ stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);\n    };\n    /**\n     * @param {?} style\n     * @param {?} shim\n     * @return {?}\n     */\n    StyleCompiler.prototype._shimIfNeeded = function (style$$1, shim) {\n        return shim ? this._shadowCss.shimCssText(style$$1, CONTENT_ATTR, HOST_ATTR) : style$$1;\n    };\n    return StyleCompiler;\n}());\nStyleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nStyleCompiler.ctorParameters = function () { return [\n    { type: UrlResolver, },\n]; };\n/**\n * @param {?} component\n * @return {?}\n */\nfunction getStylesVarName(component) {\n    var /** @type {?} */ result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = (function () {\n    function EventHandlerVars() {\n    }\n    return EventHandlerVars;\n}());\nEventHandlerVars.event = variable('$event');\nvar ConvertActionBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} allowDefault\n     */\n    function ConvertActionBindingResult(stmts, allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (args) { return literalMap(/** @type {?} */ (keys.map(function (key, i) { return [key, args[i]]; }))); };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    var /** @type {?} */ lastIndex = actionStmts.length - 1;\n    var /** @type {?} */ preventDefaultVar = null;\n    if (lastIndex >= 0) {\n        var /** @type {?} */ lastStatement = actionStmts[lastIndex];\n        var /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} currValExpr\n     */\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n    var /** @type {?} */ stmts = [];\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    if (visitor.temporaryCount) {\n        for (var /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n            stmts.push(temporaryDeclaration(bindingId, i));\n        }\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory, ast) {\n    var /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = (function (_super) {\n    __extends(_BuiltinAstConverter, _super);\n    /**\n     * @param {?} _converterFactory\n     */\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = [ast.exp].concat(ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer));\nvar _AstToIrVisitor = (function () {\n    /**\n     * @param {?} _localResolver\n     * @param {?} _implicitReceiver\n     * @param {?} bindingId\n     */\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var /** @type {?} */ op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var /** @type {?} */ value = this.visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var /** @type {?} */ fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this.visit(ast.target, _Mode.Expression).callFn(convertedArgs);\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        return this._implicitReceiver;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var /** @type {?} */ args = [literal(ast.expressions.length)];\n        for (var /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this.visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        return ast.expressions.length <= 9 ?\n            importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n            importExpr(createIdentifier(Identifiers.interpolate)).callFn([\n                args[0], literalArr(args.slice(1))\n            ]);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var /** @type {?} */ obj = this.visit(ast.obj, _Mode.Expression);\n        var /** @type {?} */ key = this.visit(ast.key, _Mode.Expression);\n        var /** @type {?} */ value = this.visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, literal(ast.value));\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype._getLocal = function (name) { return this._localResolver.getLocal(name); };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var /** @type {?} */ varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n        if (receiver === this._implicitReceiver) {\n            var /** @type {?} */ varExpr = this._getLocal(ast.name);\n            if (varExpr) {\n                throw new Error('Cannot assign to a reference or variable!');\n            }\n        }\n        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this.visit(ast, mode); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visit = function (ast, mode) {\n        var /** @type {?} */ result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} leftMostSafe\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  ,   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n        var /** @type {?} */ temporary;\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var /** @type {?} */ condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var /** @type {?} */ access = this.visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var /** @type {?} */ visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) { return false; }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var /** @type {?} */ tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    /**\n     * @param {?} temporary\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    return _AstToIrVisitor;\n}());\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        ((arg)).forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = (function () {\n    function DefaultLocalResolver() {\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = (function (_super) {\n    __extends(BuiltinFunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} args\n     * @param {?} converter\n     */\n    function BuiltinFunctionCall(span, args, converter) {\n        var _this = _super.call(this, span, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar NG_CONTAINER_TAG = 'ng-container';\nvar ViewCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} viewClassVar\n     * @param {?} rendererTypeVar\n     */\n    function ViewCompileResult(statements, viewClassVar, rendererTypeVar) {\n        this.statements = statements;\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = (function () {\n    /**\n     * @param {?} _genConfigNext\n     * @param {?} _schemaRegistry\n     */\n    function ViewCompiler(_genConfigNext, _schemaRegistry) {\n        this._genConfigNext = _genConfigNext;\n        this._schemaRegistry = _schemaRegistry;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} styles\n     * @param {?} usedPipes\n     * @return {?}\n     */\n    ViewCompiler.prototype.compileComponent = function (component, template, styles, usedPipes) {\n        var /** @type {?} */ embeddedViewCount = 0;\n        var /** @type {?} */ staticQueryIds = findStaticQueryIds(template);\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ renderComponentVarName;\n        if (!component.isHost) {\n            var /** @type {?} */ customRenderData = [];\n            if (component.template.animations && component.template.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(component.template.animations), true));\n            }\n            var /** @type {?} */ renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = renderComponentVar.name;\n            statements.push(renderComponentVar\n                .set(importExpr(createIdentifier(Identifiers.createRendererType2))\n                .callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(component.template.encapsulation)),\n                    new LiteralMapEntry('styles', styles),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData))\n                ])]))\n                .toDeclStmt(importType(createIdentifier(Identifiers.RendererType2)), [StmtModifier.Final]));\n        }\n        var /** @type {?} */ viewBuilderFactory = function (parent) {\n            var /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        var /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        statements.push.apply(statements, visitor.build());\n        return new ViewCompileResult(statements, visitor.viewName, renderComponentVarName);\n    };\n    return ViewCompiler;\n}());\nViewCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nViewCompiler.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: ElementSchemaRegistry, },\n]; };\nvar LOG_VAR = variable('l');\nvar VIEW_VAR = variable('v');\nvar CHECK_VAR = variable('ck');\nvar COMP_VAR = variable('co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} embeddedViewIndex\n     * @param {?} usedPipes\n     * @param {?} staticQueryIds\n     * @param {?} viewBuilderFactory\n     */\n    function ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : importType(this.component.type);\n    }\n    Object.defineProperty(ViewBuilder.prototype, \"viewName\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return viewClassName(this.component.type.reference, this.embeddedViewIndex);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            var /** @type {?} */ queryIds_1 = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var /** @type {?} */ queryId = queryIndex + 1;\n                var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n                var /** @type {?} */ flags = 67108864 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds_1, queryId, query.first);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    /**\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var /** @type {?} */ updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var /** @type {?} */ updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var /** @type {?} */ viewFlags = 0;\n        if (!this.parent && this.component.changeDetection === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */].OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var /** @type {?} */ viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR.name)], [new ReturnStatement(importExpr(createIdentifier(Identifiers.viewDef)).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(createIdentifier(Identifiers.ViewDefinition)));\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    /**\n     * @param {?} updateStmts\n     * @return {?}\n     */\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var /** @type {?} */ updateFn;\n        if (updateStmts.length > 0) {\n            var /** @type {?} */ preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(CHECK_VAR.name, INFERRED_TYPE),\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE)\n            ], preStmts.concat(updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 4 /* TypeNgContent */,\n            nodeDef: importExpr(createIdentifier(Identifiers.ngContentDef)).callFn([\n                literal(ast.ngContentIndex), literal(ast.index)\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr([literal(ast.value)])\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var /** @type {?} */ astWithSource = (ast.value);\n        var /** @type {?} */ inter = (astWithSource.ast);\n        var /** @type {?} */ updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) { return literal(s); }))\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        var /** @type {?} */ elName = ast.name;\n        if (ast.name === NG_CONTAINER_TAG) {\n            // Using a null element name creates an anchor.\n            elName = null;\n        }\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var /** @type {?} */ inputDefs = [];\n        var /** @type {?} */ updateRendererExpressions = [];\n        var /** @type {?} */ outputDefs = [];\n        if (elName) {\n            var /** @type {?} */ hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: /** @type {?} */ (COMP_VAR),\n                inputAst: inputAst,\n                dirAst: null,\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var target = _a[0], eventName = _a[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var /** @type {?} */ compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var /** @type {?} */ compRendererType = NULL_EXPR;\n        var /** @type {?} */ compView = NULL_EXPR;\n        if (compAst) {\n            compView = importExpr({ reference: compAst.directive.componentViewType });\n            compRendererType = importExpr({ reference: compAst.directive.rendererType });\n        }\n        // elementDef(\n        //   flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][],\n        //   ngContentIndex: number, childCount: number, namespaceAndName: string,\n        //   fixedAttrs: [string, string][] = [],\n        //   bindings?: [BindingFlags, string, string | SecurityContext][],\n        //   outputs?: ([OutputType.ElementOutput | OutputType.DirectiveHostOutput, string, string])[],\n        //   handleEvent?: ElementHandleEventFn,\n        //   componentView?: () => ViewDefinition, componentRendererType?: RendererType2): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.elementDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} ast\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var /** @type {?} */ flags = 0;\n        if (ast.hasViewContainer) {\n            flags |= 8388608 /* EmbeddedViews */;\n        }\n        var /** @type {?} */ usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(target, name), [target, name]);\n            });\n        });\n        var /** @type {?} */ hostBindings = [];\n        var /** @type {?} */ hostEvents = [];\n        var /** @type {?} */ componentFactoryResolverProvider = createComponentFactoryResolver(ast.directives);\n        if (componentFactoryResolverProvider) {\n            this._visitProvider(componentFactoryResolverProvider, ast.queryMatches);\n        }\n        ast.providers.forEach(function (providerAst, providerIndex) {\n            var /** @type {?} */ dirAst;\n            var /** @type {?} */ dirIndex;\n            ast.directives.forEach(function (localDirAst, i) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, _this.staticQueryIds.get(/** @type {?} */ (ast))), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, dirHostBindings);\n                hostEvents.push.apply(hostEvents, dirHostEvents);\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var /** @type {?} */ valueType;\n            if (tokenReference(match.value) === resolveIdentifier(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var /** @type {?} */ valueType;\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} dirAst\n     * @param {?} directiveIndex\n     * @param {?} elementNodeIndex\n     * @param {?} refs\n     * @param {?} queryMatches\n     * @param {?} usedEvents\n     * @param {?} queryIds\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var /** @type {?} */ queryId = dirAst.contentQueryStartId + queryIndex;\n            var /** @type {?} */ flags = 33554432 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n            var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 16384 /* Component */;\n        }\n        var /** @type {?} */ inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var /** @type {?} */ mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var /** @type {?} */ outputDefs = [];\n        var /** @type {?} */ dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var /** @type {?} */ eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var /** @type {?} */ updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var /** @type {?} */ dirContextExpr = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n            VIEW_VAR, literal(nodeIndex)\n        ]);\n        var /** @type {?} */ hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var /** @type {?} */ hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst: dirAst,\n        }); });\n        // directiveDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], childCount: number, ctor:\n        //   any,\n        //   deps: ([DepFlags, any] | any)[], props?: {[name: string]: [number, string]},\n        //   outputs?: {[name: string]: string}, component?: () => ViewDefinition): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 8192 /* TypeDirective */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.directiveDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount), providerExpr, depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: providerAst.sourceSpan,\n            nodeFlags: flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.providerDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                tokenExpr(providerAst.token), providerExpr, depsExpr\n            ])\n        }); };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var /** @type {?} */ flags = 0;\n        if (!providerAst.eager) {\n            flags |= 2048 /* LazyProvider */;\n        }\n        if (providerAst.providerType === ProviderAstType.PrivateService) {\n            flags |= 4096 /* PrivateProvider */;\n        }\n        providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for regular providers, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy ||\n                providerAst.providerType === ProviderAstType.Directive ||\n                providerAst.providerType === ProviderAstType.Component) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerType = _a.flags;\n        return { flags: flags | providerType, queryMatchExprs: queryMatchExprs, providerExpr: providerExpr, depsExpr: depsExpr };\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var /** @type {?} */ currViewExpr = VIEW_VAR;\n        for (var /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var /** @type {?} */ refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                    currViewExpr, literal(refNodeIndex)\n                ]);\n            }\n            // check variables\n            var /** @type {?} */ varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var /** @type {?} */ varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var /** @type {?} */ valueExpr_1 = importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));\n            return function () { return valueExpr_1; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // pureArrayDef(argCount: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePureArray */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureArrayDef)).callFn([literal(argCount)])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} keys\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var /** @type {?} */ valueExpr_2 = importExpr(createIdentifier(Identifiers.EMPTY_MAP));\n            return function () { return valueExpr_2; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // function pureObjectDef(propertyNames: string[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureObject */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureObjectDef))\n                .callFn([literalArr(keys.map(function (key) { return literal(key); }))])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} expression\n     * @param {?} name\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createPipeConverter = function (expression, name, argCount) {\n        var /** @type {?} */ pipe = this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; });\n        if (pipe.pure) {\n            var /** @type {?} */ nodeIndex_1 = this.nodes.length;\n            // function purePipeDef(argCount: number): NodeDef;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 64 /* TypePurePipe */,\n                nodeDef: importExpr(createIdentifier(Identifiers.purePipeDef))\n                    .callFn([literal(argCount)])\n            }); });\n            // find underlying pipe in the component view\n            var /** @type {?} */ compViewExpr = VIEW_VAR;\n            var /** @type {?} */ compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var /** @type {?} */ pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var /** @type {?} */ pipeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                compViewExpr, literal(pipeNodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(nodeIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var /** @type {?} */ nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var /** @type {?} */ nodeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                VIEW_VAR, literal(nodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} pipe\n     * @return {?}\n     */\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        var /** @type {?} */ flags = 0;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ depExprs = pipe.type.diDeps.map(depDef);\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 8 /* TypePipe */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pipeDef)).callFn([\n                literal(flags), importExpr(pipe.type), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return _this.createLiteralArrayConverter(expression.sourceSpan, argCount); },\n                createLiteralMapConverter: function (keys) { return _this.createLiteralMapConverter(expression.sourceSpan, keys); },\n                createPipeConverter: function (name, argCount) { return _this.createPipeConverter(expression, name, argCount); }\n            }, expression.value)\n        };\n    };\n    /**\n     * @return {?}\n     */\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ updateBindingCount = 0;\n        var /** @type {?} */ updateRendererStmts = [];\n        var /** @type {?} */ updateDirectivesStmts = [];\n        var /** @type {?} */ nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var /** @type {?} */ logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        /**\n         * @param {?} nodeIndex\n         * @param {?} sourceSpan\n         * @param {?} expressions\n         * @param {?} allowEmptyExprs\n         * @return {?}\n         */\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var /** @type {?} */ updateStmts = [];\n            var /** @type {?} */ exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var /** @type {?} */ bindingId = \"\" + updateBindingCount++;\n                var /** @type {?} */ nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); }));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} handlers\n     * @return {?}\n     */\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var /** @type {?} */ handleEventStmts = [];\n        var /** @type {?} */ handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var /** @type {?} */ bindingId = \"\" + handleEventBindingCount++;\n            var /** @type {?} */ nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var /** @type {?} */ trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var /** @type {?} */ fullEventName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var /** @type {?} */ handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var /** @type {?} */ preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE),\n                new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),\n                new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)\n            ], preStmts.concat(handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n/**\n * @param {?} providerAst\n * @return {?}\n */\nfunction providerDef(providerAst) {\n    return providerAst.multiProvider ?\n        multiProviderDef(providerAst.providers) :\n        singleProviderDef(providerAst.providerType, providerAst.providers[0]);\n}\n/**\n * @param {?} providers\n * @return {?}\n */\nfunction multiProviderDef(providers) {\n    var /** @type {?} */ allDepDefs = [];\n    var /** @type {?} */ allParams = [];\n    var /** @type {?} */ exprs = providers.map(function (provider, providerIndex) {\n        var /** @type {?} */ expr;\n        if (provider.useClass) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = importExpr(provider.useClass).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = importExpr(provider.useFactory).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(provider.useValue);\n        }\n        return expr;\n    });\n    var /** @type {?} */ providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return { providerExpr: providerExpr, flags: 512 /* TypeFactoryProvider */, depsExpr: literalArr(allDepDefs) };\n    /**\n     * @param {?} providerIndex\n     * @param {?} deps\n     * @return {?}\n     */\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var /** @type {?} */ paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(dep));\n            return variable(paramName);\n        });\n    }\n}\n/**\n * @param {?} providerType\n * @param {?} providerMeta\n * @return {?}\n */\nfunction singleProviderDef(providerType, providerMeta) {\n    var /** @type {?} */ providerExpr;\n    var /** @type {?} */ flags;\n    var /** @type {?} */ deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = importExpr(providerMeta.useClass);\n        flags = 8192 /* TypeDirective */;\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = importExpr(providerMeta.useClass);\n            flags = 256 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = importExpr(providerMeta.useFactory);\n            flags = 512 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags = 1024 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(providerMeta.useValue);\n            flags = 128 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var /** @type {?} */ depsExpr = literalArr(deps.map(function (dep) { return depDef(dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\n/**\n * @param {?} tokenMeta\n * @return {?}\n */\nfunction tokenExpr(tokenMeta) {\n    return tokenMeta.identifier ? importExpr(tokenMeta.identifier) : literal(tokenMeta.value);\n}\n/**\n * @param {?} dep\n * @return {?}\n */\nfunction depDef(dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isSelf, isHost\n    var /** @type {?} */ expr = dep.isValue ? convertValueToOutputAst(dep.value) : tokenExpr(dep.token);\n    var /** @type {?} */ flags = 0;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\n/**\n * @param {?} astNodes\n * @return {?}\n */\nfunction needsAdditionalRootNode(astNodes) {\n    var /** @type {?} */ lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (lastAstNode.name === NG_CONTAINER_TAG && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\n/**\n * @param {?} lifecycleHook\n * @return {?}\n */\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var /** @type {?} */ nodeFlag = 0;\n    switch (lifecycleHook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentChecked:\n            nodeFlag = 1048576 /* AfterContentChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentInit:\n            nodeFlag = 524288 /* AfterContentInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewChecked:\n            nodeFlag = 4194304 /* AfterViewChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewInit:\n            nodeFlag = 2097152 /* AfterViewInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].DoCheck:\n            nodeFlag = 131072 /* DoCheck */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnChanges:\n            nodeFlag = 262144 /* OnChanges */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy:\n            nodeFlag = 65536 /* OnDestroy */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnInit:\n            nodeFlag = 32768 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\n/**\n * @param {?} inputAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementBindingDef(inputAst, dirAst) {\n    switch (inputAst.type) {\n        case PropertyBindingType.Attribute:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Property:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Animation:\n            var /** @type {?} */ bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Class:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case PropertyBindingType.Style:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n    }\n}\n/**\n * @param {?} elementAst\n * @return {?}\n */\nfunction fixedAttrsDef(elementAst) {\n    var /** @type {?} */ mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var /** @type {?} */ value = dirAst.directive.hostAttributes[name];\n            var /** @type {?} */ prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    var /** @type {?} */ mapEntries = [];\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\n/**\n * @param {?} attrName\n * @param {?} attrValue1\n * @param {?} attrValue2\n * @return {?}\n */\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} exprs\n * @return {?}\n */\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)].concat(exprs));\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} bindingIdx\n * @param {?} expr\n * @return {?}\n */\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(createIdentifier(Identifiers.unwrapValue)).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\n/**\n * @param {?} nodes\n * @param {?=} result\n * @return {?}\n */\nfunction findStaticQueryIds(nodes, result) {\n    if (result === void 0) { result = new Map(); }\n    nodes.forEach(function (node) {\n        var /** @type {?} */ staticQueryIds = new Set();\n        var /** @type {?} */ dynamicQueryIds = new Set();\n        var /** @type {?} */ queryMatches;\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach(function (match) { return staticQueryIds.add(match.queryId); });\n        }\n        dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n        result.set(node, { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds });\n    });\n    return result;\n}\n/**\n * @param {?} nodeStaticQueryIds\n * @return {?}\n */\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    var /** @type {?} */ staticQueryIds = new Set();\n    var /** @type {?} */ dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach(function (entry) {\n        entry.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n        entry.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n    });\n    dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n    return { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds };\n}\n/**\n * @param {?} directives\n * @return {?}\n */\nfunction createComponentFactoryResolver(directives) {\n    var /** @type {?} */ componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n    if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n        var /** @type {?} */ entryComponentFactories = componentDirMeta.directive.entryComponents.map(function (entryComponent) { return importExpr({ reference: entryComponent.componentFactory }); });\n        var /** @type {?} */ token = createIdentifierToken(Identifiers.ComponentFactoryResolver);\n        var /** @type {?} */ classMeta = {\n            diDeps: [\n                { isValue: true, value: literalArr(entryComponentFactories) },\n                { token: token, isSkipSelf: true, isOptional: true },\n                { token: createIdentifierToken(Identifiers.NgModuleRef) },\n            ],\n            lifecycleHooks: [],\n            reference: resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)\n        };\n        return new ProviderAst(token, false, true, [{ token: token, multi: false, useClass: classMeta }], ProviderAstType.PrivateService, [], componentDirMeta.sourceSpan);\n    }\n    return null;\n}\n/**\n * @param {?} eventAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\n/**\n * @param {?} queryIds\n * @param {?} queryId\n * @param {?} isFirst\n * @return {?}\n */\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {\n    var /** @type {?} */ flags = 0;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {\n        flags |= 134217728 /* StaticQuery */;\n    }\n    else {\n        flags |= 268435456 /* DynamicQuery */;\n    }\n    return flags;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = (function () {\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} source\n     */\n    function GeneratedFile(srcFileUrl, genFileUrl, source) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        this.source = source;\n    }\n    return GeneratedFile;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} summaryResolver\n * @param {?} symbolResolver\n * @param {?} symbols\n * @param {?} types\n * @return {?}\n */\nfunction serializeSummaries(summaryResolver, symbolResolver, symbols, types) {\n    var /** @type {?} */ serializer = new Serializer$1(symbolResolver, summaryResolver);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return serializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add summaries that are referenced by the given symbols (transitively)\n    // Note: the serializer.symbols array might be growing while\n    // we execute the loop!\n    for (var /** @type {?} */ processedIndex = 0; processedIndex < serializer.symbols.length; processedIndex++) {\n        var /** @type {?} */ symbol = serializer.symbols[processedIndex];\n        if (summaryResolver.isLibraryFile(symbol.filePath)) {\n            var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n            if (!summary) {\n                // some symbols might originate from a plain typescript library\n                // that just exported .d.ts and .metadata.json files, i.e. where no summary\n                // files were created.\n                var /** @type {?} */ resolvedSymbol = symbolResolver.resolveSymbol(symbol);\n                if (resolvedSymbol) {\n                    summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n                }\n            }\n            if (summary) {\n                serializer.addOrMergeSummary(summary);\n            }\n        }\n    }\n    // Add type summaries.\n    // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n    // as the type summaries already contain the transitive data that they require\n    // (in a minimal way).\n    types.forEach(function (typeSummary) {\n        serializer.addOrMergeSummary({ symbol: typeSummary.type.reference, metadata: null, type: typeSummary });\n        if (typeSummary.summaryKind === CompileSummaryKind.NgModule) {\n            var /** @type {?} */ ngModuleSummary = (typeSummary);\n            ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                var /** @type {?} */ symbol = id.reference;\n                if (summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n                    if (summary) {\n                        serializer.addOrMergeSummary(summary);\n                    }\n                }\n            });\n        }\n    });\n    return serializer.serialize();\n}\n/**\n * @param {?} symbolCache\n * @param {?} json\n * @return {?}\n */\nfunction deserializeSummaries(symbolCache, json) {\n    var /** @type {?} */ deserializer = new Deserializer(symbolCache);\n    return deserializer.deserialize(json);\n}\nvar Serializer$1 = (function (_super) {\n    __extends(Serializer$1, _super);\n    /**\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     */\n    function Serializer$1(symbolResolver, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        return _this;\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    Serializer$1.prototype.addOrMergeSummary = function (summary) {\n        var /** @type {?} */ symbolMeta = summary.metadata;\n        if (symbolMeta && symbolMeta.__symbolic === 'class') {\n            // For classes, we keep everything except their class decorators.\n            // We need to keep e.g. the ctor args, method names, method decorators\n            // so that the class can be extended in another compilation unit.\n            // We don't keep the class decorators as\n            // 1) they refer to data\n            //   that should not cause a rebuild of downstream compilation units\n            //   (e.g. inline templates of @Component, or @NgModule.declarations)\n            // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n            var /** @type {?} */ clone_1 = {};\n            Object.keys(symbolMeta).forEach(function (propName) {\n                if (propName !== 'decorators') {\n                    clone_1[propName] = symbolMeta[propName];\n                }\n            });\n            symbolMeta = clone_1;\n        }\n        var /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!processedSummary) {\n            processedSummary = this.processValue({ symbol: summary.symbol });\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.metadata == null && symbolMeta != null) {\n            processedSummary.metadata = this.processValue(symbolMeta);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.type == null && summary.type != null) {\n            processedSummary.type = this.processValue(summary.type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    Serializer$1.prototype.serialize = function () {\n        var _this = this;\n        var /** @type {?} */ exportAs = [];\n        var /** @type {?} */ json = JSON.stringify({\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var /** @type {?} */ importAs;\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    importAs = symbol.name + \"_\" + index;\n                    exportAs.push({ symbol: symbol, exportAs: importAs });\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    // We convert the source filenames tinto output filenames,\n                    // as the generated summary file will be used when teh current\n                    // compilation unit is used as a library\n                    filePath: _this.summaryResolver.getLibraryFileName(symbol.filePath),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    Serializer$1.prototype.processValue = function (value) { return visitValue(value, this, null); };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    Serializer$1.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var /** @type {?} */ baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var /** @type {?} */ index = this.indexBySymbol.get(baseSymbol);\n            // Note: == on purpose to compare with undefined!\n            if (index == null) {\n                index = this.indexBySymbol.size;\n                this.indexBySymbol.set(baseSymbol, index);\n                this.symbols.push(baseSymbol);\n            }\n            return { __symbol: index, members: value.members };\n        }\n    };\n    return Serializer$1;\n}(ValueTransformer));\nvar Deserializer = (function (_super) {\n    __extends(Deserializer, _super);\n    /**\n     * @param {?} symbolCache\n     */\n    function Deserializer(symbolCache) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        return _this;\n    }\n    /**\n     * @param {?} json\n     * @return {?}\n     */\n    Deserializer.prototype.deserialize = function (json) {\n        var _this = this;\n        var /** @type {?} */ data = JSON.parse(json);\n        var /** @type {?} */ importAs = [];\n        this.symbols = [];\n        data.symbols.forEach(function (serializedSymbol) {\n            var /** @type {?} */ symbol = _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name);\n            _this.symbols.push(symbol);\n            if (serializedSymbol.importAs) {\n                importAs.push({ symbol: symbol, importAs: serializedSymbol.importAs });\n            }\n        });\n        var /** @type {?} */ summaries = visitValue(data.summaries, this, null);\n        return { summaries: summaries, importAs: importAs };\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    Deserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var /** @type {?} */ baseSymbol = this.symbols[map['__symbol']];\n            var /** @type {?} */ members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return Deserializer;\n}(ValueTransformer));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _host\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _outputEmitter\n     * @param {?} _summaryResolver\n     * @param {?} _localeId\n     * @param {?} _translationFormat\n     * @param {?} _genFilePreamble\n     * @param {?} _symbolResolver\n     */\n    function AotCompiler(_config, _host, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _genFilePreamble, _symbolResolver) {\n        this._config = _config;\n        this._host = _host;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._localeId = _localeId;\n        this._translationFormat = _translationFormat;\n        this._genFilePreamble = _genFilePreamble;\n        this._symbolResolver = _symbolResolver;\n    }\n    /**\n     * @return {?}\n     */\n    AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    AotCompiler.prototype.compileAll = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver), ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n            return flatten(sourceModules);\n        });\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ngModuleByPipeOrDirective\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @return {?}\n     */\n    AotCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl)[1];\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ exportedVars = [];\n        var /** @type {?} */ generatedFiles = [];\n        generatedFiles.push(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, statements, exportedVars));\n        // compile all ng modules\n        exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));\n        // compile components\n        directives.forEach(function (dirType) {\n            var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            if (!compMeta.isComponent) {\n                return Promise.resolve(null);\n            }\n            var /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            _assertComponent(compMeta);\n            // compile styles\n            var /** @type {?} */ stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);\n            stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {\n                generatedFiles.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));\n            });\n            // compile components\n            var /** @type {?} */ compViewVars = _this._compileComponent(compMeta, ngModule, ngModule.transitiveModule.directives, stylesCompileResults.componentStylesheet, fileSuffix, statements);\n            exportedVars.push(_this._compileComponentFactory(compMeta, ngModule, fileSuffix, statements), compViewVars.viewClassVar, compViewVars.compRenderTypeVar);\n        });\n        if (statements.length > 0) {\n            var /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, ngfactoryFilePath(srcFileUrl), statements, exportedVars);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @param {?} targetStatements\n     * @param {?} targetExportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._createSummary = function (srcFileUrl, directives, pipes, ngModules, injectables, targetStatements, targetExportedVars) {\n        var _this = this;\n        var /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var /** @type {?} */ typeSummaries = ngModules.map(function (ref) { return _this._metadataResolver.getNgModuleSummary(ref); }).concat(directives.map(function (ref) { return _this._metadataResolver.getDirectiveSummary(ref); }), pipes.map(function (ref) { return _this._metadataResolver.getPipeSummary(ref); }), injectables.map(function (ref) { return _this._metadataResolver.getInjectableSummary(ref); }));\n        var _a = serializeSummaries(this._summaryResolver, this._symbolResolver, symbolSummaries, typeSummaries), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            targetStatements.push(variable(entry.exportAs).set(importExpr({ reference: entry.symbol })).toDeclStmt());\n            targetExportedVars.push(entry.exportAs);\n        });\n        return new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);\n        var /** @type {?} */ providers = [];\n        if (this._localeId) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.LOCALE_ID),\n                useValue: this._localeId,\n            });\n        }\n        if (this._translationFormat) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._translationFormat\n            });\n        }\n        var /** @type {?} */ appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);\n        targetStatements.push.apply(targetStatements, appCompileResult.statements);\n        return appCompileResult.ngModuleFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponentFactory = function (compMeta, ngModule, fileSuffix, targetStatements) {\n        var /** @type {?} */ hostType = this._metadataResolver.getHostComponentType(compMeta.type.reference);\n        var /** @type {?} */ hostMeta = createHostComponentMeta(hostType, compMeta, this._metadataResolver.getHostComponentViewClass(hostType));\n        var /** @type {?} */ hostViewFactoryVar = this._compileComponent(hostMeta, ngModule, [compMeta.type], null, fileSuffix, targetStatements)\n            .viewClassVar;\n        var /** @type {?} */ compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var /** @type {?} */ inputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.inputs) {\n            var /** @type {?} */ templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var /** @type {?} */ outputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.outputs) {\n            var /** @type {?} */ templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        targetStatements.push(variable(compFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.createComponentFactory)).callFn([\n            literal(compMeta.selector), importExpr(compMeta.type),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(compMeta.template.ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(createIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const]), [StmtModifier.Final]));\n        return compFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @param {?} componentStyles\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponent = function (compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements) {\n        var _this = this;\n        var /** @type {?} */ directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template)), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var /** @type {?} */ viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            targetStatements.push.apply(targetStatements, _resolveStyleStatements(this._symbolResolver, componentStyles, fileSuffix));\n        }\n        targetStatements.push.apply(targetStatements, viewResult.statements);\n        return { viewClassVar: viewResult.viewClassVar, compRenderTypeVar: viewResult.rendererTypeVar };\n    };\n    /**\n     * @param {?} fileUrl\n     * @param {?} stylesCompileResult\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {\n        _resolveStyleStatements(this._symbolResolver, stylesCompileResult, fileSuffix);\n        return this._codegenSourceModule(fileUrl, _stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} statements\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, genFileUrl, statements, exportedVars) {\n        return new GeneratedFile(srcFileUrl, genFileUrl, this._outputEmitter.emitStatements(sourceUrl(srcFileUrl), genFileUrl, statements, exportedVars, this._genFilePreamble));\n    };\n    return AotCompiler;\n}());\n/**\n * @param {?} reflector\n * @param {?} compileResult\n * @param {?} fileSuffix\n * @return {?}\n */\nfunction _resolveStyleStatements(reflector, compileResult, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.valuePlaceholder.reference = reflector.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix), dep.name);\n    });\n    return compileResult.statements;\n}\n/**\n * @param {?} stylesheetUrl\n * @param {?} shim\n * @param {?} suffix\n * @return {?}\n */\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction _assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeNgModules(programStaticSymbols, host, metadataResolver) {\n    var _a = _createNgModules(programStaticSymbols, host, metadataResolver), ngModules = _a.ngModules, symbolsMissingModule = _a.symbolsMissingModule;\n    return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ result = analyzeNgModules(programStaticSymbols, host, metadataResolver);\n    if (result.symbolsMissingModule && result.symbolsMissingModule.length) {\n        var /** @type {?} */ messages = result.symbolsMissingModule.map(function (s) { return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\"; });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return result;\n}\n/**\n * @param {?} programSymbols\n * @param {?} ngModuleMetas\n * @param {?} symbolsMissingModule\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {\n    var /** @type {?} */ moduleMetasByRef = new Map();\n    ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });\n    var /** @type {?} */ ngModuleByPipeOrDirective = new Map();\n    var /** @type {?} */ ngModulesByFile = new Map();\n    var /** @type {?} */ ngDirectivesByFile = new Map();\n    var /** @type {?} */ ngPipesByFile = new Map();\n    var /** @type {?} */ ngInjectablesByFile = new Map();\n    var /** @type {?} */ filePaths = new Set();\n    // Make sure we produce an analyzed file for each input file\n    programSymbols.forEach(function (symbol) {\n        var /** @type {?} */ filePath = symbol.filePath;\n        filePaths.add(filePath);\n        if (metadataResolver.isInjectable(symbol)) {\n            ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));\n        }\n    });\n    // Looping over all modules to construct:\n    // - a map from file to modules `ngModulesByFile`,\n    // - a map from file to directives `ngDirectivesByFile`,\n    // - a map from file to pipes `ngPipesByFile`,\n    // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.\n    ngModuleMetas.forEach(function (ngModuleMeta) {\n        var /** @type {?} */ srcFileUrl = ngModuleMeta.type.reference.filePath;\n        filePaths.add(srcFileUrl);\n        ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));\n        ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n            var /** @type {?} */ fileUrl = dirIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));\n            ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);\n        });\n        ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {\n            var /** @type {?} */ fileUrl = pipeIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));\n            ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);\n        });\n    });\n    var /** @type {?} */ files = [];\n    filePaths.forEach(function (srcUrl) {\n        var /** @type {?} */ directives = ngDirectivesByFile.get(srcUrl) || [];\n        var /** @type {?} */ pipes = ngPipesByFile.get(srcUrl) || [];\n        var /** @type {?} */ ngModules = ngModulesByFile.get(srcUrl) || [];\n        var /** @type {?} */ injectables = ngInjectablesByFile.get(srcUrl) || [];\n        files.push({ srcUrl: srcUrl, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables });\n    });\n    return {\n        // map directive/pipe to module\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        // list modules and directives for every source file\n        files: files,\n        ngModules: ngModuleMetas, symbolsMissingModule: symbolsMissingModule\n    };\n}\n/**\n * @param {?} staticSymbolResolver\n * @param {?} files\n * @param {?} host\n * @return {?}\n */\nfunction extractProgramSymbols(staticSymbolResolver, files, host) {\n    var /** @type {?} */ staticSymbols = [];\n    files.filter(function (fileName) { return host.isSourceFile(fileName); }).forEach(function (sourceFile) {\n        staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function (symbol) {\n            var /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var /** @type {?} */ symbolMeta = resolvedSymbol.metadata;\n            if (symbolMeta) {\n                if (symbolMeta.__symbolic != 'error') {\n                    // Ignore symbols that are only included to record error information.\n                    staticSymbols.push(resolvedSymbol.symbol);\n                }\n            }\n        });\n    });\n    return staticSymbols;\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _createNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ ngModules = new Map();\n    var /** @type {?} */ programPipesAndDirectives = [];\n    var /** @type {?} */ ngModulePipesAndDirective = new Set();\n    var /** @type {?} */ addNgModule = function (staticSymbol) {\n        if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {\n            return false;\n        }\n        var /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);\n        if (ngModule) {\n            ngModules.set(ngModule.type.reference, ngModule);\n            ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });\n            ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });\n            // For every input module add the list of transitively included modules\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.reference); });\n        }\n        return !!ngModule;\n    };\n    programStaticSymbols.forEach(function (staticSymbol) {\n        if (!addNgModule(staticSymbol) &&\n            (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {\n            programPipesAndDirectives.push(staticSymbol);\n        }\n    });\n    // Throw an error if any of the program pipe or directives is not declared by a module\n    var /** @type {?} */ symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });\n    return { ngModules: Array.from(ngModules.values()), symbolsMissingModule: symbolsMissingModule };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StaticAndDynamicReflectionCapabilities = (function () {\n    /**\n     * @param {?} staticDelegate\n     */\n    function StaticAndDynamicReflectionCapabilities(staticDelegate) {\n        this.staticDelegate = staticDelegate;\n        this.dynamicDelegate = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_48\" /* ɵReflectionCapabilities */]();\n    }\n    /**\n     * @param {?} staticDelegate\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.install = function (staticDelegate) {\n        __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].updateCapabilities(new StaticAndDynamicReflectionCapabilities(staticDelegate));\n    };\n    /**\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.factory = function (type) { return this.dynamicDelegate.factory(type); };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\n        return isStaticType(type) ? this.staticDelegate.hasLifecycleHook(type, lcProperty) :\n            this.dynamicDelegate.hasLifecycleHook(type, lcProperty);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.parameters = function (type) {\n        return isStaticType(type) ? this.staticDelegate.parameters(type) :\n            this.dynamicDelegate.parameters(type);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.annotations = function (type) {\n        return isStaticType(type) ? this.staticDelegate.annotations(type) :\n            this.dynamicDelegate.annotations(type);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\n        return isStaticType(typeOrFunc) ? this.staticDelegate.propMetadata(typeOrFunc) :\n            this.dynamicDelegate.propMetadata(typeOrFunc);\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.getter = function (name) { return this.dynamicDelegate.getter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.setter = function (name) { return this.dynamicDelegate.setter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.method = function (name) { return this.dynamicDelegate.method(name); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.importUri = function (type) { return this.staticDelegate.importUri(type); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resourceUri = function (type) { return this.staticDelegate.resourceUri(type); };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @param {?} runtime\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\n        return this.staticDelegate.resolveIdentifier(name, moduleUrl, members);\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) {\n        if (isStaticType(enumIdentifier)) {\n            return this.staticDelegate.resolveEnum(enumIdentifier, name);\n        }\n        else {\n            return null;\n        }\n    };\n    return StaticAndDynamicReflectionCapabilities;\n}());\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isStaticType(type) {\n    return typeof type === 'object' && type.name && type.filePath;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\n/**\n * @param {?} value\n * @return {?}\n */\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = (function () {\n    /**\n     * @param {?} summaryResolver\n     * @param {?} symbolResolver\n     * @param {?=} knownMetadataClasses\n     * @param {?=} knownMetadataFunctions\n     * @param {?=} errorRecorder\n     */\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        var _this = this;\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.conversionMap = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.annotationNames = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]]);\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], 'Directive');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */], 'Component');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */], 'Pipe');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */], 'NgModule');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */], 'Injectable');\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.importUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return staticSymbol ? staticSymbol.filePath : null;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.resourceUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveIdentifier = function (name, moduleUrl, members) {\n        var /** @type {?} */ importSymbol = this.getStaticSymbol(moduleUrl, name);\n        var /** @type {?} */ rootSymbol = this.findDeclaration(moduleUrl, name);\n        if (importSymbol != rootSymbol) {\n            this.symbolResolver.recordImportAs(rootSymbol, importSymbol);\n        }\n        if (members && members.length) {\n            return this.getStaticSymbol(rootSymbol.filePath, rootSymbol.name, members);\n        }\n        return rootSymbol;\n    };\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n        else {\n            return symbol;\n        }\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveEnum = function (enumIdentifier, name) {\n        var /** @type {?} */ staticSymbol = enumIdentifier;\n        var /** @type {?} */ members = (staticSymbol.members || []).concat(name);\n        return this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name, members);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        var /** @type {?} */ annotations = this.annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, parentAnnotations);\n            }\n            var /** @type {?} */ ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = this.simplify(type, classMetadata['decorators']);\n                annotations.push.apply(annotations, ownAnnotations_1);\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var /** @type {?} */ summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var /** @type {?} */ requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n                    var /** @type {?} */ typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return ann instanceof requiredType; }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(syntaxError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[summary.type.summaryKind] + \" in another compilation unit without duplicating the decorator. \" +\n                            (\"Please add a \" + requiredAnnotationTypes.map(function (type) { return _this.annotationNames.get(type); }).join(' or ') + \" decorator to the class.\")), type);\n                    }\n                }\n            }\n            this.annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var /** @type {?} */ propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    propMetadata[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var /** @type {?} */ propData = members_1[propName];\n                var /** @type {?} */ prop = ((propData))\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var /** @type {?} */ decorators = [];\n                if (propMetadata[propName]) {\n                    decorators.push.apply(decorators, propMetadata[propName]);\n                }\n                propMetadata[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.parameters = function (type) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var /** @type {?} */ parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n                var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n                var /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;\n                var /** @type {?} */ ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var /** @type {?} */ ctor = ((ctorData)).find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var /** @type {?} */ parameterTypes = (this.simplify(type, ctor['parameters'] || []));\n                    var /** @type {?} */ parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));\n                    parameters_1 = [];\n                    parameterTypes.forEach(function (paramType, index) {\n                        var /** @type {?} */ nestedResult = [];\n                        if (paramType) {\n                            nestedResult.push(paramType);\n                        }\n                        var /** @type {?} */ decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, decorators);\n                        }\n                        parameters_1.push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype._methodNames = function (type) {\n        var /** @type {?} */ methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    methodNames[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var /** @type {?} */ propData = members_2[propName];\n                var /** @type {?} */ isMethod = ((propData)).some(function (a) { return a['__symbolic'] == 'method'; });\n                methodNames[propName] = methodNames[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    /**\n     * @param {?} type\n     * @param {?} classMetadata\n     * @return {?}\n     */\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var /** @type {?} */ parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctor\n     * @return {?}\n     */\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, [void 0].concat(args)))(); });\n    };\n    /**\n     * @param {?} type\n     * @param {?} fn\n     * @return {?}\n     */\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    /**\n     * @return {?}\n     */\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"S\" /* Attribute */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_49\" /* ContentChild */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_50\" /* ContentChildren */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_51\" /* ViewChild */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_52\" /* ViewChildren */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"M\" /* Input */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_35\" /* Output */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_36\" /* HostBinding */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* HostListener */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'trigger'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_53\" /* trigger */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'state'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_54\" /* state */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'transition'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_55\" /* transition */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'style'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_56\" /* style */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'animate'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_57\" /* animate */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'keyframes'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_58\" /* keyframes */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'sequence'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_59\" /* sequence */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'group'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_60\" /* group */]);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * Simplify but discard any errors\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var /** @type {?} */ originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var /** @type {?} */ result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.simplify = function (context, value) {\n        var _this = this;\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ scope = BindingScope.empty;\n        var /** @type {?} */ calling = new Map();\n        /**\n         * @param {?} context\n         * @param {?} value\n         * @param {?} depth\n         * @return {?}\n         */\n        function simplifyInContext(context, value, depth) {\n            /**\n             * @param {?} staticSymbol\n             * @return {?}\n             */\n            function resolveReferenceValue(staticSymbol) {\n                var /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            /**\n             * @param {?} functionSymbol\n             * @param {?} targetFunction\n             * @param {?} args\n             * @return {?}\n             */\n            function simplifyCall(functionSymbol, targetFunction, args) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        throw new Error('Recursion not supported');\n                    }\n                    calling.set(functionSymbol, true);\n                    try {\n                        var /** @type {?} */ value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var /** @type {?} */ parameters = targetFunction['parameters'];\n                            var /** @type {?} */ defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, defaults.slice(args.length).map(function (value) { return simplify(value); }));\n                            }\n                            var /** @type {?} */ functionScope = BindingScope.build();\n                            for (var /** @type {?} */ i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var /** @type {?} */ oldScope = scope;\n                            var /** @type {?} */ result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyInContext(functionSymbol, value_1, depth + 1);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });\n            }\n            /**\n             * @param {?} expression\n             * @return {?}\n             */\n            function simplify(expression) {\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    var /** @type {?} */ result_2 = [];\n                    for (var _i = 0, _a = ((expression)); _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        // Check for a spread expression\n                        if (item && item.__symbolic === 'spread') {\n                            var /** @type {?} */ spreadArray = simplify(item.expression);\n                            if (Array.isArray(spreadArray)) {\n                                for (var _b = 0, spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {\n                                    var spreadItem = spreadArray_1[_b];\n                                    result_2.push(spreadItem);\n                                }\n                                continue;\n                            }\n                        }\n                        var /** @type {?} */ value_2 = simplify(item);\n                        if (shouldIgnore(value_2)) {\n                            continue;\n                        }\n                        result_2.push(value_2);\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols\n                    if (expression === self.injectionToken || expression === self.opaqueToken ||\n                        self.conversionMap.has(expression)) {\n                        return expression;\n                    }\n                    else {\n                        var /** @type {?} */ staticSymbol = expression;\n                        var /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue) {\n                            return simplifyInContext(staticSymbol, declarationValue, depth + 1);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var /** @type {?} */ staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var /** @type {?} */ left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var /** @type {?} */ right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var /** @type {?} */ condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var /** @type {?} */ operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var /** @type {?} */ indexTarget = simplify(expression['expression']);\n                                var /** @type {?} */ index = simplify(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var /** @type {?} */ member = expression['member'];\n                                var /** @type {?} */ selectContext = context;\n                                var /** @type {?} */ selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var /** @type {?} */ members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue) {\n                                        return simplifyInContext(selectContext, declarationValue, depth + 1);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyInContext(selectContext, selectTarget[member], depth + 1);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references,\n                                // as symbol references have been converted into StaticSymbols already\n                                // in the StaticSymbolResolver!\n                                var /** @type {?} */ name = expression['name'];\n                                var /** @type {?} */ localValue = scope.resolve(name);\n                                if (localValue != BindingScope.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        return context;\n                                    }\n                                    var /** @type {?} */ argExpressions = expression['arguments'] || [];\n                                    var /** @type {?} */ converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var /** @type {?} */ args = argExpressions.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                var /** @type {?} */ message = produceErrorMessage(expression);\n                                if (expression['line']) {\n                                    message =\n                                        message + \" (position \" + (expression['line'] + 1) + \":\" + (expression['character'] + 1) + \" in the original .ts file)\";\n                                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);\n                                }\n                                else {\n                                    self.reportError(new Error(message), context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) { return simplify(value); });\n                }\n                return IGNORE;\n            }\n            try {\n                return simplify(value);\n            }\n            catch (e) {\n                var /** @type {?} */ members = context.members.length ? \".\" + context.members.join('.') : '';\n                var /** @type {?} */ message = e.message + \", resolving symbol \" + context.name + members + \" in \" + context.filePath;\n                if (e.fileName) {\n                    throw positionalError(message, e.fileName, e.line, e.column);\n                }\n                throw syntaxError(message);\n            }\n        }\n        var /** @type {?} */ recordedSimplifyInContext = function (context, value, depth) {\n            try {\n                return simplifyInContext(context, value, depth);\n            }\n            catch (e) {\n                _this.reportError(e, context);\n            }\n        };\n        var /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value, 0) :\n            simplifyInContext(context, value, 0);\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    return StaticReflector;\n}());\n/**\n * @param {?} error\n * @return {?}\n */\nfunction expandedMessage(error) {\n    switch (error.message) {\n        case 'Reference to non-exported class':\n            if (error.context && error.context.className) {\n                return \"Reference to a non-exported class \" + error.context.className + \". Consider exporting the class\";\n            }\n            break;\n        case 'Variable not initialized':\n            return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n        case 'Destructuring not supported':\n            return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n        case 'Could not resolve type':\n            if (error.context && error.context.typeName) {\n                return \"Could not resolve type \" + error.context.typeName;\n            }\n            break;\n        case 'Function call not supported':\n            var /** @type {?} */ prefix = error.context && error.context.name ? \"Calling function '\" + error.context.name + \"', f\" : 'F';\n            return prefix +\n                'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n        case 'Reference to a local symbol':\n            if (error.context && error.context.name) {\n                return \"Reference to a local (non-exported) symbol '\" + error.context.name + \"'. Consider exporting the symbol\";\n            }\n            break;\n    }\n    return error.message;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction produceErrorMessage(error) {\n    return \"Error encountered resolving symbol values statically. \" + expandedMessage(error);\n}\n/**\n * @param {?} input\n * @param {?} transform\n * @return {?}\n */\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var /** @type {?} */ result = {};\n    Object.keys(input).forEach(function (key) {\n        var /** @type {?} */ value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\n/**\n * @param {?} o\n * @return {?}\n */\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n/**\n * @abstract\n */\nvar BindingScope = (function () {\n    function BindingScope() {\n    }\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    BindingScope.prototype.resolve = function (name) { };\n    /**\n     * @return {?}\n     */\n    BindingScope.build = function () {\n        var /** @type {?} */ current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    return BindingScope;\n}());\nBindingScope.missing = {};\nBindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\nvar PopulatedScope = (function (_super) {\n    __extends(PopulatedScope, _super);\n    /**\n     * @param {?} bindings\n     */\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    };\n    return PopulatedScope;\n}(BindingScope));\n/**\n * @param {?} message\n * @param {?} fileName\n * @param {?} line\n * @param {?} column\n * @return {?}\n */\nfunction positionalError(message, fileName, line, column) {\n    var /** @type {?} */ result = new Error(message);\n    ((result)).fileName = fileName;\n    ((result)).line = line;\n    ((result)).column = column;\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResolvedStaticSymbol = (function () {\n    /**\n     * @param {?} symbol\n     * @param {?} metadata\n     */\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     * @param {?} summaryResolver\n     * @param {?=} errorRecorder\n     */\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return this._resolveSymbolMembers(staticSymbol);\n        }\n        var /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n        if (result) {\n            return result;\n        }\n        result = this._resolveSymbolFromSummary(staticSymbol);\n        if (result) {\n            return result;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        result = this.resolvedSymbols.get(staticSymbol);\n        return result;\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param {?} staticSymbol the symbol for which to generate a import symbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol) {\n        if (staticSymbol.members.length) {\n            var /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n        if (!result) {\n            result = this.importAs.get(staticSymbol);\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isNgFactoryFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param {?} fileName the file to invalidate\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        var /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {\n                var symbol = symbols_1[_i];\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var /** @type {?} */ members = staticSymbol.members;\n        var /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var /** @type {?} */ value = baseMetadata;\n            for (var /** @type {?} */ i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members a symbol for a static member of the named type\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        var /** @type {?} */ symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));\n        this._createSymbolsOf(filePath);\n        this.resolvedSymbols.forEach(function (resolvedSymbol) {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                symbols.add(resolvedSymbol.symbol);\n            }\n        });\n        return Array.from(symbols);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var _this = this;\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        var /** @type {?} */ resolvedSymbols = [];\n        var /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var /** @type {?} */ topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var /** @type {?} */ origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n                var /** @type {?} */ name = unescapeIdentifier(metadataKey);\n                var /** @type {?} */ symbol = _this.getStaticSymbol(filePath, name);\n                var /** @type {?} */ importSymbol = undefined;\n                if (metadata['importAs']) {\n                    // Index bundle indexes should use the importAs module name instead of a reference\n                    // to the .d.ts file directly.\n                    importSymbol = _this.getStaticSymbol(metadata['importAs'], name);\n                    _this.recordImportAs(symbol, importSymbol);\n                }\n                var /** @type {?} */ origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var /** @type {?} */ originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + filePath), null);\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var /** @type {?} */ symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var /** @type {?} */ symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var /** @type {?} */ resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var /** @type {?} */ targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    var /** @type {?} */ resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        var /** @type {?} */ nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var _i = 0, _a = metadata['exports']; _i < _a.length; _i++) {\n                var moduleExport = _a[_i];\n                _loop_1(/** @type {?} */ moduleExport);\n            }\n        }\n        resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(function (resolvedSymbol) { return resolvedSymbol.symbol; }));\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} topLevelPath\n     * @param {?} topLevelSymbolNames\n     * @param {?} metadata\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var /** @type {?} */ transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var /** @type {?} */ self = this;\n        var ReferenceTransformer = (function (_super) {\n            __extends(ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /**\n             * @param {?} map\n             * @param {?} functionParams\n             * @return {?}\n             */\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var /** @type {?} */ symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var /** @type {?} */ oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, (map['parameters'] || []));\n                    var /** @type {?} */ result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var /** @type {?} */ module_1 = map['module'];\n                    var /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name) {\n                        return null;\n                    }\n                    var /** @type {?} */ filePath = void 0;\n                    if (module_1) {\n                        filePath = self.resolveModule(module_1, sourceSymbol.filePath);\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module_1 + \" relative to \" + sourceSymbol.filePath + \".\"\n                            };\n                        }\n                        return self.getStaticSymbol(filePath, name);\n                    }\n                    else if (functionParams.indexOf(name) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name)) {\n                            return self.getStaticSymbol(topLevelPath, name);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        if (transformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, transformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param {?} module an absolute path to a module file.\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var /** @type {?} */ maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + module + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage), null);\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    /**\n     * @param {?} module\n     * @param {?} symbolName\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? \" relative to $ {\\n            containingFile\\n          } \" : '')), null);\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    /**\n     * @param {?} module\n     * @param {?} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, null, containingFile);\n        }\n    };\n    return StaticSymbolResolver;\n}());\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     */\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Set();\n        this.importAs = new Map();\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripNgFactory(filePath));\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getLibraryFileName = function (filePath) { return this.host.getOutputFileName(filePath); };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        var /** @type {?} */ summary = this.summaryCache.get(staticSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = this.summaryCache.get(staticSymbol);\n        }\n        return summary;\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        this._loadSummaryFile(filePath);\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return this.importAs.get(staticSymbol);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        if (this.loadedFilePaths.has(filePath)) {\n            return;\n        }\n        this.loadedFilePaths.add(filePath);\n        if (this.isLibraryFile(filePath)) {\n            var /** @type {?} */ summaryFilePath = summaryFileName(filePath);\n            var /** @type {?} */ json = void 0;\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n            if (json) {\n                var _a = deserializeSummaries(this.staticSymbolCache, json), summaries = _a.summaries, importAs = _a.importAs;\n                summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n                importAs.forEach(function (importAs) {\n                    _this.importAs.set(importAs.symbol, _this.staticSymbolCache.get(ngfactoryFilePath(filePath), importAs.importAs));\n                });\n            }\n        }\n    };\n    return AotSummaryResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a new AotCompiler based on options and a host.\n * @param {?} compilerHost\n * @param {?} options\n * @return {?}\n */\nfunction createAotCompiler(compilerHost, options) {\n    var /** @type {?} */ translations = options.translations || '';\n    var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n    var /** @type {?} */ symbolCache = new StaticSymbolCache();\n    var /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, symbolResolver);\n    StaticAndDynamicReflectionCapabilities.install(staticReflector);\n    var /** @type {?} */ console = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */]();\n    var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning, console);\n    var /** @type {?} */ config = new CompilerConfig({\n        defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate !== false,\n    });\n    var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var /** @type {?} */ expressionParser = new Parser(new Lexer());\n    var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n    var /** @type {?} */ tmplParser = new TemplateParser(config, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var /** @type {?} */ importResolver = {\n        getImportAs: function (symbol) { return symbolResolver.getImportAs(symbol); },\n        fileNameToModuleName: function (fileName, containingFilePath) { return compilerHost.fileNameToModuleName(fileName, containingFilePath); },\n        getTypeArity: function (symbol) { return symbolResolver.getTypeArity(symbol); }\n    };\n    var /** @type {?} */ viewCompiler = new ViewCompiler(config, elementSchemaRegistry);\n    var /** @type {?} */ compiler = new AotCompiler(config, compilerHost, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(), new TypeScriptEmitter(importResolver), summaryResolver, options.locale, options.i18nFormat, options.genFilePreamble, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction interpretStatements(statements, resultVars) {\n    var /** @type {?} */ stmtsWithReturn = statements.concat([new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })))]);\n    var /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());\n    var /** @type {?} */ visitor = new StatementInterpreter();\n    var /** @type {?} */ result = visitor.visitAllStatements(stmtsWithReturn, ctx);\n    return result != null ? result.value : null;\n}\n/**\n * @param {?} varNames\n * @param {?} varValues\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n    for (var /** @type {?} */ i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} instance\n     * @param {?} className\n     * @param {?} vars\n     */\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n    }\n    /**\n     * @return {?}\n     */\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = (function () {\n    /**\n     * @param {?} value\n     */\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\n/**\n * @param {?} _classStmt\n * @param {?} _ctx\n * @param {?} _visitor\n * @return {?}\n */\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var /** @type {?} */ propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var /** @type {?} */ paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[method.name] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var /** @type {?} */ ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = (function () {\n    function StatementInterpreter() {\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return ctx.instance.__proto__;\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ index = expr.index.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);\n        var /** @type {?} */ result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, args);\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, args);\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[expr.name].apply(receiver, args);\n        }\n        return result;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);\n        var /** @type {?} */ fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var /** @type {?} */ fn$$1 = stmt.fn.visitExpression(this, ctx);\n            return fn$$1.apply(null, args);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?=} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);\n        var /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, [void 0].concat(args)))();\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n        return ast.value.reference;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var /** @type {?} */ paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var /** @type {?} */ paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var /** @type {?} */ rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        ast.entries.forEach(function (entry) { return ((result))[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var /** @type {?} */ values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var /** @type {?} */ i = 0; i < statements.length; i++) {\n            var /** @type {?} */ stmt = statements[i];\n            var /** @type {?} */ val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\n/**\n * @param {?} varNames\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar AbstractJsEmitterVisitor = (function (_super) {\n    __extends(AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name + \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var /** @type {?} */ fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.currentClass.parent.visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} sourceUrl\n * @param {?} ctx\n * @param {?} vars\n * @return {?}\n */\nfunction evalExpression(sourceUrl$$1, ctx, vars) {\n    var /** @type {?} */ fnBody = ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl$$1;\n    var /** @type {?} */ fnArgNames = [];\n    var /** @type {?} */ fnArgValues = [];\n    for (var /** @type {?} */ argName in vars) {\n        fnArgNames.push(argName);\n        fnArgValues.push(vars[argName]);\n    }\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])()) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var /** @type {?} */ emptyFn = new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat('return null;'))))().toString();\n        var /** @type {?} */ headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl$$1, sourceUrl$$1, headerLines).toJsComment();\n    }\n    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\n}\n/**\n * @param {?} sourceUrl\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction jitStatements(sourceUrl$$1, statements, resultVars) {\n    var /** @type {?} */ converter = new JitEmitterVisitor();\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(resultVars);\n    var /** @type {?} */ returnStmt = new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })));\n    converter.visitAllStatements(statements.concat([returnStmt]), ctx);\n    return evalExpression(sourceUrl$$1, ctx, converter.getArgs());\n}\nvar JitEmitterVisitor = (function (_super) {\n    __extends(JitEmitterVisitor, _super);\n    function JitEmitterVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var /** @type {?} */ result = {};\n        for (var /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value.reference;\n        var /** @type {?} */ id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var /** @type {?} */ name = identifierName(ast.value) || 'val';\n            this._evalArgNames.push(\"jit_\" + name + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n        return null;\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * \\@security When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = (function () {\n    /**\n     * @param {?} _injector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _compilerConfig\n     * @param {?} _console\n     */\n    function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _compilerConfig, _console) {\n        this._injector = _injector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n    }\n    Object.defineProperty(JitCompiler.prototype, \"injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._compileModuleAndComponents(moduleType, true).syncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._compileModuleAndComponents(moduleType, false).asyncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._compileModuleAndAllComponents(moduleType, true).syncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._compileModuleAndAllComponents(moduleType, false).asyncResult;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    JitCompiler.prototype.getNgContentSelectors = function (component) {\n        this._console.warn('Compiler.getNgContentSelectors is deprecated. Use ComponentFactory.ngContentSelectors instead!');\n        var /** @type {?} */ template = this._compiledTemplateCache.get(component);\n        if (!template) {\n            throw new Error(\"The component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(component) + \" is not yet compiled!\");\n        }\n        return template.compMeta.template.ngContentSelectors;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            var /** @type {?} */ componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_61\" /* ModuleWithComponentFactories */](_this._compileModule(moduleType), componentFactories);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @param {?} mainModule\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromises = [];\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        // Note: the loadingPromise for a module only includes the loading of the exported directives\n        // of imported modules.\n        // However, for runtime compilation, we want to transitively compile all modules,\n        // so we also need to call loadNgModuleDirectiveAndPipeMetadata for all nested modules.\n        ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {\n            loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(localModuleMeta.reference, isSync));\n        });\n        return Promise.all(loadingPromises);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var _this = this;\n        var /** @type {?} */ ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n        if (!ngModuleFactory) {\n            var /** @type {?} */ moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);\n            // Always provide a bound Compiler\n            var /** @type {?} */ extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */], { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];\n            var /** @type {?} */ compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);\n            if (!this._compilerConfig.useJit) {\n                ngModuleFactory =\n                    interpretStatements(compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            else {\n                ngModuleFactory = jitStatements(ngModuleJitUrl(moduleMeta_1), compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * \\@internal\n     * @param {?} mainModule\n     * @param {?} allComponentFactories\n     * @return {?}\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        var /** @type {?} */ moduleByDirective = new Map();\n        var /** @type {?} */ templates = new Set();\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                moduleByDirective.set(dirIdentifier.reference, localModuleMeta);\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var /** @type {?} */ template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(/** @type {?} */ (dirMeta.componentFactory));\n                    }\n                }\n            });\n        });\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.componentType);\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.componentType);\n                templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCache = function () {\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    /**\n     * @param {?} compType\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var /** @type {?} */ componentFactory = (compMeta.componentFactory);\n            var /** @type {?} */ hostClass = this._metadataResolver.getHostComponentType(compType);\n            var /** @type {?} */ hostMeta = createHostComponentMeta(hostClass, compMeta, /** @type {?} */ (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_63\" /* ɵgetComponentViewDefinitionFactory */])(componentFactory)));\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} template\n     * @return {?}\n     */\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var /** @type {?} */ compMeta = template.compMeta;\n        var /** @type {?} */ externalStylesheetsByModuleUrl = new Map();\n        var /** @type {?} */ stylesCompileResult = this._styleCompiler.compileComponent(compMeta);\n        stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });\n        this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);\n        var /** @type {?} */ directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, template.ngModule.schemas, templateSourceUrl(template.ngModule.type, template.compMeta, template.compMeta.template)), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), usedPipes);\n        var /** @type {?} */ statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);\n        var /** @type {?} */ viewClassAndRendererTypeVars = compMeta.isHost ?\n            [compileResult.viewClassVar] :\n            [compileResult.viewClassVar, compileResult.rendererTypeVar];\n        var /** @type {?} */ viewClass;\n        var /** @type {?} */ rendererType;\n        if (!this._compilerConfig.useJit) {\n            _b = interpretStatements(statements, viewClassAndRendererTypeVars), viewClass = _b[0], rendererType = _b[1];\n        }\n        else {\n            _c = jitStatements(templateJitUrl(template.ngModule.type, template.compMeta), statements, viewClassAndRendererTypeVars), viewClass = _c[0], rendererType = _c[1];\n        }\n        template.compiled(viewClass, rendererType);\n        var _b, _c;\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var /** @type {?} */ nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n            var /** @type {?} */ nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.valuePlaceholder.reference = nestedStylesArr;\n        });\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(result.statements, [result.stylesVar])[0];\n        }\n        else {\n            return jitStatements(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.statements, [result.stylesVar])[0];\n        }\n    };\n    return JitCompiler;\n}());\nJitCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompiler.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_10\" /* Injector */], },\n    { type: CompileMetadataResolver, },\n    { type: TemplateParser, },\n    { type: StyleCompiler, },\n    { type: ViewCompiler, },\n    { type: NgModuleCompiler, },\n    { type: CompilerConfig, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n]; };\nvar CompiledTemplate = (function () {\n    /**\n     * @param {?} isHost\n     * @param {?} compType\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directives\n     */\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = null;\n        this.isCompiled = false;\n    }\n    /**\n     * @param {?} viewClass\n     * @param {?} rendererType\n     * @return {?}\n     */\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        ((this.compMeta.componentViewType)).setDelegate(viewClass);\n        for (var /** @type {?} */ prop in rendererType) {\n            ((this.compMeta.rendererType))[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * Implements `Compiler` by delegating to the JitCompiler using a known module.\n */\nvar ModuleBoundCompiler = (function () {\n    /**\n     * @param {?} _delegate\n     * @param {?} _ngModule\n     */\n    function ModuleBoundCompiler(_delegate, _ngModule) {\n        this._delegate = _delegate;\n        this._ngModule = _ngModule;\n    }\n    Object.defineProperty(ModuleBoundCompiler.prototype, \"_injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._delegate.injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._delegate.compileModuleSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._delegate.compileModuleAsync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsAsync(moduleType);\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.getNgContentSelectors = function (component) {\n        return this._delegate.getNgContentSelectors(component);\n    };\n    /**\n     * Clears all caches\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };\n    /**\n     * Clears the cache for the given component/ngModule.\n     * @param {?} type\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };\n    return ModuleBoundCompiler;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     * @param {?=} _locale\n     */\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    /**\n     * @param {?} html\n     * @param {?} url\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, i18nParserResult.messages);\n        var _a;\n    };\n    /**\n     * @return {?}\n     */\n    MessageBundle.prototype.getMessages = function () { return this._messages; };\n    /**\n     * @param {?} serializer\n     * @return {?}\n     */\n    MessageBundle.prototype.write = function (serializer) {\n        var /** @type {?} */ messages = {};\n        var /** @type {?} */ mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var /** @type {?} */ id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        var /** @type {?} */ msgList = Object.keys(messages).map(function (id) {\n            var /** @type {?} */ mapper = serializer.createNameMapper(messages[id]);\n            var /** @type {?} */ src = messages[id];\n            var /** @type {?} */ nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            return new Message(nodes, {}, {}, src.meaning, src.description, id);\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\nvar MapPlaceholderNames = (function (_super) {\n    __extends(MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var /** @type {?} */ startName = mapper.toPublicName(ph.startName);\n        var /** @type {?} */ closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extract i18n messages from source code\n */\nvar Extractor = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolResolver\n     * @param {?} messageBundle\n     * @param {?} metadataResolver\n     */\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ errors = [];\n            files.forEach(function (file) {\n                var /** @type {?} */ compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var /** @type {?} */ dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var /** @type {?} */ html = compMeta.template.template;\n                    var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                    errors.push.apply(errors, _this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} locale\n     * @return {?}\n     */\n    Extractor.create = function (host, locale) {\n        var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser());\n        var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n        var /** @type {?} */ symbolCache = new StaticSymbolCache();\n        var /** @type {?} */ summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var /** @type {?} */ staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        StaticAndDynamicReflectionCapabilities.install(staticReflector);\n        var /** @type {?} */ config = new CompilerConfig({ defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated, useJit: false });\n        var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n        var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */](), symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var /** @type {?} */ extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _NO_RESOURCE_LOADER = {\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    get: function (url) {\n        throw new Error(\"No ResourceLoader implementation has been provided. Can't read the url \\\"\" + url + \"\\\"\");\n    }\n};\nvar baseHtmlParser = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('HtmlParser');\n/**\n * A set of providers that provide `JitCompiler` and its dependencies to use for\n * template compilation.\n */\nvar COMPILER_PROVIDERS = [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_64\" /* ɵReflector */], useValue: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */] },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], useExisting: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_64\" /* ɵReflector */] },\n    { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },\n    SummaryResolver,\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */],\n    Lexer,\n    Parser,\n    {\n        provide: baseHtmlParser,\n        useClass: HtmlParser,\n    },\n    {\n        provide: I18NHtmlParser,\n        useFactory: function (parser, translations, format, config, console) { return new I18NHtmlParser(parser, translations, format, config.missingTranslation, console); },\n        deps: [\n            baseHtmlParser,\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_65\" /* TRANSLATIONS */])],\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_11\" /* TRANSLATIONS_FORMAT */])],\n            [CompilerConfig],\n            [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */]],\n        ]\n    },\n    {\n        provide: HtmlParser,\n        useExisting: I18NHtmlParser,\n    },\n    TemplateParser,\n    DirectiveNormalizer,\n    CompileMetadataResolver,\n    DEFAULT_PACKAGE_URL_PROVIDER,\n    StyleCompiler,\n    ViewCompiler,\n    NgModuleCompiler,\n    { provide: CompilerConfig, useValue: new CompilerConfig() },\n    JitCompiler,\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */], useExisting: JitCompiler },\n    DomElementSchemaRegistry,\n    { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },\n    UrlResolver,\n    DirectiveResolver,\n    PipeResolver,\n    NgModuleResolver,\n];\nvar JitCompilerFactory = (function () {\n    /**\n     * @param {?} defaultOptions\n     */\n    function JitCompilerFactory(defaultOptions) {\n        var compilerOptions = {\n            useDebug: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])(),\n            useJit: true,\n            defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated,\n            missingTranslation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning,\n            enableLegacyTemplate: true,\n        };\n        this._defaultOptions = [compilerOptions].concat(defaultOptions);\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    JitCompilerFactory.prototype.createCompiler = function (options) {\n        if (options === void 0) { options = []; }\n        var /** @type {?} */ opts = _mergeOptions(this._defaultOptions.concat(options));\n        var /** @type {?} */ injector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_66\" /* ReflectiveInjector */].resolveAndCreate([\n            COMPILER_PROVIDERS, {\n                provide: CompilerConfig,\n                useFactory: function () {\n                    return new CompilerConfig({\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        useJit: opts.useJit,\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        defaultEncapsulation: opts.defaultEncapsulation,\n                        missingTranslation: opts.missingTranslation,\n                        enableLegacyTemplate: opts.enableLegacyTemplate,\n                    });\n                },\n                deps: []\n            },\n            opts.providers\n        ]);\n        return injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */]);\n    };\n    return JitCompilerFactory;\n}());\nJitCompilerFactory.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompilerFactory.ctorParameters = function () { return [\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Y\" /* COMPILER_OPTIONS */],] },] },\n]; };\n/**\n * @return {?}\n */\nfunction _initReflector() {\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].reflectionCapabilities = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_48\" /* ɵReflectionCapabilities */]();\n}\n/**\n * A platform that included corePlatform and the compiler.\n *\n * \\@experimental\n */\nvar platformCoreDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"u\" /* createPlatformFactory */])(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"v\" /* platformCore */], 'coreDynamic', [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Y\" /* COMPILER_OPTIONS */], useValue: {}, multi: true },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_67\" /* CompilerFactory */], useClass: JitCompilerFactory },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"s\" /* PLATFORM_INITIALIZER */], useValue: _initReflector, multi: true },\n]);\n/**\n * @param {?} optionsArr\n * @return {?}\n */\nfunction _mergeOptions(optionsArr) {\n    return {\n        useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),\n        defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),\n        providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; })),\n        missingTranslation: _lastDefined(optionsArr.map(function (options) { return options.missingTranslation; })),\n    };\n}\n/**\n * @template T\n * @param {?} args\n * @return {?}\n */\nfunction _lastDefined(args) {\n    for (var /** @type {?} */ i = args.length - 1; i >= 0; i--) {\n        if (args[i] !== undefined) {\n            return args[i];\n        }\n    }\n    return undefined;\n}\n/**\n * @param {?} parts\n * @return {?}\n */\nfunction _mergeArrays(parts) {\n    var /** @type {?} */ result = [];\n    parts.forEach(function (part) { return part && result.push.apply(result, part); });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Interface that defines how import statements should be generated.\n * @abstract\n */\nvar ImportResolver = (function () {\n    function ImportResolver() {\n    }\n    /**\n     * Converts a file path to a module name that can be used as an `import.\n     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n     * @abstract\n     * @param {?} importedFilePath\n     * @param {?} containingFilePath\n     * @return {?}\n     */\n    ImportResolver.prototype.fileNameToModuleName = function (importedFilePath, containingFilePath) { };\n    /**\n     * Converts the given StaticSymbol into another StaticSymbol that should be used\n     * to generate the import from.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getImportAs = function (symbol) { };\n    /**\n     * Determine the arity of a type.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getTypeArity = function (symbol) { };\n    return ImportResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=compiler.js.map\n//# sourceMappingURL=compiler.es5.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9jb21waWxlci9AYW5ndWxhci9jb21waWxlci5lczUuanM/ZDBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4wLjNcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5pbXBvcnQgeyBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCBBdHRyaWJ1dGUsIENPTVBJTEVSX09QVElPTlMsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcGlsZXIsIENvbXBpbGVyRmFjdG9yeSwgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIElucHV0LCBMT0NBTEVfSUQsIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzLCBOT19FUlJPUlNfU0NIRU1BLCBOZ01vZHVsZSwgTmdNb2R1bGVGYWN0b3J5LCBOZ01vZHVsZVJlZiwgT3B0aW9uYWwsIE91dHB1dCwgUEFDS0FHRV9ST09UX1VSTCwgUExBVEZPUk1fSU5JVElBTElaRVIsIFBpcGUsIFF1ZXJ5LCBRdWVyeUxpc3QsIFJlZmxlY3RpdmVJbmplY3RvciwgUmVuZGVyZXIsIFNlY3VyaXR5Q29udGV4dCwgU2VsZiwgU2tpcFNlbGYsIFRSQU5TTEFUSU9OUywgVFJBTlNMQVRJT05TX0ZPUk1BVCwgVGVtcGxhdGVSZWYsIFR5cGUsIFZlcnNpb24sIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuLCBWaWV3Q29udGFpbmVyUmVmLCBWaWV3RW5jYXBzdWxhdGlvbiwgYW5pbWF0ZSwgY3JlYXRlUGxhdGZvcm1GYWN0b3J5LCBncm91cCwgaXNEZXZNb2RlLCBrZXlmcmFtZXMsIHBsYXRmb3JtQ29yZSwgcmVzb2x2ZUZvcndhcmRSZWYsIHNlcXVlbmNlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIsIMm1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgybVDb25zb2xlLCDJtUVNUFRZX0FSUkFZLCDJtUVNUFRZX01BUCwgybVFUlJPUl9DT01QT05FTlRfVFlQRSwgybVMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLCDJtUxpZmVjeWNsZUhvb2tzLCDJtU5nTW9kdWxlSW5qZWN0b3IsIMm1UmVmbGVjdGlvbkNhcGFiaWxpdGllcywgybVSZWZsZWN0b3IsIMm1UmVmbGVjdG9yUmVhZGVyLCDJtWFuZCwgybVjY2YsIMm1Y3J0LCDJtWRpZCwgybVlbGQsIMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUsIMm1Z2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5LCDJtWlubGluZUludGVycG9sYXRlLCDJtWludGVycG9sYXRlLCDJtW5jZCwgybVub3YsIMm1cGFkLCDJtXBpZCwgybVwb2QsIMm1cHBkLCDJtXByZCwgybVxdWQsIMm1cmVmbGVjdG9yLCDJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeSwgybVzdHJpbmdpZnksIMm1dGVkLCDJtXVudiwgybV2aWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIFZFUlNJT04gPSBuZXcgVmVyc2lvbignNC4wLjMnKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAqL1xudmFyIFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJvdW5kIGV4cHJlc3Npb24gd2l0aGluIHRoZSB0ZXh0IG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQXR0ckFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIChlLmcuXG4gKiBgW1xcQHRyaWdnZXJdPVwic3RhdGVFeHBcImApXG4gKi9cbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBzZWN1cml0eUNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB1bml0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZSwgXCJpc0FuaW1hdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IFByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgZXZlbnQgKGUuZy4gYChldmVudCk9XCJoYW5kbGVyKClcImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IChlLmcuXG4gKiBgKFxcQHRyaWdnZXIucGhhc2UpPVwiY2FsbGJhY2soJGV2ZW50KVwiYCkuXG4gKi9cbnZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgcGhhc2UsIGhhbmRsZXIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCB0YXJnZXQsIHBoYXNlKSB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgKyBcIjpcIiArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkBcIiArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImZ1bGxOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lKHRoaXMubmFtZSwgdGhpcy50YXJnZXQsIHRoaXMucGhhc2UpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLnBoYXNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICovXG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufSgpKTtcbi8qKlxuICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDxuZy10ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICovXG52YXIgVmFyaWFibGVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYXJpYWJsZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFyaWFibGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZUFzdDtcbn0oKSk7XG4vKipcbiAqIEFuIGVsZW1lbnQgZGVjbGFyYXRpb24gaW4gYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBoYXNWaWV3Q29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gZW5kU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBxdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5xdWVyeU1hdGNoZXMgPSBxdWVyeU1hdGNoZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gKi9cbnZhciBFbWJlZGRlZFRlbXBsYXRlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHs/fSB2YXJpYWJsZXNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gaGFzVmlld0NvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWJlZGRlZFRlbXBsYXRlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbWJlZGRlZFRlbXBsYXRlQXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgcHJvcGVydHkgd2l0aCBhIGJvdW5kIHZhbHVlIChlLmcuIGAqbmdJZj1cImNvbmRpdGlvblwiKS5cbiAqL1xudmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgZGVjbGFyZWQgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gaG9zdFByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFdmVudHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRRdWVyeVN0YXJ0SWRcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBjb250ZW50UXVlcnlTdGFydElkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAqL1xudmFyIFByb3ZpZGVyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGxpZmVjeWNsZUhvb2tzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmVhZ2VyID0gZWFnZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IGxpZmVjeWNsZUhvb2tzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIE5vIHZpc2l0IG1ldGhvZCBpbiB0aGUgdmlzaXRvciBmb3Igbm93Li4uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyQXN0O1xufSgpKTtcbnZhciBQcm92aWRlckFzdFR5cGUgPSB7fTtcblByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlID0gMDtcblByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSA9IDE7XG5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50ID0gMjtcblByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgPSAzO1xuUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4gPSA0O1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlXSA9IFwiUHVibGljU2VydmljZVwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG5Qcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudF0gPSBcIkNvbXBvbmVudFwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmVdID0gXCJEaXJlY3RpdmVcIjtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuQnVpbHRpbl0gPSBcIkJ1aWx0aW5cIjtcbi8qKlxuICogUG9zaXRpb24gd2hlcmUgY29udGVudCBpcyB0byBiZSBwcm9qZWN0ZWQgKGluc3RhbmNlIG9mIGA8bmctY29udGVudD5gIGluIGEgdGVtcGxhdGUpLlxuICovXG52YXIgTmdDb250ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdDb250ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nQ29udGVudEFzdDtcbn0oKSk7XG52YXIgUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9O1xuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eSA9IDA7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZSA9IDE7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzID0gMjtcblByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGUgPSAzO1xuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24gPSA0O1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5XSA9IFwiUHJvcGVydHlcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGVdID0gXCJBdHRyaWJ1dGVcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzc10gPSBcIkNsYXNzXCI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGUuU3R5bGVdID0gXCJTdHlsZVwiO1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbl0gPSBcIkFuaW1hdGlvblwiO1xuLyoqXG4gKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7XFxAbGluayBUZW1wbGF0ZUFzdH1zIHdpdGggdGhlIGdpdmVuIHtcXEBsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn0uXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gYXN0c1xuICogQHBhcmFtIHs/PX0gY29udGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCBhc3RzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBhIHJlZmVyZW5jZSB0byBhIHN0YXRpYyB0eXBlLlxuICpcbiAqIFRoaXMgdG9rZW4gaXMgdW5pcXVlIGZvciBhIGZpbGVQYXRoIGFuZCBuYW1lIGFuZCBjYW4gYmUgdXNlZCBhcyBhIGhhc2ggdGFibGUga2V5LlxuICovXG52YXIgU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZW1iZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2wucHJvdG90eXBlLmFzc2VydE5vTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IHN5bWJvbCB3aXRob3V0IG1lbWJlcnMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbDtcbn0oKSk7XG4vKipcbiAqIEEgY2FjaGUgb2Ygc3RhdGljIHN5bWJvbCB1c2VkIGJ5IHRoZSBTdGF0aWNSZWZsZWN0b3IgdG8gcmV0dXJuIHRoZSBzYW1lIHN5bWJvbCBmb3IgdGhlXG4gKiBzYW1lIHN5bWJvbCB2YWx1ZXMuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2xDYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgbWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlclN1ZmZpeCA9IG1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBtZW1iZXJzLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBcIlxcXCJcIiArIGRlY2xhcmF0aW9uRmlsZSArIFwiXFxcIi5cIiArIG5hbWUgKyBtZW1iZXJTdWZmaXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgU3RhdGljU3ltYm9sKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2xDYWNoZTtcbn0oKSk7XG52YXIgVGFnQ29udGVudFR5cGUgPSB7fTtcblRhZ0NvbnRlbnRUeXBlLlJBV19URVhUID0gMDtcblRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDE7XG5UYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBID0gMjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLlJBV19URVhUXSA9IFwiUkFXX1RFWFRcIjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQV0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvbkluZGV4ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicsIDEpO1xuICAgIGlmIChjb2xvbkluZGV4ID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCBcXFwiXCIgKyBlbGVtZW50TmFtZSArIFwiXFxcIiBleHBlY3RpbmcgXFxcIjpuYW1lc3BhY2U6bmFtZVxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcmVmaXhcbiAqIEBwYXJhbSB7P30gbG9jYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggPyBcIjpcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xufVxuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlc1xuLy8gc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb25cbi8vIFRoaXMgbGlzdCBpcyBub3QgZXhoYXVzdGl2ZSB0byBrZWVwIHRoZSBjb21waWxlciBmb290cHJpbnQgbG93LlxuLy8gVGhlIGAmIzEyMztgIC8gYCYjeDFhYjtgIHN5bnRheCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LlxudmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICdhbXAnOiAnJicsXG4gICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgJ2d0JzogJz4nLFxuICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICd6d25qJzogJ1xcdTIwMEMnLFxufTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBIdG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHRtbFRhZ0RlZmluaXRpb24oX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCByZXF1aXJlZFBhcmVudHMgPSBfYi5yZXF1aXJlZFBhcmVudHMsIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gX2IuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIF9jID0gX2IuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlID0gX2MgPT09IHZvaWQgMCA/IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgOiBfYywgX2QgPSBfYi5jbG9zZWRCeVBhcmVudCwgY2xvc2VkQnlQYXJlbnQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5pc1ZvaWQsIGlzVm9pZCA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9iLmlnbm9yZUZpcnN0TGYsIGlnbm9yZUZpcnN0TGYgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbG9zZWRCeUNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNsb3NlZEJ5Q2hpbGRyZW4gJiYgY2xvc2VkQnlDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLmNsb3NlZEJ5Q2hpbGRyZW5bdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGNsb3NlZEJ5UGFyZW50IHx8IGlzVm9pZDtcbiAgICAgICAgaWYgKHJlcXVpcmVkUGFyZW50cyAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmVudHMgPSB7fTtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJlbnQgaXMgdGhlIGxpc3QgaXMgYXV0b21hdGljYWxseSB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlZCBwYXJlbnRzIGFyZSBwcmVzZW50XG4gICAgICAgICAgICB0aGlzLnBhcmVudFRvQWRkID0gcmVxdWlyZWRQYXJlbnRzWzBdO1xuICAgICAgICAgICAgcmVxdWlyZWRQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLnJlcXVpcmVkUGFyZW50c1t0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRQYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWlyZWRQYXJlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNQYXJlbnRUZW1wbGF0ZSA9IGxjUGFyZW50ID09PSAndGVtcGxhdGUnIHx8IGN1cnJlbnRQYXJlbnQgPT09ICduZy10ZW1wbGF0ZSc7XG4gICAgICAgIHJldHVybiAhaXNQYXJlbnRUZW1wbGF0ZSAmJiB0aGlzLnJlcXVpcmVkUGFyZW50c1tsY1BhcmVudF0gIT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVm9pZCB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5jbG9zZWRCeUNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWxUYWdEZWZpbml0aW9uO1xufSgpKTtcbi8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmdWxseSBjb25mb3JtIHRvIHRoZSBIVE1MNSBzcGVjLlxudmFyIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnbWV0YSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2xpbmsnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3BhcmFtJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3NvdXJjZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAncCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLFxuICAgICAgICAgICAgJ21haW4nLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgIF0sXG4gICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgfSksXG4gICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgIHJlcXVpcmVkUGFyZW50czogWyd0Ym9keScsICd0Zm9vdCcsICd0aGVhZCddLFxuICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgIH0pLFxuICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgcmVxdWlyZWRQYXJlbnRzOiBbJ2NvbGdyb3VwJ10sIGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICdzY3JpcHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxufTtcbnZhciBfREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRhZ05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gVEFHX0RFRklOSVRJT05TW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAnKFstXFxcXHddKyl8JyArXG4gICAgJyg/OlxcXFwuKFstXFxcXHddKykpfCcgK1xuICAgIC8vIFwiLVwiIHNob3VsZCBhcHBlYXIgZmlyc3QgaW4gdGhlIHJlZ2V4cCBiZWxvdyBhcyBGRjMxIHBhcnNlcyBcIlsuLVxcd11cIiBhcyBhIHJhbmdlXG4gICAgJyg/OlxcXFxbKFstLlxcXFx3Kl0rKSg/Oj0oW1xcXCJcXCddPykoW15cXFxcXVxcXCJcXCddKilcXFxcNSk/XFxcXF0pfCcgK1xuICAgIC8vIFwiW25hbWU9XCJ2YWx1ZVwiXVwiLFxuICAgIC8vIFwiW25hbWU9J3ZhbHVlJ11cIlxuICAgICcoXFxcXCkpfCcgK1xuICAgICcoXFxcXHMqLFxcXFxzKiknLCAvLyBcIixcIlxuJ2cnKTtcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xudmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XG4gICAgICAgICAgICBpZiAoY3NzU2VsLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICFjc3NTZWwuZWxlbWVudCAmJiBjc3NTZWwuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2g7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgX1NFTEVDVE9SX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbN10pIHtcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmlzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaGFzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmVsZW1lbnQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSB0aGlzLmVsZW1lbnQgfHwgJ2Rpdic7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9ICcnOyB9XG4gICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLCB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpIHx8ICcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IHRoaXMuZWxlbWVudCB8fCAnJztcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiByZXMgKz0gXCIuXCIgKyBrbGFzczsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lICsgKHZhbHVlID8gJz0nICsgdmFsdWUgOiAnJykgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub3RTZWxlY3RvcikgeyByZXR1cm4gcmVzICs9IFwiOm5vdChcIiArIG5vdFNlbGVjdG9yICsgXCIpXCI7IH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1NlbGVjdG9yO1xufSgpKTtcbi8qKlxuICogUmVhZHMgYSBsaXN0IG9mIENzc1NlbGVjdG9ycyBhbmQgYWxsb3dzIHRvIGNhbGN1bGF0ZSB3aGljaCBvbmVzXG4gKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXG4gKi9cbnZhciBTZWxlY3Rvck1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm90U2VsZWN0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgbm90TWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhub3RTZWxlY3RvcnMsIG51bGwpO1xuICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JzXG4gICAgICogQHBhcmFtIHs/PX0gY2FsbGJhY2tDdHh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsaXN0Q29udGV4dCA9IG5ldyBTZWxlY3Rvckxpc3RDb250ZXh0KGNzc1NlbGVjdG9ycyk7XG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBsaXN0Q29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVGVybWluYWwgPSBpID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZU1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxWYWx1ZXNNYXAgPSB0ZXJtaW5hbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxNYXAuc2V0KG5hbWUsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydGlhbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZVBhcnRpYWxNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gez99IGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5fbGlzdENvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHNbaV0uYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2VsZW1lbnRNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbFZhbHVlc01hcCA9IHRoaXMuX2F0dHJWYWx1ZU1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0YWJsZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBtYXRjaGVkQ2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkU2VsZWN0b3IgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5lc3RlZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZ2V0IHJpZCBvZiByZWN1cnNpb24gYW5kIG1lYXN1cmUgYWdhaW5cbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZG9uJ3QgcGFzcyB0aGUgd2hvbGUgc2VsZWN0b3IgaW50byB0aGUgcmVjdXJzaW9uLFxuICAgICAgICAvLyBidXQgb25seSB0aGUgbm90IHByb2Nlc3NlZCBwYXJ0c1xuICAgICAgICByZXR1cm4gbmVzdGVkU2VsZWN0b3IubWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JNYXRjaGVyO1xufSgpKTtcbnZhciBTZWxlY3Rvckxpc3RDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTGlzdENvbnRleHQoc2VsZWN0b3JzKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICB0aGlzLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3Rvckxpc3RDb250ZXh0O1xufSgpKTtcbnZhciBTZWxlY3RvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGNiQ29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gbGlzdENvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3RvckNvbnRleHQoc2VsZWN0b3IsIGNiQ29udGV4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcbiAgICAgICAgdGhpcy5saXN0Q29udGV4dCA9IGxpc3RDb250ZXh0O1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vdE1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlcih0aGlzLm5vdFNlbGVjdG9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSAhbm90TWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAmJiBjYWxsYmFjayAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5zZWxlY3RvciwgdGhpcy5jYkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBNT0RVTEVfU1VGRklYID0gJyc7XG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKyhbYS16MC05XSkvZztcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRBdENvbG9uKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnOicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gY2hhcmFjdGVyXG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9zcGxpdEF0KGlucHV0LCBjaGFyYWN0ZXIsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyYWN0ZXJJbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcmFjdGVyKTtcbiAgICBpZiAoY2hhcmFjdGVySW5kZXggPT0gLTEpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xuICAgIHJldHVybiBbaW5wdXQuc2xpY2UoMCwgY2hhcmFjdGVySW5kZXgpLnRyaW0oKSwgaW5wdXQuc2xpY2UoY2hhcmFjdGVySW5kZXggKyAxKS50cmltKCldO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gY29udGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmlzaXRWYWx1ZSh2YWx1ZSwgdmlzaXRvciwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmljdFN0cmluZ01hcCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPdGhlcih2YWx1ZSwgY29udGV4dCk7XG59XG52YXIgVmFsdWVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJlc3VsdFtrZXldID0gdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICByZXR1cm4gVmFsdWVUcmFuc2Zvcm1lcjtcbn0oKSk7XG52YXIgU3luY0FzeW5jUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bmNSZXN1bHRcbiAgICAgKiBAcGFyYW0gez89fSBhc3luY1Jlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCkge1xuICAgICAgICBpZiAoYXN5bmNSZXN1bHQgPT09IHZvaWQgMCkgeyBhc3luY1Jlc3VsdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5zeW5jUmVzdWx0ID0gc3luY1Jlc3VsdDtcbiAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IGFzeW5jUmVzdWx0O1xuICAgICAgICBpZiAoIWFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHN5bmNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTeW5jQXN5bmNSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1zZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ludGF4RXJyb3IobXNnKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3IgPSBFcnJvcihtc2cpO1xuICAgICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xuLyoqXG4gKiBAcGFyYW0gez99IGVycm9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N5bnRheEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufVxudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gU1RSSU5HX01BUF9QUk9UTztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5jb2RlZCA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29kZVBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBkZWNvZGUgc3Vycm9nYXRlXG4gICAgICAgIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGJmZiAmJiBzdHIubGVuZ3RoID4gKGluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGdyb3VwIDA6IFwiW3Byb3BdIG9yIChldmVudCkgb3IgQHRyaWdnZXJcIlxuLy8gZ3JvdXAgMTogXCJwcm9wXCIgZnJvbSBcIltwcm9wXVwiXG4vLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxuLy8gZ3JvdXAgMzogXCJAdHJpZ2dlclwiIGZyb20gXCJAdHJpZ2dlclwiXG52YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO1xudmFyIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gZGVmaW5pdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBudWxsOyB9XG4gICAgICAgIGlmIChkZWZpbml0aW9ucyA9PT0gdm9pZCAwKSB7IGRlZmluaXRpb25zID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lRXhwclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVOYW1lRXhwciA9IHN0YXRlTmFtZUV4cHI7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICBfdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHRpbWluZ3MgPT09IHZvaWQgMCkgeyB0aW1pbmdzID0gMDsgfVxuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG52YXIgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcGlsZUlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgaWYgKCFjb21waWxlSWRlbnRpZmllciB8fCAhY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLm5hbWU7XG4gICAgfVxuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gybVzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gXCJhbm9ueW1vdXNfXCIgKyBfYW5vbnltb3VzVHlwZUluZGV4Kys7XG4gICAgICAgIHJlZlsnX19hbm9ueW1vdXNUeXBlJ10gPSBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWRlbnRpZmllciA9IF9zYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBpbGVJZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIMm1cmVmbGVjdG9yLmltcG9ydFVyaShyZWYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcGFyYW0gez99IGVtYmVkZGVkVGVtcGxhdGVJbmRleFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmlld0NsYXNzTmFtZShjb21wVHlwZSwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgcmV0dXJuIFwiVmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiX1wiICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW5kZXJlclR5cGVOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIFwiUmVuZGVyVHlwZV9cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaG9zdFZpZXdDbGFzc05hbWUoY29tcFR5cGUpIHtcbiAgICByZXR1cm4gXCJIb3N0Vmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaXJXcmFwcGVyQ2xhc3NOYW1lKGRpclR5cGUpIHtcbiAgICByZXR1cm4gXCJXcmFwcGVyX1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGRpclR5cGUgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiTmdGYWN0b3J5XCI7XG59XG52YXIgQ29tcGlsZVN1bW1hcnlLaW5kID0ge307XG5Db21waWxlU3VtbWFyeUtpbmQuUGlwZSA9IDA7XG5Db21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlID0gMTtcbkNvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSA9IDI7XG5Db21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSA9IDM7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGVdID0gXCJQaXBlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZV0gPSBcIkRpcmVjdGl2ZVwiO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZV0gPSBcIk5nTW9kdWxlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGVdID0gXCJJbmplY3RhYmxlXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRva2VuTmFtZSh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZSAhPSBudWxsID8gX3Nhbml0aXplSWRlbnRpZmllcih0b2tlbi52YWx1ZSkgOiBpZGVudGlmaWVyTmFtZSh0b2tlbi5pZGVudGlmaWVyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0b2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5SZWZlcmVuY2UodG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaWRlbnRpZmllciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5pZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICovXG52YXIgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9iLmV4dGVybmFsU3R5bGVzaGVldHMsIGFuaW1hdGlvbnMgPSBfYi5hbmltYXRpb25zLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYi5uZ0NvbnRlbnRTZWxlY3RvcnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uLCBpc0lubGluZSA9IF9iLmlzSW5saW5lO1xuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gX25vcm1hbGl6ZUFycmF5KGV4dGVybmFsU3R5bGVzaGVldHMpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zID8gZmxhdHRlbihhbmltYXRpb25zKSA6IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IG5nQ29udGVudFNlbGVjdG9ycyB8fCBbXTtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24gJiYgaW50ZXJwb2xhdGlvbi5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2ludGVycG9sYXRpb24nIHNob3VsZCBoYXZlIGEgc3RhcnQgYW5kIGFuIGVuZCBzeW1ib2wuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuaXNJbmxpbmUgPSBpc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uczogdGhpcy5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS5uYW1lOyB9KSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0aGlzLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG59KCkpO1xuLyoqXG4gKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSBkaXJlY3RpdmUuXG4gKi9cbnZhciBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNIb3N0ID0gX2IuaXNIb3N0LCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2IuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYi5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYi5ob3N0QXR0cmlidXRlcywgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYi5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2IucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2IuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdQcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkodmlld1F1ZXJpZXMpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Vmlld1R5cGUgPSBjb21wb25lbnRWaWV3VHlwZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGUgPSByZW5kZXJlclR5cGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNIb3N0ID0gX2IuaXNIb3N0LCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0ID0gX2IuaG9zdCwgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYi5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2IucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2IuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdExpc3RlbmVycyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAoaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGhvc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnNbbWF0Y2hlc1syXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICBpZiAob3V0cHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogISFpc0NvbXBvbmVudCwgc2VsZWN0b3I6IHNlbGVjdG9yLCBleHBvcnRBczogZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBjb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogcmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogdGhpcy5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IHRoaXMuZXhwb3J0QXMsXG4gICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogdGhpcy5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IHRoaXMuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB0aGlzLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdGhpcy52aWV3UXVlcmllcyxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IHRoaXMuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMudGVtcGxhdGUgJiYgdGhpcy50ZW1wbGF0ZS50b1N1bW1hcnkoKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiB0aGlzLmNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiB0aGlzLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IHRoaXMuY29tcG9uZW50RmFjdG9yeVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIENvbnN0cnVjdCB7XFxAbGluayBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGF9IGZyb20ge1xcQGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7P30gaG9zdFR5cGVSZWZlcmVuY2VcbiAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAqIEBwYXJhbSB7P30gaG9zdFZpZXdUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShob3N0VHlwZVJlZmVyZW5jZSwgY29tcE1ldGEsIGhvc3RWaWV3VHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gQ3NzU2VsZWN0b3IucGFyc2UoY29tcE1ldGEuc2VsZWN0b3IpWzBdLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICBpc0hvc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IHsgcmVmZXJlbmNlOiBob3N0VHlwZVJlZmVyZW5jZSwgZGlEZXBzOiBbXSwgbGlmZWN5Y2xlSG9va3M6IFtdIH0sXG4gICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnJyxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBob3N0OiB7fSxcbiAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIHNlbGVjdG9yOiAnKicsXG4gICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICBxdWVyaWVzOiBbXSxcbiAgICAgICAgdmlld1F1ZXJpZXM6IFtdLFxuICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogaG9zdFZpZXdUeXBlLFxuICAgICAgICByZW5kZXJlclR5cGU6IHsgaWQ6ICdfX0hvc3RfXycsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsIHN0eWxlczogW10sIGRhdGE6IHt9IH1cbiAgICB9KTtcbn1cbnZhciBDb21waWxlUGlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlUGlwZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1cmUgPSAhIXB1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcHVyZTogdGhpcy5wdXJlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVBpcGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIG1vZHVsZS5cbiAqL1xudmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgZGVjbGFyZWREaXJlY3RpdmVzID0gX2IuZGVjbGFyZWREaXJlY3RpdmVzLCBleHBvcnRlZERpcmVjdGl2ZXMgPSBfYi5leHBvcnRlZERpcmVjdGl2ZXMsIGRlY2xhcmVkUGlwZXMgPSBfYi5kZWNsYXJlZFBpcGVzLCBleHBvcnRlZFBpcGVzID0gX2IuZXhwb3J0ZWRQaXBlcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzID0gX2IuYm9vdHN0cmFwQ29tcG9uZW50cywgaW1wb3J0ZWRNb2R1bGVzID0gX2IuaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMgPSBfYi5leHBvcnRlZE1vZHVsZXMsIHNjaGVtYXMgPSBfYi5zY2hlbWFzLCB0cmFuc2l0aXZlTW9kdWxlID0gX2IudHJhbnNpdGl2ZU1vZHVsZSwgaWQgPSBfYi5pZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRQaXBlcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy5pbXBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoaW1wb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gX25vcm1hbGl6ZUFycmF5KHNjaGVtYXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMsXG4gICAgICAgICAgICBtb2R1bGVzOiB0aGlzLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogdGhpcy50cmFuc2l0aXZlTW9kdWxlLmV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5leHBvcnRlZFBpcGVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG59KCkpO1xudmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5waXBlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaCh7IHByb3ZpZGVyOiBwcm92aWRlciwgbW9kdWxlOiBtb2R1bGUgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aXZlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMucGlwZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGlwZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhwb3J0ZWRQaXBlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kdWxlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVjXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEVudHJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGVjKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKGVjLmNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoZWMuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKGVjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiB8fCBbXTtcbn1cbnZhciBQcm92aWRlck1ldGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IF9fMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyTWV0YSh0b2tlbiwgX2EpIHtcbiAgICAgICAgdmFyIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHM7XG4gICAgICAgIHRoaXMubXVsdGkgPSAhIW11bHRpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJNZXRhO1xufSgpKTtcbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gbGlzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICByZXR1cm4gKChmbGF0KSkuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzb3VyY2VVcmwodXJsKSB7XG4gICAgLy8gTm90ZTogV2UgbmVlZCAzIFwiL1wiIHNvIHRoYXQgbmcgc2hvd3MgdXAgYXMgYSBzZXBhcmF0ZSBkb21haW5cbiAgICAvLyBpbiB0aGUgY2hyb21lIGRldiB0b29scy5cbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXHcrOlxcL1xcL1tcXHc6LV0rKT8oXFwvKyk/LywgJ25nOi8vLycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHBhcmFtIHs/fSB0ZW1wbGF0ZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlU291cmNlVXJsKG5nTW9kdWxlVHlwZSwgY29tcE1ldGEsIHRlbXBsYXRlTWV0YSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybDtcbiAgICBpZiAodGVtcGxhdGVNZXRhLmlzSW5saW5lKSB7XG4gICAgICAgIGlmIChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgLy8gTm90ZTogYSAudHMgZmlsZSBtaWdodCBjb250YWluIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCBpbmxpbmUgdGVtcGxhdGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnaXZlIHRoZW0gdW5pcXVlIHVybHMsIGFzIHRoZXNlIHdpbGwgYmUgdXNlZCBmb3Igc291cmNlbWFwcy5cbiAgICAgICAgICAgIHVybCA9IGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoICsgXCIuXCIgKyBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5uYW1lICsgXCIuaHRtbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5odG1sXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybDtcbiAgICB9XG4gICAgLy8gYWx3YXlzIHByZXBlbmQgbmc6Ly8gdG8gbWFrZSBhbmd1bGFyIHJlc291cmNlcyBlYXN5IHRvIGZpbmQgYW5kIG5vdCBjbG9iYmVyXG4gICAgLy8gdXNlciByZXNvdXJjZXMuXG4gICAgcmV0dXJuIHNvdXJjZVVybCh1cmwpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwobWV0YSwgaWQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoUGFydHMgPSBtZXRhLm1vZHVsZVVybC5zcGxpdCgvXFwvXFxcXC9nKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNvdXJjZVVybChcImNzcy9cIiArIGlkICsgYmFzZU5hbWUgKyBcIi5uZ3N0eWxlLmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZHVsZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5nTW9kdWxlSml0VXJsKG1vZHVsZU1ldGEpIHtcbiAgICByZXR1cm4gc291cmNlVXJsKGlkZW50aWZpZXJOYW1lKG1vZHVsZU1ldGEudHlwZSkgKyBcIi9tb2R1bGUubmdmYWN0b3J5LmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVKaXRVcmwobmdNb2R1bGVUeXBlLCBjb21wTWV0YSkge1xuICAgIHJldHVybiBzb3VyY2VVcmwoaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5uZ2ZhY3RvcnkuanNcIik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ29tcGlsZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyQ29uZmlnKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmRlZmF1bHRFbmNhcHN1bGF0aW9uLCBkZWZhdWx0RW5jYXBzdWxhdGlvbiA9IF9jID09PSB2b2lkIDAgPyBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA6IF9jLCBfZCA9IF9iLnVzZUppdCwgdXNlSml0ID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgbWlzc2luZ1RyYW5zbGF0aW9uID0gX2IubWlzc2luZ1RyYW5zbGF0aW9uLCBlbmFibGVMZWdhY3lUZW1wbGF0ZSA9IF9iLmVuYWJsZUxlZ2FjeVRlbXBsYXRlO1xuICAgICAgICB0aGlzLmRlZmF1bHRFbmNhcHN1bGF0aW9uID0gZGVmYXVsdEVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMudXNlSml0ID0gdXNlSml0O1xuICAgICAgICB0aGlzLm1pc3NpbmdUcmFuc2xhdGlvbiA9IG1pc3NpbmdUcmFuc2xhdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVMZWdhY3lUZW1wbGF0ZSA9IGVuYWJsZUxlZ2FjeVRlbXBsYXRlICE9PSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVyQ29uZmlnO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQYXJzZXJFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZXJyTG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjdHhMb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVyckxvY2F0aW9uID0gZXJyTG9jYXRpb247XG4gICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG59KCkpO1xudmFyIFBhcnNlU3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU3Bhbjtcbn0oKSk7XG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBU1QnOyB9O1xuICAgIHJldHVybiBBU1Q7XG59KCkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcXVvdGVkIGV4cHJlc3Npb24gb2YgdGhlIGZvcm06XG4gKlxuICogcXVvdGUgPSBwcmVmaXggYDpgIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gKiBwcmVmaXggPSBpZGVudGlmaWVyXG4gKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAqXG4gKiBBIHF1b3RlZCBleHByZXNzaW9uIGlzIG1lYW50IHRvIGJlIHByZS1wcm9jZXNzZWQgYnkgYW4gQVNUIHRyYW5zZm9ybWVyIHRoYXRcbiAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICogSXQgaXMgbWVhbnQgdG8gYWxsb3cgdGhpcmQtcGFydHkgZGV2ZWxvcGVycyB0byBleHRlbmQgQW5ndWxhciB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbiBsYW5ndWFnZS4gVGhlIGB1bmludGVycHJldGVkRXhwcmVzc2lvbmAgcGFydCBvZiB0aGUgcXVvdGUgaXNcbiAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gKi9cbnZhciBRdW90ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1b3RlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIF90aGlzLnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gdW5pbnRlcnByZXRlZEV4cHJlc3Npb247XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUXVvdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUXVvdGUnOyB9O1xuICAgIHJldHVybiBRdW90ZTtcbn0oQVNUKSk7XG52YXIgRW1wdHlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5RXhwcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXB0eUV4cHIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlFeHByO1xufShBU1QpKTtcbnZhciBJbXBsaWNpdFJlY2VpdmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbn0oQVNUKSk7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoYWluKHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENoYWluO1xufShBU1QpKTtcbnZhciBDb25kaXRpb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlRXhwXG4gICAgICogQHBhcmFtIHs/fSBmYWxzZUV4cFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKHNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy50cnVlRXhwID0gdHJ1ZUV4cDtcbiAgICAgICAgX3RoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25kaXRpb25hbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG59KEFTVCkpO1xudmFyIFByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5V3JpdGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVdyaXRlKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm9wZXJ0eVdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG59KEFTVCkpO1xudmFyIFNhZmVQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgS2V5ZWRSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbnZhciBLZXllZFdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUoc3Bhbiwgb2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9iaiA9IG9iajtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEtleWVkV3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbn0oQVNUKSk7XG52YXIgQmluZGluZ1BpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKHNwYW4sIGV4cCwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHAgPSBleHA7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbn0oQVNUKSk7XG52YXIgTGl0ZXJhbFByaW1pdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsUHJpbWl0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxBcnJheSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xufShBU1QpKTtcbnZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGtleXNcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwO1xufShBU1QpKTtcbnZhciBJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KEFTVCkpO1xudmFyIEJpbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gbGVmdFxuICAgICAqIEBwYXJhbSB7P30gcmlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5hcnkoc3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICBfdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeTtcbn0oQVNUKSk7XG52YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZml4Tm90LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZpeE5vdDtcbn0oQVNUKSk7XG52YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgU2FmZU1ldGhvZENhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbn0oQVNUKSk7XG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3IFBhcnNlU3BhbigwLCBzb3VyY2UgPT0gbnVsbCA/IDAgOiBzb3VyY2UubGVuZ3RoKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXN0ID0gYXN0O1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc291cmNlICsgXCIgaW4gXCIgKyB0aGlzLmxvY2F0aW9uOyB9O1xuICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xufShBU1QpKTtcbnZhciBUZW1wbGF0ZUJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSBrZXlJc1ZhclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhzcGFuLCBrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC50YXJnZXQudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMsIGNvbnRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG59KCkpO1xudmFyIEFzdFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihhc3Quc3BhbiwgYXN0LnN0cmluZ3MsIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGFzdC5zcGFuLCBhc3QudmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kQ2FsbChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnRhcmdldC52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkoYXN0LnNwYW4sIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKGFzdC5zcGFuLCBhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdChhc3Quc3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdQaXBlKGFzdC5zcGFuLCBhc3QuZXhwLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5vYmoudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Quc3BhbiwgYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gbmV3IEFycmF5KGFzdHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbihhc3Quc3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShhc3Quc3BhbiwgYXN0LnByZWZpeCwgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciAkRU9GID0gMDtcbnZhciAkVEFCID0gOTtcbnZhciAkTEYgPSAxMDtcbnZhciAkVlRBQiA9IDExO1xudmFyICRGRiA9IDEyO1xudmFyICRDUiA9IDEzO1xudmFyICRTUEFDRSA9IDMyO1xudmFyICRCQU5HID0gMzM7XG52YXIgJERRID0gMzQ7XG52YXIgJEhBU0ggPSAzNTtcbnZhciAkJCA9IDM2O1xudmFyICRQRVJDRU5UID0gMzc7XG52YXIgJEFNUEVSU0FORCA9IDM4O1xudmFyICRTUSA9IDM5O1xudmFyICRMUEFSRU4gPSA0MDtcbnZhciAkUlBBUkVOID0gNDE7XG52YXIgJFNUQVIgPSA0MjtcbnZhciAkUExVUyA9IDQzO1xudmFyICRDT01NQSA9IDQ0O1xudmFyICRNSU5VUyA9IDQ1O1xudmFyICRQRVJJT0QgPSA0NjtcbnZhciAkU0xBU0ggPSA0NztcbnZhciAkQ09MT04gPSA1ODtcbnZhciAkU0VNSUNPTE9OID0gNTk7XG52YXIgJExUID0gNjA7XG52YXIgJEVRID0gNjE7XG52YXIgJEdUID0gNjI7XG52YXIgJFFVRVNUSU9OID0gNjM7XG52YXIgJDAgPSA0ODtcbnZhciAkOSA9IDU3O1xudmFyICRBID0gNjU7XG52YXIgJEUgPSA2OTtcbnZhciAkRiA9IDcwO1xudmFyICRYID0gODg7XG52YXIgJFogPSA5MDtcbnZhciAkTEJSQUNLRVQgPSA5MTtcbnZhciAkQkFDS1NMQVNIID0gOTI7XG52YXIgJFJCUkFDS0VUID0gOTM7XG52YXIgJENBUkVUID0gOTQ7XG52YXIgJF8gPSA5NTtcbnZhciAkYSA9IDk3O1xudmFyICRlID0gMTAxO1xudmFyICRmID0gMTAyO1xudmFyICRuID0gMTEwO1xudmFyICRyID0gMTE0O1xudmFyICR0ID0gMTE2O1xudmFyICR1ID0gMTE3O1xudmFyICR2ID0gMTE4O1xudmFyICR4ID0gMTIwO1xudmFyICR6ID0gMTIyO1xudmFyICRMQlJBQ0UgPSAxMjM7XG52YXIgJEJBUiA9IDEyNDtcbnZhciAkUkJSQUNFID0gMTI1O1xudmFyICROQlNQID0gMTYwO1xudmFyICRCVCA9IDk2O1xuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlID49ICRUQUIgJiYgY29kZSA8PSAkU1BBQ0UpIHx8IChjb2RlID09ICROQlNQKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQXNjaWlIZXhEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkZiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJEYgfHwgaXNEaWdpdChjb2RlKTtcbn1cbi8qKlxuICogQSByZXBsYWNlbWVudCBmb3IgXFxASW5qZWN0YWJsZSB0byBiZSB1c2VkIGluIHRoZSBjb21waWxlciwgc28gdGhhdFxuICogd2UgZG9uJ3QgdHJ5IHRvIGV2YWx1YXRlIHRoZSBtZXRhZGF0YSBpbiB0aGUgY29tcGlsZXIgZHVyaW5nIEFvVC5cbiAqIFRoaXMgZGVjb3JhdG9yIGlzIGVub3VnaCB0byBtYWtlIHRoZSBjb21waWxlciB3b3JrIHdpdGggdGhlIFJlZmxlY3RpdmVJbmplY3RvciB0aG91Z2guXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBDb21waWxlckluamVjdGFibGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFycmF5T2ZTdHJpbmdzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0Rldk1vZGUoKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgSU5URVJQT0xBVElPTl9CTEFDS0xJU1RfUkVHRVhQUyA9IFtcbiAgICAvXlxccyokLyxcbiAgICAvWzw+XS8sXG4gICAgL15be31dJC8sXG4gICAgLyYoI3xbYS16XSkvaSxcbiAgICAvXlxcL1xcLy8sXG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgIShBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT0gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSwgW3N0YXJ0LCBlbmRdLlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZXZNb2RlKCkgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydF8xID0gKHZhbHVlWzBdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kXzEgPSAodmFsdWVbMV0pO1xuICAgICAgICAvLyBibGFjayBsaXN0IGNoZWNraW5nXG4gICAgICAgIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICAgICAgICBpZiAocmVnZXhwLnRlc3Qoc3RhcnRfMSkgfHwgcmVnZXhwLnRlc3QoZW5kXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWydcIiArIHN0YXJ0XzEgKyBcIicsICdcIiArIGVuZF8xICsgXCInXSBjb250YWlucyB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXJrZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBtYXJrZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnO1xufSgpKTtcbnZhciBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHID0gbmV3IEludGVycG9sYXRpb25Db25maWcoJ3t7JywgJ319Jyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVG9rZW5UeXBlID0ge307XG5Ub2tlblR5cGUuQ2hhcmFjdGVyID0gMDtcblRva2VuVHlwZS5JZGVudGlmaWVyID0gMTtcblRva2VuVHlwZS5LZXl3b3JkID0gMjtcblRva2VuVHlwZS5TdHJpbmcgPSAzO1xuVG9rZW5UeXBlLk9wZXJhdG9yID0gNDtcblRva2VuVHlwZS5OdW1iZXIgPSA1O1xuVG9rZW5UeXBlLkVycm9yID0gNjtcblRva2VuVHlwZVtUb2tlblR5cGUuQ2hhcmFjdGVyXSA9IFwiQ2hhcmFjdGVyXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLklkZW50aWZpZXJdID0gXCJJZGVudGlmaWVyXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLktleXdvcmRdID0gXCJLZXl3b3JkXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLlN0cmluZ10gPSBcIlN0cmluZ1wiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5PcGVyYXRvcl0gPSBcIk9wZXJhdG9yXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLk51bWJlcl0gPSBcIk51bWJlclwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5FcnJvcl0gPSBcIkVycm9yXCI7XG52YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbnZhciBMZXhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbkxleGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkxleGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IG51bVZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzdHJWYWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuU3RyaW5nOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3BlcmF0ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLklkZW50aWZpZXI7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdsZXQnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEFzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2FzJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ251bGwnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVHJ1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0cnVlJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRGYWxzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdmYWxzZSc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0aGlzJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5FcnJvcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyID8gdGhpcy5udW1WYWx1ZSA6IC0xOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuQ2hhcmFjdGVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLktleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5PcGVyYXRvcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLlN0cmluZzpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0NoYXJhY3RlclRva2VuKGluZGV4LCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0tleXdvcmRUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5LZXl3b3JkLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdPcGVyYXRvclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdTdHJpbmdUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld051bWJlclRva2VuKGluZGV4LCBuKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk51bWJlciwgbiwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yVG9rZW4oaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuRXJyb3IsIDAsIG1lc3NhZ2UpO1xufVxudmFyIEVPRiA9IG5ldyBUb2tlbigtMSwgVG9rZW5UeXBlLkNoYXJhY3RlciwgMCwgJycpO1xudmFyIF9TY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gX1NjYW5uZXIoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wZWVrID0gKyt0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXQgPSB0aGlzLmlucHV0LCAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZWVrID0gdGhpcy5wZWVrLCAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBlZWsgPSAkRU9GO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVlayA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IGluZGV4O1xuICAgICAgICBzd2l0Y2ggKHBlZWspIHtcbiAgICAgICAgICAgIGNhc2UgJFBFUklPRDpcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaWdpdCh0aGlzLnBlZWspID8gdGhpcy5zY2FuTnVtYmVyKHN0YXJ0KSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCAkUEVSSU9EKTtcbiAgICAgICAgICAgIGNhc2UgJExQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJFJQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJFJCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDS0VUOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRDT01NQTpcbiAgICAgICAgICAgIGNhc2UgJENPTE9OOlxuICAgICAgICAgICAgY2FzZSAkU0VNSUNPTE9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgY2FzZSAkU1E6XG4gICAgICAgICAgICBjYXNlICREUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICRIQVNIOlxuICAgICAgICAgICAgY2FzZSAkUExVUzpcbiAgICAgICAgICAgIGNhc2UgJE1JTlVTOlxuICAgICAgICAgICAgY2FzZSAkU1RBUjpcbiAgICAgICAgICAgIGNhc2UgJFNMQVNIOlxuICAgICAgICAgICAgY2FzZSAkUEVSQ0VOVDpcbiAgICAgICAgICAgIGNhc2UgJENBUkVUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSk7XG4gICAgICAgICAgICBjYXNlICRRVUVTVElPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnPycsICRQRVJJT0QsICcuJyk7XG4gICAgICAgICAgICBjYXNlICRMVDpcbiAgICAgICAgICAgIGNhc2UgJEdUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICBjYXNlICRFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9JywgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJEJBUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsICRCQVIsICd8Jyk7XG4gICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgW1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSArIFwiXVwiLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHN0YXJ0LCBjb2RlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIGNvZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gc3RyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0IHN0YXJ0IGluZGV4IGluIHRoZSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHs/fSB0d29Db2RlIGNvZGUgcG9pbnQgZm9yIHRoZSBzZWNvbmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHs/fSB0d28gc2Vjb25kIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiB0aGUgc2Vjb25kIGNvZGUgcG9pbnQgbWF0Y2hlcylcbiAgICAgKiBAcGFyYW0gez89fSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7Pz19IHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tcGxleE9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBvbmUsIHR3b0NvZGUsIHR3bywgdGhyZWVDb2RlLCB0aHJlZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gb25lO1xuICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHR3bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWVDb2RlICE9IG51bGwgJiYgdGhpcy5wZWVrID09IHRocmVlQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdGhyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgc3RyKSA6XG4gICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWJlciA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb25lbnRTdGFydCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXhwb25lbnRTaWduKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBleHBvbmVudCcsIC0xKTtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHNpbXBsZSA/IHBhcnNlSW50QXV0b1JhZGl4KHN0cikgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIHJldHVybiBuZXdOdW1iZXJUb2tlbihzdGFydCwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdW90ZSA9IHRoaXMucGVlaztcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnVmZmVyID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuZXNjYXBlZENvZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgVFMyLjEtaW50cm9kdWNlZCB0eXBlIHN0cmljdG5lc3NcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWsgPSB0aGlzLnBlZWs7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkdSkge1xuICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05YS1mXSskL2kudGVzdChoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSB1bmVzY2FwZSh0aGlzLnBlZWspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5lc2NhcGVkQ29kZSk7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VudGVybWluYXRlZCBxdW90ZScsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgcmV0dXJuIG5ld1N0cmluZ1Rva2VuKHN0YXJ0LCBidWZmZXIgKyBsYXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIFwiTGV4ZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIGF0IGNvbHVtbiBcIiArIHBvc2l0aW9uICsgXCIgaW4gZXhwcmVzc2lvbiBbXCIgKyB0aGlzLmlucHV0ICsgXCJdXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIF9TY2FubmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIoaW5wdXQpO1xuICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoc2Nhbm5lci5wZWVrKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIHdoaWxlIChzY2FubmVyLnBlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNFeHBvbmVudFN0YXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkTUlOVVMgfHwgY29kZSA9PSAkUExVUztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1F1b3RlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkQlQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlICRuOlxuICAgICAgICAgICAgcmV0dXJuICRMRjtcbiAgICAgICAgY2FzZSAkZjpcbiAgICAgICAgICAgIHJldHVybiAkRkY7XG4gICAgICAgIGNhc2UgJHI6XG4gICAgICAgICAgICByZXR1cm4gJENSO1xuICAgICAgICBjYXNlICR0OlxuICAgICAgICAgICAgcmV0dXJuICRUQUI7XG4gICAgICAgIGNhc2UgJHY6XG4gICAgICAgICAgICByZXR1cm4gJFZUQUI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbnRBdXRvUmFkaXgodGV4dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTcGxpdEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RyaW5nc1xuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBvZmZzZXRzO1xuICAgIH1cbiAgICByZXR1cm4gU3BsaXRJbnRlcnBvbGF0aW9uO1xufSgpKTtcbnZhciBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZUJpbmRpbmdzXG4gICAgICogQHBhcmFtIHs/fSB3YXJuaW5nc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQodGVtcGxhdGVCaW5kaW5ncywgd2FybmluZ3MsIGVycm9ycykge1xuICAgICAgICB0aGlzLnRlbXBsYXRlQmluZGluZ3MgPSB0ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhdHRlcm4gPSBlc2NhcGVSZWdFeHAoY29uZmlnLnN0YXJ0KSArICcoW1xcXFxzXFxcXFNdKj8pJyArIGVzY2FwZVJlZ0V4cChjb25maWcuZW5kKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xufVxudmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbGV4ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZXIoX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIHRydWUsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkhvc3QgYmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIFwiICsgZXJyb3JzLmpvaW4oJyAnKSwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGVyckxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gY3R4TG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgLy8gUXVvdGVzIGV4cHJlc3Npb25zIHVzZSAzcmQtcGFydHkgZXhwcmVzc2lvbiBsYW5ndWFnZS4gV2UgZG9uJ3Qgd2FudCB0byB1c2VcbiAgICAgICAgLy8gb3VyIGxleGVyIG9yIHBhcnNlciBmb3IgdGhhdCwgc28gd2UgY2hlY2sgZm9yIHRoYXQgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGUgPSB0aGlzLl9wYXJzZVF1b3RlKGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIGlmIChxdW90ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VRdW90ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4U2VwYXJhdG9ySW5kZXggPSBpbnB1dC5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChwcmVmaXhTZXBhcmF0b3JJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4U2VwYXJhdG9ySW5kZXgpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGlucHV0LnN1YnN0cmluZyhwcmVmaXhTZXBhcmF0b3JJbmRleCArIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFF1b3RlKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQubGVuZ3RoKSwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVmaXhUb2tlblxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcbiAgICAgICAgaWYgKHByZWZpeFRva2VuKSB7XG4gICAgICAgICAgICAvLyBQcmVmaXggdGhlIHRva2VucyB3aXRoIHRoZSB0b2tlbnMgZnJvbSBwcmVmaXhUb2tlbiBidXQgaGF2ZSB0aGVtIHRha2Ugbm8gc3BhY2UgKDAgaW5kZXgpLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4VG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUocHJlZml4VG9rZW4pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHQuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbnMudW5zaGlmdC5hcHBseSh0b2tlbnMsIHByZWZpeFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlVGVtcGxhdGVCaW5kaW5ncygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGxpdCA9IHRoaXMuc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzcGxpdC5leHByZXNzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvblRleHQgPSBzcGxpdC5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uVGV4dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKHNwbGl0LmV4cHJlc3Npb25zW2ldKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgc3BsaXQub2Zmc2V0c1tpXSArIChleHByZXNzaW9uVGV4dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBJbnRlcnBvbGF0aW9uKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpLCBzcGxpdC5zdHJpbmdzLCBleHByZXNzaW9ucyksIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnNwbGl0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJpbmdzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aCArIGludGVycG9sYXRpb25Db25maWcuZW5kLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKCdCbGFuayBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gaW50ZXJwb2xhdGVkIHN0cmluZ3MnLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCBpLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCckaW1wbGljdCcpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UobmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbigwLCBpbnB1dCA9PSBudWxsID8gMCA6IGlucHV0Lmxlbmd0aCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9zdHJpcENvbW1lbnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaSAhPSBudWxsID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY29tbWVudFN0YXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRDaGFyID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBvdXRlclF1b3RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICBpZiAob3V0ZXJRdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3V0ZXJRdW90ZSA9PSBudWxsICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9jaGVja05vSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGlucHV0LnNwbGl0KHJlZ2V4cCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7P30gcGFydEluRXJySWR4XG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0SW5FcnJJZHgsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyTG9jYXRpb24gPSAnJztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHBhcnRJbkVycklkeDsgaisrKSB7XG4gICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgcGFydHNbal0gOlxuICAgICAgICAgICAgICAgIFwiXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgcGFydHNbal0gKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyTG9jYXRpb24ubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5QYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTGV4ZXIsIH0sXG5dOyB9O1xudmFyIF9QYXJzZUFTVCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gaW5wdXRMZW5ndGhcbiAgICAgKiBAcGFyYW0gez99IHBhcnNlQWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgaW5wdXRMZW5ndGgsIHBhcnNlQWN0aW9uLCBlcnJvcnMsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuaW5wdXRMZW5ndGggPSBpbnB1dExlbmd0aDtcbiAgICAgICAgdGhpcy5wYXJzZUFjdGlvbiA9IHBhcnNlQWN0aW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zW2ldIDogRU9GO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBlZWsoMCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcImlucHV0SW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IHRoaXMubmV4dC5pbmRleCArIHRoaXMub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc3BhbiA9IGZ1bmN0aW9uIChzdGFydCkgeyByZXR1cm4gbmV3IFBhcnNlU3BhbihzdGFydCwgdGhpcy5pbnB1dEluZGV4KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRleCsrOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5vcHRpb25hbENoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRMZXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRBcygpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3Rlcihjb2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkgJiYgIW4uaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyB0aGlzLm5leHQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8JykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQ2Fubm90IGhhdmUgYSBwaXBlIGluIGFuIGFjdGlvbiBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmRpbmdQaXBlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm8gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQsIHllcywgbm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbE9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnfHwnXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcmJidcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksICcmJicsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFcXVhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJz09JywnIT0nLCc9PT0nLCchPT0nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUmVsYXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJzwnLCAnPicsICc8PScsICc+PSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VNdWx0aXBsaWNhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCBvcGVyYXRvciwgbmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbihzdGFydCwgc3RhcnQpLCAwKSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxDaGFpbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFBFUklPRCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/LicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFdyaXRlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRSZWFkKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGdW5jdGlvbkNhbGwodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVHJ1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRmFsc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUaGlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRMQlJBQ0UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbGl0ZXJhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246IFwiICsgdGhpcy5pbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdGhpcy5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlcm1pbmF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRMQlJBQ0UpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFJCUkFDRSkpIHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkKys7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAodGhpcy5zcGFuKHN0YXJ0KSwga2V5cywgdmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBpc1NhZmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgIG5ldyBNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1RoZSBcXCc/LlxcJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmdzIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbEFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbmFscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluYmV0d2Vlbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy0nKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JGb3VuZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhcm5pbmdzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleUlzVmFyID0gdGhpcy5wZWVrS2V5d29yZExldCgpO1xuICAgICAgICAgICAgaWYgKGtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByYXdLZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gcmF3S2V5O1xuICAgICAgICAgICAgaWYgKCFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwcmVmaXggKyBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnXFwkaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGV0U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIGNvbnN1bWUgYGFzYFxuICAgICAgICAgICAgICAgIG5hbWUgPSByYXdLZXk7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGtleUlzVmFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCAhPT0gRU9GICYmICF0aGlzLnBlZWtLZXl3b3JkTGV0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydF8yID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnRfMiAtIHRoaXMub2Zmc2V0LCB0aGlzLmlucHV0SW5kZXggLSB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBBU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCB0aGlzLmxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBUZW1wbGF0ZUJpbmRpbmcodGhpcy5zcGFuKHN0YXJ0KSwga2V5LCBrZXlJc1ZhciwgbmFtZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla0tleXdvcmRBcygpICYmICFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxldFN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIGBhc2BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZXROYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4obGV0U3RhcnQpLCBsZXROYW1lLCB0cnVlLCBrZXksIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCB3YXJuaW5ncywgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/PX0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmxvY2F0aW9uVGV4dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcbiAgICAgICAgICAgIFwiYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoICYmICFuLmlzQ2hhcmFjdGVyKCRTRU1JQ09MT04pICYmXG4gICAgICAgICAgICAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcih0aGlzLm5leHQudG9TdHJpbmcoKSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoKSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1BhcnNlQVNUO1xufSgpKTtcbnZhciBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQocyk7XG4gICAgICAgIHJldHVybiBzLmVycm9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuZXJyb3JzLnB1c2goJ3BpcGVzJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/fSBsaW5lXG4gICAgICogQHBhcmFtIHs/fSBjb2xcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZUxvY2F0aW9uKGZpbGUsIG9mZnNldCwgbGluZSwgY29sKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICE9IG51bGwgPyB0aGlzLmZpbGUudXJsICsgXCJAXCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sIDogdGhpcy5maWxlLnVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2UgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbCA9IHRoaXMuY29sO1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gMCAmJiBkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lLS07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJpb3JMaW5lID0gc291cmNlLnN1YnN0cigwLCBvZmZzZXQgLSAxKS5sYXN0SW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKCRMRikpO1xuICAgICAgICAgICAgICAgIGNvbCA9IHByaW9yTGluZSA+IDAgPyBvZmZzZXQgLSBwcmlvckxpbmUgOiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXhDaGFyc1xuICAgICAqIEBwYXJhbSB7P30gbWF4TGluZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAobWF4Q2hhcnMsIG1heExpbmVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA+IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbc3RhcnRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIGVuZE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbZW5kT2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udGVudC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHRoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBhZnRlcjogY29udGVudC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIGVuZE9mZnNldCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZUxvY2F0aW9uO1xufSgpKTtcbnZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU291cmNlRmlsZTtcbn0oKSk7XG52YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBlbmRcbiAgICAgKiBAcGFyYW0gez89fSBkZXRhaWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlU291cmNlU3Bhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VTb3VyY2VTcGFuO1xufSgpKTtcbnZhciBQYXJzZUVycm9yTGV2ZWwgPSB7fTtcblBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HID0gMDtcblBhcnNlRXJyb3JMZXZlbC5FUlJPUiA9IDE7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLldBUk5JTkddID0gXCJXQVJOSU5HXCI7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLkVSUk9SXSA9IFwiRVJST1JcIjtcbnZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEBwYXJhbSB7Pz19IGxldmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VFcnJvcihzcGFuLCBtc2csIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IHRoaXMuc3Bhbi5zdGFydC5nZXRDb250ZXh0KDEwMCwgMyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHRTdHIgPSBjdHggPyBcIiAoXFxcIlwiICsgY3R4LmJlZm9yZSArIFwiW1wiICsgUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdICsgXCIgLT5dXCIgKyBjdHguYWZ0ZXIgKyBcIlxcXCIpXCIgOiAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IHRoaXMuc3Bhbi5kZXRhaWxzID8gXCIsIFwiICsgdGhpcy5zcGFuLmRldGFpbHMgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLm1zZyArIGNvbnRleHRTdHIgKyBcIjogXCIgKyB0aGlzLnNwYW4uc3RhcnQgKyBkZXRhaWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGtpbmRcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVVybCA9IGlkZW50aWZpZXJNb2R1bGVVcmwodHlwZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlRmlsZU5hbWUgPSBtb2R1bGVVcmwgIT0gbnVsbCA/IFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyBpZGVudGlmaWVyTmFtZSh0eXBlKSArIFwiIGluIFwiICsgbW9kdWxlVXJsIDpcbiAgICAgICAgXCJpbiBcIiArIGtpbmQgKyBcIiBcIiArIGlkZW50aWZpZXJOYW1lKHR5cGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4obmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgbnVsbCwgbnVsbCwgbnVsbCksIG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIG51bGwsIG51bGwsIG51bGwpKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQ7XG59KCkpO1xudmFyIEV4cGFuc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzd2l0Y2hWYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY2FzZXNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN3aXRjaFZhbHVlU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlID0gc3dpdGNoVmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwYW5zaW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb247XG59KCkpO1xudmFyIEV4cGFuc2lvbkNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlU291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbkNhc2UodmFsdWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU291cmNlU3BhbiwgZXhwU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTb3VyY2VTcGFuID0gdmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmV4cFNvdXJjZVNwYW4gPSBleHBTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cGFuc2lvbkNhc2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb25DYXNlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb25DYXNlO1xufSgpKTtcbnZhciBBdHRyaWJ1dGUkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZSQxKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBdHRyaWJ1dGUkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQXR0cmlidXRlJDE7XG59KCkpO1xudmFyIEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGVuZFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRWxlbWVudDtcbn0oKSk7XG52YXIgQ29tbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbW1lbnQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb21tZW50O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez89fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdEFsbCh2aXNpdG9yLCBub2RlcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUkMSA9IHt9O1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fU1RBUlQgPSAwO1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EID0gMTtcblRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEID0gMjtcblRva2VuVHlwZSQxLlRBR19DTE9TRSA9IDM7XG5Ub2tlblR5cGUkMS5URVhUID0gNDtcblRva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDU7XG5Ub2tlblR5cGUkMS5SQVdfVEVYVCA9IDY7XG5Ub2tlblR5cGUkMS5DT01NRU5UX1NUQVJUID0gNztcblRva2VuVHlwZSQxLkNPTU1FTlRfRU5EID0gODtcblRva2VuVHlwZSQxLkNEQVRBX1NUQVJUID0gOTtcblRva2VuVHlwZSQxLkNEQVRBX0VORCA9IDEwO1xuVG9rZW5UeXBlJDEuQVRUUl9OQU1FID0gMTE7XG5Ub2tlblR5cGUkMS5BVFRSX1ZBTFVFID0gMTI7XG5Ub2tlblR5cGUkMS5ET0NfVFlQRSA9IDEzO1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgPSAxNDtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFID0gMTU7XG5Ub2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgPSAxNjtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgPSAxNztcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCA9IDE4O1xuVG9rZW5UeXBlJDEuRU9GID0gMTk7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVF0gPSBcIlRBR19PUEVOX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRdID0gXCJUQUdfT1BFTl9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19DTE9TRV0gPSBcIlRBR19DTE9TRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuVEVYVF0gPSBcIlRFWFRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuUkFXX1RFWFRdID0gXCJSQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVF0gPSBcIkNPTU1FTlRfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNPTU1FTlRfRU5EXSA9IFwiQ09NTUVOVF9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX1NUQVJUXSA9IFwiQ0RBVEFfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX0VORF0gPSBcIkNEQVRBX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQVRUUl9OQU1FXSA9IFwiQVRUUl9OQU1FXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5BVFRSX1ZBTFVFXSA9IFwiQVRUUl9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRE9DX1RZUEVdID0gXCJET0NfVFlQRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlRdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUVdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EXSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FT0ZdID0gXCJFT0ZcIjtcbnZhciBUb2tlbiQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW4kMSh0eXBlLCBwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBUb2tlbiQxO1xufSgpKTtcbnZhciBUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9rZW5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yTXNnXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb2tlbkVycm9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFRva2VuaXplUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5pemVSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICogQHBhcmFtIHs/PX0gdG9rZW5pemVFeHBhbnNpb25Gb3Jtc1xuICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICBpZiAodG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICByZXR1cm4gbmV3IF9Ub2tlbml6ZXIobmV3IFBhcnNlU291cmNlRmlsZShzb3VyY2UsIHVybCksIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAgIC50b2tlbml6ZSgpO1xufVxudmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG4vKipcbiAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFxcXCJcIiArIGNoYXIgKyBcIlxcXCJcIjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbnRpdHlTcmNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93biBlbnRpdHkgXFxcIlwiICsgZW50aXR5U3JjICsgXCJcXFwiIC0gdXNlIHRoZSBcXFwiJiM8ZGVjaW1hbD47XFxcIiBvciAgXFxcIiYjeDxoZXg+O1xcXCIgc3ludGF4XCI7XG59XG52YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbn0oKSk7XG52YXIgX1Rva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZmlsZSBUaGUgaHRtbCBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IF9nZXRUYWdEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHs/fSBfdG9rZW5pemVJY3UgV2hldGhlciB0byB0b2tlbml6ZSBJQ1UgbWVzc2FnZXMgKGNvbnNpZGVyZWQgYXMgdGV4dCBub2RlcyB3aGVuIGZhbHNlKVxuICAgICAqIEBwYXJhbSB7Pz19IF9pbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Rva2VuaXplcihfZmlsZSwgX2dldFRhZ0RlZmluaXRpb24sIF90b2tlbml6ZUljdSwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKF9pbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgX2ludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBfZmlsZTtcbiAgICAgICAgdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbiA9IF9nZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IF90b2tlbml6ZUljdTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9wZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX25leHRQZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSAtMTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IF9maWxlLmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IF9maWxlLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl90b2tlbml6ZUljdSAmJiB0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRU9GKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX3BlZWspICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLl9maWxlLCB0aGlzLl9pbmRleCwgdGhpcy5fbGluZSwgdGhpcy5fY29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZW5kVG9rZW4gPSBmdW5jdGlvbiAocGFydHMsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IG5ldyBUb2tlbiQxKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gbmV3IFRva2VuRXJyb3IobXNnLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBzcGFuKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29udHJvbEZsb3dFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKCRFT0YpLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkTEYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlayAhPT0gJExGICYmIHRoaXMuX3BlZWsgIT09ICRDUikge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMuX2luZGV4ID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgdGhpcy5fbmV4dFBlZWsgPVxuICAgICAgICAgICAgdGhpcy5faW5kZXggKyAxID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4ICsgMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJDb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX3BlZWssIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3Bhbihsb2NhdGlvbiwgbG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHIgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggKyBsZW4gPiB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbml0aWFsUG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gcGFyc2UgdGhlIHN0cmluZyBmYWlscywgd2Ugd2FudCB0byByZXNldCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgYXR0ZW1wdFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZVN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0cihjaGFycykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB3aGlsZSAoIXByZWRpY2F0ZSh0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7P30gbGVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4IC0gc3RhcnQub2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKHN0YXJ0LCBzdGFydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0VW50aWxDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRDaGFyID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgIGlmIChkZWNvZGVFbnRpdGllcyAmJiB0aGlzLl9wZWVrID09PSAkQU1QRVJTQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlRW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkSEFTSCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSGV4ID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCR4KSB8fCB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnVtYmVyU3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNEaWdpdEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ck51bSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhudW1iZXJTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhckNvZGUgPSBwYXJzZUludChzdHJOdW0sIGlzSGV4ID8gMTYgOiAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRpdHkgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0UG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOYW1lZEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWUpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEBwYXJhbSB7P30gZmlyc3RDaGFyT2ZFbmRcbiAgICAgKiBAcGFyYW0gez99IGF0dGVtcHRFbmRSZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHQgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMsIGZpcnN0Q2hhck9mRW5kLCBhdHRlbXB0RW5kUmVzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0U3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKGRlY29kZUVudGl0aWVzID8gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUIDogVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRleHRTdGFydCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoZmlyc3RDaGFyT2ZFbmQpICYmIGF0dGVtcHRFbmRSZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+IHRhZ0Nsb3NlU3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGJ5IHRoZSBwcmV2aW91cyBpZiBzdGF0ZW1lbnQgdG8gdGhlIG91dHB1dFxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW5wdXQuc3Vic3RyaW5nKHRhZ0Nsb3NlU3RhcnQub2Zmc2V0LCB0aGlzLl9pbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGZpcnN0Q2hhck9mRW5kKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcihkZWNvZGVFbnRpdGllcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldLCB0YWdDbG9zZVN0YXJ0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRNSU5VUyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRNSU5VUywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0+Jyk7IH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5ELCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignQ0RBVEFbJyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRSQlJBQ0tFVCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJ10+Jyk7IH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVEb2NUeXBlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRE9DX1RZUEUsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdFVudGlsQ2hhcigkR1QpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMiwgdGhpcy5faW5kZXggLSAxKV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVByZWZpeEFuZE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVPclByZWZpeFN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZVN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZU9yUHJlZml4U3RhcnQsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCB0aGlzLl9pbmRleCA9PT0gbmFtZVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRQb3MgPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ZXJjYXNlVGFnTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJFNMQVNIICYmIHRoaXMuX3BlZWsgIT09ICRHVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEVRKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbkVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50VG9rZW5UeXBlID0gdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbih0YWdOYW1lKS5jb250ZW50VHlwZTtcbiAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBsb3dlcmNhc2VUYWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKGxvd2VyY2FzZVRhZ05hbWUsIGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGRlY29kZUVudGl0aWVzLCAkTFQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKGxvd2VyY2FzZVRhZ05hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtudWxsLCBsb3dlcmNhc2VUYWdOYW1lXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9OQU1FKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRTUSB8fCB0aGlzLl9wZWVrID09PSAkRFEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1b3RlQ2hhciA9IHRoaXMuX3BlZWs7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IHF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHZhbHVlU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEIDogVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX0NMT1NFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdHlwZV0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5faW5JbnRlcnBvbGF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghdGhpcy5faXNUZXh0RW5kKCkpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzVGV4dEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMVCB8fCB0aGlzLl9wZWVrID09PSAkRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9zYXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fcGVlaywgdGhpcy5faW5kZXgsIHRoaXMuX2NvbHVtbiwgdGhpcy5fbGluZSwgdGhpcy50b2tlbnMubGVuZ3RoXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXN0b3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcGVlayA9IHBvc2l0aW9uWzBdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgdGhpcy5fbGluZSA9IHBvc2l0aW9uWzNdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYlRva2VucyA9IHBvc2l0aW9uWzRdO1xuICAgICAgICBpZiAobmJUb2tlbnMgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXh0cmEgdG9rZW5zXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDAsIG5iVG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUO1xuICAgIH07XG4gICAgcmV0dXJuIF9Ub2tlbml6ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRTTEFTSCB8fFxuICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiZcbiAgICAgICAgKGNvZGUgPCAkMCB8fCBjb2RlID4gJDkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGlnaXRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwYW5zaW9uRm9ybVN0YXJ0KGlucHV0LCBvZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ludGVycG9sYXRpb25TdGFydCA9IGludGVycG9sYXRpb25Db25maWcgPyBpbnB1dC5pbmRleE9mKGludGVycG9sYXRpb25Db25maWcuc3RhcnQsIG9mZnNldCkgPT0gb2Zmc2V0IDogZmFsc2U7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PSAkTEJSQUNFICYmICFpc0ludGVycG9sYXRpb25TdGFydDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwZWVrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGUxXG4gKiBAcGFyYW0gez99IGNvZGUyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3JjVG9rZW5zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHN0VG9rZW5zID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdERzdFRva2VuO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzcmNUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCAmJiB0b2tlbi50eXBlID09IFRva2VuVHlwZSQxLlRFWFQpIHtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5wYXJ0c1swXSArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5zb3VyY2VTcGFuLmVuZCA9IHRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBkc3RUb2tlbnMucHVzaChsYXN0RHN0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkc3RUb2tlbnM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVHJlZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJlZUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyZWVFcnJvci5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmVlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBQYXJzZVRyZWVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdE5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZVRyZWVSZXN1bHQocm9vdE5vZGVzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSByb290Tm9kZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VUcmVlUmVzdWx0O1xufSgpKTtcbnZhciBQYXJzZXIkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBnZXRUYWdEZWZpbml0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VyJDEoZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlciQxLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2Vuc0FuZEVycm9ycyA9IHRva2VuaXplKHNvdXJjZSwgdXJsLCB0aGlzLmdldFRhZ0RlZmluaXRpb24sIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmVlQW5kRXJyb3JzID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbnNBbmRFcnJvcnMudG9rZW5zLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyZWVBbmRFcnJvcnMucm9vdE5vZGVzLCAoKHRva2Vuc0FuZEVycm9ycy5lcnJvcnMpKS5jb25jYXQodHJlZUFuZEVycm9ycy5lcnJvcnMpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXIkMTtcbn0oKSk7XG52YXIgX1RyZWVCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9UcmVlQnVpbGRlcih0b2tlbnMsIGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19DTE9TRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEVYVCB8fCB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlJBV19URVhUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBvdGhlciB0b2tlbnMuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodGhpcy5fcm9vdE5vZGVzLCB0aGlzLl9lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ID0gdGhpcy5fcGVlaztcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYWx3YXlzIGFuIEVPRiB0b2tlbiBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLnRva2Vuc1t0aGlzLl9pbmRleF07XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlSWYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnRUb2tlbikge1xuICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ0RBVEFfRU5EKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuUkFXX1RFWFQpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRleHQgIT0gbnVsbCA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb24gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gW107XG4gICAgICAgIC8vIHJlYWQgPVxuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwQ2FzZSA9IHRoaXMuX3BhcnNlRXhwYW5zaW9uQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFleHBDYXNlKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXJyb3JcbiAgICAgICAgICAgIGNhc2VzLnB1c2goZXhwQ2FzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCB0aGUgZmluYWwgfVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBFeHBhbnNpb24oc3dpdGNoVmFsdWUucGFydHNbMF0sIHR5cGUucGFydHNbMF0sIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZS5zb3VyY2VTcGFuKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcGFyc2VFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgLy8gcmVhZCB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAneycuXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwID0gdGhpcy5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCk7XG4gICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2gobmV3IFRva2VuJDEoVG9rZW5UeXBlJDEuRU9GLCBbXSwgZW5kLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkRXhwID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgaWYgKHBhcnNlZEV4cC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy5fZXJyb3JzLmNvbmNhdCgvKiogQHR5cGUgez99ICovIChwYXJzZWRFeHAuZXJyb3JzKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBTb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydC5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UodmFsdWUucGFydHNbMF0sIHBhcnNlZEV4cC5yb290Tm9kZXMsIHNvdXJjZVNwYW4sIHZhbHVlLnNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHAgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uRm9ybVN0YWNrID0gW1Rva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvbkZvcm1TdGFjay5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cC5wdXNoKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudC5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBUZXh0KHRleHQsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0VGFnVG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVTdGFydFRhZyA9IGZ1bmN0aW9uIChzdGFydFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5BVFRSX05BTUUpIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlOiBUaGVyZSBjb3VsZCBoYXZlIGJlZW4gYSB0b2tlbml6ZXIgZXJyb3JcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSk7XG4gICAgICAgICAgICBpZiAoISh0YWdEZWYuY2FuU2VsZkNsb3NlIHx8IGdldE5zUHJlZml4KGZ1bGxOYW1lKSAhPT0gbnVsbCB8fCB0YWdEZWYuaXNWb2lkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgXCJPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFxcXCJcIiArIHN0YXJ0VGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuX3BlZWsuc291cmNlU3Bhbi5zdGFydDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IG5ldyBFbGVtZW50KGZ1bGxOYW1lLCBhdHRycywgW10sIHNwYW4sIHNwYW4sIG51bGwpO1xuICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSk7XG4gICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcHVzaEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRFbCA9IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudEVsLm5hbWUpLmlzQ2xvc2VkQnlDaGlsZChlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMoKSwgcGFyZW50ID0gX2EucGFyZW50LCBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgdGFnRGVmLnJlcXVpcmVFeHRyYVBhcmVudChwYXJlbnQubmFtZSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1BhcmVudCA9IG5ldyBFbGVtZW50KHRhZ0RlZi5wYXJlbnRUb0FkZCwgW10sIFtdLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QmVmb3JlQ29udGFpbmVyKHBhcmVudCwgY29udGFpbmVyLCBuZXdQYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KGVsKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnB1c2goZWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbmRUYWdUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUVuZFRhZyA9IGZ1bmN0aW9uIChlbmRUYWdUb2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShlbmRUYWdUb2tlbi5wYXJ0c1swXSwgZW5kVGFnVG9rZW4ucGFydHNbMV0sIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJNc2cgPSBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZnVsbE5hbWUgKyBcIlxcXCIuIEl0IG1heSBoYXBwZW4gd2hlbiB0aGUgdGFnIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgdGFnLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjY2xvc2luZy1lbGVtZW50cy10aGF0LWhhdmUtaW1wbGllZC1lbmQtdGFnc1wiO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgZXJyTXNnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BvcEVsZW1lbnQgPSBmdW5jdGlvbiAoZnVsbE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFja0luZGV4ID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSW5kZXggPj0gMDsgc3RhY2tJbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnNwbGljZShzdGFja0luZGV4LCB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gc3RhY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IG1lcmdlTnNBbmROYW1lKGF0dHJOYW1lLnBhcnRzWzBdLCBhdHRyTmFtZS5wYXJ0c1sxXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVNwYW47XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICBlbmQgPSB2YWx1ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgdmFsdWVTcGFuID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlJDEoZnVsbE5hbWUsIHZhbHVlLCBuZXcgUGFyc2VTb3VyY2VTcGFuKGF0dHJOYW1lLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCksIHZhbHVlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCA/IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgPG5nLWNvbnRhaW5lcj5gIGVsZW1lbnRzIGFyZSBza2lwcGVkIGFzIHRoZXkgYXJlIG5vdCByZW5kZXJlZCBhcyBET00gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFja1tpXS5uYW1lICE9PSAnbmctY29udGFpbmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW2ldLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFN0YWNrW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWRkVG9QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjb250YWluZXIuXG4gICAgICogV2hlbiBubyBjb250YWluZXIgaXMgZ2l2ZW4sIHRoZSBub2RlIGlzIGFwcGVuZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGVsZW1lbnQgc3RhY2sgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBjb250YWluZXIgd2l0aCB0aGUgbmV3IG5vZGUgaW4gdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSBsb2NhbE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsICYmIHBhcmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdldE5zUHJlZml4KHBhcmVudEVsZW1lbnQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBfVHJlZUJ1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0YWNrXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGVsZW1lbnQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAqIEBwYXJhbSB7P30gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHBsYWNlaG9sZGVyVG9NZXNzYWdlIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gbWVzc2FnZXMgKHVzZWQgZm9yIG5lc3RlZCBJQ1UgbWVzc2FnZXMpXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlKG5vZGVzLCBwbGFjZWhvbGRlcnMsIHBsYWNlaG9sZGVyVG9NZXNzYWdlLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclRvTWVzc2FnZSA9IHBsYWNlaG9sZGVyVG9NZXNzYWdlO1xuICAgICAgICB0aGlzLm1lYW5pbmcgPSBtZWFuaW5nO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xudmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQkMSh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQkMTtcbn0oKSk7XG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xudmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjYXNlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljdShleHByZXNzaW9uLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gSWN1O1xufSgpKTtcbnZhciBUYWdQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBzdGFydE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNsb3NlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0gez99IGlzVm9pZFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGFnUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbn0oKSk7XG52YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY3VQbGFjZWhvbGRlcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdVBsYWNlaG9sZGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xufSgpKTtcbnZhciBDbG9uZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsb25lVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoaWxkcmVuLCBjb250YWluZXIuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gbmV3IEljdShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHBoLnN0YXJ0TmFtZSwgcGguY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb25lVmlzaXRvcjtcbn0oKSk7XG52YXIgUmVjdXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IH07XG4gICAgO1xuICAgIHJldHVybiBSZWN1cnNlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTID0ge1xuICAgICdBJzogJ0xJTksnLFxuICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxuICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcbiAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcbiAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcbiAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcbiAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcbiAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxuICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXG4gICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcbiAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXG59O1xuLyoqXG4gKiBDcmVhdGVzIHVuaXF1ZSBuYW1lcyBmb3IgcGxhY2Vob2xkZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cyA9IHt9O1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZvaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSB0aGlzLl9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogXCJTVEFSVF9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gaXNWb2lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gXCIgXCIgKyBuYW1lICsgXCI9XCIgKyBhdHRyc1tuYW1lXTsgfSkuam9pbignJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9oYXNoQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRoaXMuX2hhc2hUYWcoXCIvXCIgKyB0YWcsIHt9LCBmYWxzZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VlbiA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cy5oYXNPd25Qcm9wZXJ0eShiYXNlKTtcbiAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV07XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IGlkICsgMTtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBcIl9cIiArIGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCkgeyByZXR1cm4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpOyB9O1xufVxudmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwcmVzc2lvblBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMuX2lzSWN1ID0gbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb247XG4gICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeSA9IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50ID0ge307XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIHt9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCwgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9IGVsLnNvdXJjZVNwYW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VQaE5hbWUgPSAnJztcbiAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgIGNsb3NlUGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W2Nsb3NlUGhOYW1lXSA9IFwiPC9cIiArIGVsLm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKGVsLm5hbWUsIGF0dHJzLCBzdGFydFBoTmFtZSwgY2xvc2VQaE5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIGVsLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbihhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICBpY3UuY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F6ZSkge1xuICAgICAgICAgICAgaTE4bkljdUNhc2VzW2NhemUudmFsdWVdID0gbmV3IENvbnRhaW5lcihjYXplLmV4cHJlc3Npb24ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCB7fSk7IH0pLCBjYXplLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faWN1RGVwdGgtLTtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWN1IHx8IHRoaXMuX2ljdURlcHRoID4gMCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBhbiBJQ1Ugbm9kZSB3aGVuOlxuICAgICAgICAgICAgLy8gLSB0aGUgbWVzc2FnZSAodnMgYSBwYXJ0IG9mIHRoZSBtZXNzYWdlKSBpcyBhbiBJQ1UgbWVzc2FnZSwgb3JcbiAgICAgICAgICAgIC8vIC0gdGhlIElDVSBtZXNzYWdlIGlzIG5lc3RlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cFBoID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRVbmlxdWVQbGFjZWhvbGRlcihcIlZBUl9cIiArIGljdS50eXBlKTtcbiAgICAgICAgICAgIGkxOG5JY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyID0gZXhwUGg7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtleHBQaF0gPSBpY3Uuc3dpdGNoVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gaTE4bkljdTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHJldHVybnMgYSBwbGFjZWhvbGRlclxuICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAvLyB0cmFuc2xhdGlvbnMuIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHZpc2l0b3IgKHRoZXkgYXJlIG5vdCByZS1lbnRyYW50KSB0byBjb21wdXRlIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGlkLlxuICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKHRoaXMuX2V4cHJlc3Npb25QYXJzZXIsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdID0gdmlzaXRvci50b0kxOG5NZXNzYWdlKFtpY3VdLCAnJywgJycsICcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihpMThuSWN1LCBwaE5hbWUsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodGV4dCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGxpdEludGVycG9sYXRpb24gPSB0aGlzLl9leHByZXNzaW9uUGFyc2VyLnNwbGl0SW50ZXJwb2xhdGlvbih0ZXh0LCBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCksIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoIXNwbGl0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCQxKHRleHQsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKG5vZGVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZywgc0RlbGltaXRlciA9IF9hLnN0YXJ0LCBlRGVsaW1pdGVyID0gX2EuZW5kO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gc3BsaXRJbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZShiYXNlTmFtZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtwaE5hbWVdID0gc0RlbGltaXRlciArIGV4cHJlc3Npb24gKyBlRGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsYXN0IGluZGV4IGNvbnRhaW5zIG5vIGV4cHJlc3Npb25cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xufSgpKTtcbnZhciBfQ1VTVE9NX1BIX0VYUCA9IC9cXC9cXC9bXFxzXFxTXSppMThuW1xcc1xcU10qXFwoW1xcc1xcU10qcGhbXFxzXFxTXSo9W1xcc1xcU10qKFwifCcpKFtcXHNcXFNdKj8pXFwxW1xcc1xcU10qXFwpL2c7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnNwbGl0KF9DVVNUT01fUEhfRVhQKVsyXTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaTE4biBlcnJvci5cbiAqL1xudmFyIEkxOG5FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEkxOG5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG52YXIgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xudmFyIF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCA9IC9eaTE4bjo/LztcbnZhciBNRUFOSU5HX1NFUEFSQVRPUiA9ICd8JztcbnZhciBJRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEBwYXJhbSB7P30gaW1wbGljaXRUYWdzXG4gKiBAcGFyYW0gez99IGltcGxpY2l0QXR0cnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IHRyYW5zbGF0aW9uc1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcGFyYW0gez99IGltcGxpY2l0VGFnc1xuICogQHBhcmFtIHs/fSBpbXBsaWNpdEF0dHJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZVRyYW5zbGF0aW9ucyhub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgcmV0dXJuIHZpc2l0b3IubWVyZ2Uobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG59XG52YXIgRXh0cmFjdGlvblJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0cmFjdGlvblJlc3VsdChtZXNzYWdlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xufSgpKTtcbnZhciBfVmlzaXRvck1vZGUgPSB7fTtcbl9WaXNpdG9yTW9kZS5FeHRyYWN0ID0gMDtcbl9WaXNpdG9yTW9kZS5NZXJnZSA9IDE7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLkV4dHJhY3RdID0gXCJFeHRyYWN0XCI7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLk1lcmdlXSA9IFwiTWVyZ2VcIjtcbi8qKlxuICogVGhpcyBWaXNpdG9yIGlzIHVzZWQ6XG4gKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIF9WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdFRhZ3NcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdEF0dHJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCBudWxsKTsgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXh0cmFjdGlvblJlc3VsdCh0aGlzLl9tZXNzYWdlcywgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmVlIHdoZXJlIGFsbCB0cmFuc2xhdGFibGUgbm9kZXMgYXJlIHRyYW5zbGF0ZWRcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UoaWN1Q2FzZS52YWx1ZSwgZXhwcmVzc2lvbiwgaWN1Q2FzZS5zb3VyY2VTcGFuLCBpY3VDYXNlLnZhbHVlU291cmNlU3BhbiwgaWN1Q2FzZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhc0luSWN1ID0gdGhpcy5faW5JY3U7XG4gICAgICAgIGlmICghdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2ljdV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5JY3UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgaWN1ID0gbmV3IEV4cGFuc2lvbihpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlcywgaWN1LnNvdXJjZVNwYW4sIGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgIHJldHVybiBpY3U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09wZW5pbmcgPSBfaXNPcGVuaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcgJiYgIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnVHJ5aW5nIHRvIGNsb3NlIGFuIHVub3BlbmVkIGJsb2NrJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5Ob2RlICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjID0gY29tbWVudC52YWx1ZS5yZXBsYWNlKF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UodGhpcy5fYmxvY2tDaGlsZHJlbiwgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoY29tbWVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGVkQ2hpbGROb2RlcztcbiAgICAgICAgLy8gRXh0cmFjdDpcbiAgICAgICAgLy8gLSB0b3AgbGV2ZWwgbm9kZXMgd2l0aCB0aGUgKGltcGxpY2l0KSBcImkxOG5cIiBhdHRyaWJ1dGUgaWYgbm90IGFscmVhZHkgaW4gYSBzZWN0aW9uXG4gICAgICAgIC8vIC0gSUNVIG1lc3NhZ2VzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5BdHRyID0gX2dldEkxOG5BdHRyKGVsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk1ldGEgPSBpMThuQXR0ciA/IGkxOG5BdHRyLnZhbHVlIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW1wbGljaXQgPSB0aGlzLl9pbXBsaWNpdFRhZ3Muc29tZShmdW5jdGlvbiAodGFnKSB7IHJldHVybiBlbC5uYW1lID09PSB0YWc7IH0pICYmICF0aGlzLl9pbkljdSAmJlxuICAgICAgICAgICAgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZSB8fCBpc0ltcGxpY2l0O1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuTWV0YSk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUcmFuc2xhdGFibGUgPSBpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGVsLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsICdDb3VsZCBub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIGludG8gY2hpbGQgbm9kZXMgZm9yIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXROb2RlcyA9IHRyYW5zbGF0ZWRDaGlsZE5vZGVzIHx8IGVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmlzaXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhpcyBsb29wIHdoZW4gdGhlIGJsb2NrIGNsb3NlcyAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aC0tO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gd2FzSW5JMThuTm9kZTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZEF0dHJzID0gdGhpcy5fdHJhbnNsYXRlQXR0cmlidXRlcyhlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9pbkljdSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0QXR0cmlidXRlc09mID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcGxpY2l0QXR0ck5hbWVzID0gdGhpcy5faW1wbGljaXRBdHRyc1tlbC5uYW1lXSB8fCBbXTtcbiAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgIGF0dHIudmFsdWU7IH0pO1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdLCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/PX0gbXNnTWV0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRNZXNzYWdlID0gZnVuY3Rpb24gKGFzdCwgbXNnTWV0YSkge1xuICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgQXR0cmlidXRlJDEgJiYgISgoYXN0WzBdKSkudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfcGFyc2VNZXNzYWdlTWV0YShtc2dNZXRhKSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShhc3QsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl90cmFuc2xhdGVNZXNzYWdlID0gZnVuY3Rpb24gKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlICYmIHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSB0aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIG1lc3NhZ2UgaWQ9XFxcIlwiICsgdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cmlidXRlcyA9IGVsLmF0dHJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuUGFyc2VkTWVzc2FnZU1ldGEgPSB7fTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgaTE4blBhcnNlZE1lc3NhZ2VNZXRhW2F0dHIubmFtZS5zbGljZShfSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpXSA9XG4gICAgICAgICAgICAgICAgICAgIF9wYXJzZU1lc3NhZ2VNZXRhKGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlICYmIGF0dHIudmFsdWUgIT0gJycgJiYgaTE4blBhcnNlZE1lc3NhZ2VNZXRhLmhhc093blByb3BlcnR5KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lXSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IF90aGlzLl9jcmVhdGVJMThuTWVzc2FnZShbYXR0cl0sIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBfdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUkMShhdHRyLm5hbWUsICcnLCBhdHRyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2Rlc1swXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gKChub2Rlc1swXSkpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAqIC0gd2UgYXJlIGluIGEgYmxvY2ssXG4gICAgICogLSB3ZSBhcmUgbm90IGluc2lkZSBhIElDVSBtZXNzYWdlICh0aG9zZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5KSxcbiAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrICYmICF0aGlzLl9pbkljdSAmJiB0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHN0YXJ0IG9mIGEgc2VjdGlvbiwgc2VlIGBfY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uYFxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9WaXNpdG9yLnByb3RvdHlwZSwgXCJfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0cmFuc2xhdGFibGUgc2VjdGlvbiBjb3VsZCBiZTpcbiAgICAgICAgICogLSB0aGUgY29udGVudCBvZiB0cmFuc2xhdGFibGUgZWxlbWVudCxcbiAgICAgICAgICogLSBub2RlcyBiZXR3ZWVuIGA8IS0tIGkxOG4gLS0+YCBhbmQgYDwhLS0gL2kxOG4gLS0+YCBjb21tZW50c1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCAhPT0gdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIGEgc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgc2VjdGlvbiBoYXMgb25seSBvbmUgc2lnbmlmaWNhbnQgY2hpbGRyZW4gKGNvbW1lbnRzIG5vdCBzaWduaWZpY2FudCkgdGhlbiB3ZSBzaG91bGQgbm90XG4gICAgICoga2VlcCB0aGUgbWVzc2FnZSBmcm9tIHRoaXMgY2hpbGRyZW46XG4gICAgICpcbiAgICAgKiBgPHAgaTE4bj1cIm1lYW5pbmd8ZGVzY3JpcHRpb25cIj57SUNVIG1lc3NhZ2V9PC9wPmAgd291bGQgcHJvZHVjZSB0d28gbWVzc2FnZXM6XG4gICAgICogLSBvbmUgZm9yIHRoZSA8cD4gY29udGVudCB3aXRoIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uLFxuICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSB0aGUgbGFzdCBtZXNzYWdlIGlzIGRpc2NhcmRlZCBhcyBpdCBjb250YWlucyBsZXNzIGluZm9ybWF0aW9uICh0aGUgQVNUIGlzXG4gICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2Ugc2hvdWxkIHN0aWxsIGtlZXAgbWVzc2FnZXMgZXh0cmFjdGVkIGZyb20gYXR0cmlidXRlcyBpbnNpZGUgdGhlIHNlY3Rpb24gKGllIGluIHRoZVxuICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RDaGlsZHJlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgZGlyZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50Q2hpbGRyZW4gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9tZXNzYWdlc1tpXS5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIShhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgVGV4dCQxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzT3BlbmluZ0NvbW1lbnQobikge1xuICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gbiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRJMThuQXR0cihwKSB7XG4gICAgcmV0dXJuIHAuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSOyB9KSB8fCBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGkxOG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9wYXJzZU1lc3NhZ2VNZXRhKGkxOG4pIHtcbiAgICBpZiAoIWkxOG4pXG4gICAgICAgIHJldHVybiB7IG1lYW5pbmc6ICcnLCBkZXNjcmlwdGlvbjogJycsIGlkOiAnJyB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkSW5kZXggPSBpMThuLmluZGV4T2YoSURfU0VQQVJBVE9SKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXNjSW5kZXggPSBpMThuLmluZGV4T2YoTUVBTklOR19TRVBBUkFUT1IpO1xuICAgIHZhciBfYSA9IChpZEluZGV4ID4gLTEpID8gW2kxOG4uc2xpY2UoMCwgaWRJbmRleCksIGkxOG4uc2xpY2UoaWRJbmRleCArIDIpXSA6IFtpMThuLCAnJ10sIG1lYW5pbmdBbmREZXNjID0gX2FbMF0sIGlkID0gX2FbMV07XG4gICAgdmFyIF9iID0gKGRlc2NJbmRleCA+IC0xKSA/XG4gICAgICAgIFttZWFuaW5nQW5kRGVzYy5zbGljZSgwLCBkZXNjSW5kZXgpLCBtZWFuaW5nQW5kRGVzYy5zbGljZShkZXNjSW5kZXggKyAxKV0gOlxuICAgICAgICBbJycsIG1lYW5pbmdBbmREZXNjXSwgbWVhbmluZyA9IF9iWzBdLCBkZXNjcmlwdGlvbiA9IF9iWzFdO1xuICAgIHJldHVybiB7IG1lYW5pbmc6IG1lYW5pbmcsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgaWQ6IGlkIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sVGFnRGVmaW5pdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQTtcbiAgICAgICAgdGhpcy5pc1ZvaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZ25vcmVGaXJzdExmID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50UGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgcmV0dXJuIFhtbFRhZ0RlZmluaXRpb247XG59KCkpO1xudmFyIF9UQUdfREVGSU5JVElPTiA9IG5ldyBYbWxUYWdEZWZpbml0aW9uKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0WG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIF9UQUdfREVGSU5JVElPTjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWxQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1sUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ2V0WG1sVGFnRGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IHBhcnNlRXhwYW5zaW9uRm9ybXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sUGFyc2VyO1xufShQYXJzZXIkMSkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuaWQgfHwgc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIChcIltcIiArIG1lc3NhZ2UubWVhbmluZyArIFwiXVwiKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuaWQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuaWQ7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBtZXNzYWdlLm5vZGVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS52aXNpdCh2aXNpdG9yLCBudWxsKTsgfSk7XG4gICAgcmV0dXJuIGNvbXB1dGVNc2dJZChwYXJ0cy5qb2luKCcnKSwgbWVzc2FnZS5tZWFuaW5nKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICpcbiAqIFRoZSB2aXNpdG9yIGlzIGFsc28gdXNlZCBpbiB0aGUgaTE4biBwYXJzZXIgdGVzdHNcbiAqXG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX1NlcmlhbGl6ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBpY3UuZXhwcmVzc2lvbiArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCI+XCIgKyBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIjwvcGggbmFtZT1cXFwiXCIgKyBwaC5jbG9zZU5hbWUgKyBcIlxcXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBoLnZhbHVlID8gXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUgKyBcIjwvcGg+XCIgOiBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCIvPlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gXCI8cGggaWN1IG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIj5cIiArIHBoLnZhbHVlLnZpc2l0KHRoaXMpICsgXCI8L3BoPlwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVyVmlzaXRvcjtcbn0oKSk7XG52YXIgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS52aXNpdChzZXJpYWxpemVyVmlzaXRvciwgbnVsbCk7IH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogSWdub3JlIHRoZSBJQ1UgZXhwcmVzc2lvbnMgc28gdGhhdCBtZXNzYWdlIElEcyBzdGF5cyBpZGVudGljYWwgaWYgb25seSB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzLlxuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgLy8gRG8gbm90IHRha2UgdGhlIGV4cHJlc3Npb24gaW50byBhY2NvdW50XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcjtcbn0oX1NlcmlhbGl6ZXJWaXNpdG9yKSk7XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBkZXNpZ25lZCBub3QgdGVzdGVkIHdpdGggc2VjdXJpdHkgaW4gbWluZC5cbiAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaGExKHN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4LCBFbmRpYW4uQmlnKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgdmFyIF9hID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdLCBhID0gX2FbMF0sIGIgPSBfYVsxXSwgYyA9IF9hWzJdLCBkID0gX2FbM10sIGUgPSBfYVs0XTtcbiAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIHZhciBfYiA9IFthLCBiLCBjLCBkLCBlXSwgaDAgPSBfYlswXSwgaDEgPSBfYlsxXSwgaDIgPSBfYlsyXSwgaDMgPSBfYlszXSwgaDQgPSBfYls0XTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBmayhqLCBiLCBjLCBkKSwgZiA9IF9jWzBdLCBrID0gX2NbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgX2QgPSBbZCwgYywgcm9sMzIoYiwgMzApLCBhLCB0ZW1wXSwgZSA9IF9kWzBdLCBkID0gX2RbMV0sIGMgPSBfZFsyXSwgYiA9IF9kWzNdLCBhID0gX2RbNF07XG4gICAgICAgIH1cbiAgICAgICAgX2UgPSBbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCBhID0gX2VbMF0sIGIgPSBfZVsxXSwgYyA9IF9lWzJdLCBkID0gX2VbM10sIGUgPSBfZVs0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0hleFN0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFthLCBiLCBjLCBkLCBlXSkpO1xuICAgIHZhciBfZCwgX2U7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gYlxuICogQHBhcmFtIHs/fSBjXG4gKiBAcGFyYW0gez99IGRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1dGY4ID0gdXRmOEVuY29kZShzdHIpO1xuICAgIHZhciBfYSA9IFtoYXNoMzIodXRmOCwgMCksIGhhc2gzMih1dGY4LCAxMDIwNzIpXSwgaGkgPSBfYVswXSwgbG8gPSBfYVsxXTtcbiAgICBpZiAoaGkgPT0gMCAmJiAobG8gPT0gMCB8fCBsbyA9PSAxKSkge1xuICAgICAgICBoaSA9IGhpIF4gMHgxMzBmOWJlZjtcbiAgICAgICAgbG8gPSBsbyBeIC0weDZiNWY1NmQ4O1xuICAgIH1cbiAgICByZXR1cm4gW2hpLCBsb107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbXNnXG4gKiBAcGFyYW0gez99IG1lYW5pbmdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNc2dJZChtc2csIG1lYW5pbmcpIHtcbiAgICB2YXIgX2EgPSBmaW5nZXJwcmludChtc2cpLCBoaSA9IF9hWzBdLCBsbyA9IF9hWzFdO1xuICAgIGlmIChtZWFuaW5nKSB7XG4gICAgICAgIHZhciBfYiA9IGZpbmdlcnByaW50KG1lYW5pbmcpLCBoaW0gPSBfYlswXSwgbG9tID0gX2JbMV07XG4gICAgICAgIF9jID0gYWRkNjQocm9sNjQoW2hpLCBsb10sIDEpLCBbaGltLCBsb21dKSwgaGkgPSBfY1swXSwgbG8gPSBfY1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFtoaSAmIDB4N2ZmZmZmZmYsIGxvXSkpO1xuICAgIHZhciBfYztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gY1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzaDMyKHN0ciwgYykge1xuICAgIHZhciBfYSA9IFsweDllMzc3OWI5LCAweDllMzc3OWI5XSwgYSA9IF9hWzBdLCBiID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgKyAxMiA8PSBsZW47IGkgKz0gMTIpIHtcbiAgICAgICAgYSA9IGFkZDMyKGEsIHdvcmRBdChzdHIsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIHdvcmRBdChzdHIsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoc3RyLCBpICsgOCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBfYiA9IG1peChbYSwgYiwgY10pLCBhID0gX2JbMF0sIGIgPSBfYlsxXSwgYyA9IF9iWzJdO1xuICAgIH1cbiAgICBhID0gYWRkMzIoYSwgd29yZEF0KHN0ciwgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoc3RyLCBpICsgNCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIC8vIHRoZSBmaXJzdCBieXRlIG9mIGMgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBsZW5ndGhcbiAgICBjID0gYWRkMzIoYywgbGVuKTtcbiAgICBjID0gYWRkMzIoYywgd29yZEF0KHN0ciwgaSArIDgsIEVuZGlhbi5MaXR0bGUpIDw8IDgpO1xuICAgIHJldHVybiBtaXgoW2EsIGIsIGNdKVsyXTtcbiAgICB2YXIgX2I7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXgoX2EpIHtcbiAgICB2YXIgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXTtcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgODtcbiAgICBjID0gc3ViMzIoYywgYSk7XG4gICAgYyA9IHN1YjMyKGMsIGIpO1xuICAgIGMgXj0gYiA+Pj4gMTM7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDEyO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDE2O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiA1O1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAzO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDEwO1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxNTtcbiAgICByZXR1cm4gW2EsIGIsIGNdO1xufVxudmFyIEVuZGlhbiA9IHt9O1xuRW5kaWFuLkxpdHRsZSA9IDA7XG5FbmRpYW4uQmlnID0gMTtcbkVuZGlhbltFbmRpYW4uTGl0dGxlXSA9IFwiTGl0dGxlXCI7XG5FbmRpYW5bRW5kaWFuLkJpZ10gPSBcIkJpZ1wiO1xuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkMzIoYSwgYikge1xuICAgIHJldHVybiBhZGQzMnRvNjQoYSwgYilbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBiXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhZGQzMnRvNjQoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSArIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4+IDE2KSArIChiID4+PiAxNikgKyAobG93ID4+PiAxNik7XG4gICAgcmV0dXJuIFtoaWdoID4+PiAxNiwgKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZildO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZDY0KF9hLCBfYikge1xuICAgIHZhciBhaCA9IF9hWzBdLCBhbCA9IF9hWzFdO1xuICAgIHZhciBiaCA9IF9iWzBdLCBibCA9IF9iWzFdO1xuICAgIHZhciBfYyA9IGFkZDMydG82NChhbCwgYmwpLCBjYXJyeSA9IF9jWzBdLCBsID0gX2NbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IGFkZDMyKGFkZDMyKGFoLCBiaCksIGNhcnJ5KTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ViMzIoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSAtIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4gMTYpIC0gKGIgPj4gMTYpICsgKGxvdyA+PiAxNik7XG4gICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gY291bnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcm9sNjQoX2EsIGNvdW50KSB7XG4gICAgdmFyIGhpID0gX2FbMF0sIGxvID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IChoaSA8PCBjb3VudCkgfCAobG8gPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbCA9IChsbyA8PCBjb3VudCkgfCAoaGkgPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgcmV0dXJuIFtoLCBsXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyLCBlbmRpYW4pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkczMyID0gQXJyYXkoKHN0ci5sZW5ndGggKyAzKSA+Pj4gMik7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZHMzMltpXSA9IHdvcmRBdChzdHIsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVBdChzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IHN0ci5sZW5ndGggPyAwIDogc3RyLmNoYXJDb2RlQXQoaW5kZXgpICYgMHhmZjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3b3JkQXQoc3RyLCBpbmRleCwgZW5kaWFuKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZCA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gRW5kaWFuLkJpZykge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgKDI0IC0gOCAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgOCAqIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gd29yZHMzMlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gd29yZHMzMlRvQnl0ZVN0cmluZyh3b3JkczMyKSB7XG4gICAgcmV0dXJuIHdvcmRzMzIucmVkdWNlKGZ1bmN0aW9uIChzdHIsIHdvcmQpIHsgcmV0dXJuIHN0ciArIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKTsgfSwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHdvcmRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgod29yZCA+Pj4gOCAqICgzIC0gaSkpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9IZXhTdHJpbmcoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGV4ID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiID0gYnl0ZUF0KHN0ciwgaSk7XG4gICAgICAgIGhleCArPSAoYiA+Pj4gNCkudG9TdHJpbmcoMTYpICsgKGIgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyhzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNpbWFsID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9UaGVQb3dlciA9ICcxJztcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGVjaW1hbCA9IGFkZEJpZ0ludChkZWNpbWFsLCBudW1iZXJUaW1lc0JpZ0ludChieXRlQXQoc3RyLCBpKSwgdG9UaGVQb3dlcikpO1xuICAgICAgICB0b1RoZVBvd2VyID0gbnVtYmVyVGltZXNCaWdJbnQoMjU2LCB0b1RoZVBvd2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWwuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB4XG4gKiBAcGFyYW0gez99IHlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZEJpZ0ludCh4LCB5KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIGNhcnJ5ID0gMDsgaSA8IGxlbiB8fCBjYXJyeTsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRtcFN1bSA9IGNhcnJ5ICsgKyh4W2ldIHx8IDApICsgKyh5W2ldIHx8IDApO1xuICAgICAgICBpZiAodG1wU3VtID49IDEwKSB7XG4gICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbnVtXG4gKiBAcGFyYW0gez99IGJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG51bWJlclRpbWVzQmlnSW50KG51bSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2R1Y3QgPSAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiVG9UaGVQb3dlciA9IGI7XG4gICAgZm9yICg7IG51bSAhPT0gMDsgbnVtID0gbnVtID4+PiAxKSB7XG4gICAgICAgIGlmIChudW0gJiAxKVxuICAgICAgICAgICAgcHJvZHVjdCA9IGFkZEJpZ0ludChwcm9kdWN0LCBiVG9UaGVQb3dlcik7XG4gICAgICAgIGJUb1RoZVBvd2VyID0gYWRkQmlnSW50KGJUb1RoZVBvd2VyLCBiVG9UaGVQb3dlcik7XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIGxvY2FsZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmNyZWF0ZU5hbWVNYXBwZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gU2VyaWFsaXplcjtcbn0oKSk7XG4vKipcbiAqIEEgc2ltcGxlIG1hcHBlciB0aGF0IHRha2UgYSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYW4gaW50ZXJuYWwgbmFtZSB0byBhIHB1YmxpYyBuYW1lXG4gKi9cbnZhciBTaW1wbGVQbGFjZWhvbGRlck1hcHBlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gbWFwTmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIG1hcE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWFwTmFtZSA9IG1hcE5hbWU7XG4gICAgICAgIF90aGlzLmludGVybmFsVG9QdWJsaWMgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9OZXh0SWQgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9JbnRlcm5hbCA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGludGVybmFsTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvUHVibGljTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHB1YmxpY05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS50b0ludGVybmFsTmFtZSA9IGZ1bmN0aW9uIChwdWJsaWNOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkgPyB0aGlzLnB1YmxpY1RvSW50ZXJuYWxbcHVibGljTmFtZV0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIuY2FsbCh0aGlzLCBwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkgeyB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcm5hbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwdWJsaWNOYW1lID0gdGhpcy5tYXBOYW1lKGludGVybmFsTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBYTUIgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRJZCA9IHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV07XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gbmV4dElkICsgMTtcbiAgICAgICAgICAgIHB1YmxpY05hbWUgPSBwdWJsaWNOYW1lICsgXCJfXCIgKyBuZXh0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWNbaW50ZXJuYWxOYW1lXSA9IHB1YmxpY05hbWU7XG4gICAgICAgIHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA9IGludGVybmFsTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcjtcbn0oUmVjdXJzZVZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLl9zZXJpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW25hbWVdICsgXCJcXFwiXCI7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2N0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICByZXR1cm4gXCI8IURPQ1RZUEUgXCIgKyBkb2N0eXBlLnJvb3RUYWcgKyBcIiBbXFxuXCIgKyBkb2N0eXBlLmR0ZCArIFwiXFxuXT5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQxO1xufSgpKTtcbnZhciBfdmlzaXRvciA9IG5ldyBfVmlzaXRvciQxKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbn1cbnZhciBEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJzW2tdID0gX2VzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7IH07XG4gICAgcmV0dXJuIERlY2xhcmF0aW9uO1xufSgpKTtcbnZhciBEb2N0eXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RUYWdcbiAgICAgKiBAcGFyYW0gez99IGR0ZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvY3R5cGUocm9vdFRhZywgZHRkKSB7XG4gICAgICAgIHRoaXMucm9vdFRhZyA9IHJvb3RUYWc7XG4gICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb2N0eXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RG9jdHlwZSh0aGlzKTsgfTtcbiAgICByZXR1cm4gRG9jdHlwZTtcbn0oKSk7XG52YXIgVGFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqIEBwYXJhbSB7Pz19IGNoaWxkcmVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFnKG5hbWUsIHVuZXNjYXBlZEF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodW5lc2NhcGVkQXR0cnMgPT09IHZvaWQgMCkgeyB1bmVzY2FwZWRBdHRycyA9IHt9OyB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUYWcucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWcodGhpcyk7IH07XG4gICAgcmV0dXJuIFRhZztcbn0oKSk7XG52YXIgVGV4dCQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVuZXNjYXBlZFZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dCQyKHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dCQyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGV4dCQyO1xufSgpKTtcbnZhciBDUiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENSLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1Iod3MpIHtcbiAgICAgICAgaWYgKHdzID09PSB2b2lkIDApIHsgd3MgPSAwOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlxcblwiICsgbmV3IEFycmF5KHdzICsgMSkuam9pbignICcpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ1I7XG59KFRleHQkMikpO1xudmFyIF9FU0NBUEVEX0NIQVJTID0gW1xuICAgIFsvJi9nLCAnJmFtcDsnXSxcbiAgICBbL1wiL2csICcmcXVvdDsnXSxcbiAgICBbLycvZywgJyZhcG9zOyddLFxuICAgIFsvPC9nLCAnJmx0OyddLFxuICAgIFsvPi9nLCAnJmd0OyddLFxuXTtcbi8qKlxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXNjYXBlWG1sKHRleHQpIHtcbiAgICByZXR1cm4gX0VTQ0FQRURfQ0hBUlMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBlbnRyeSkgeyByZXR1cm4gdGV4dC5yZXBsYWNlKGVudHJ5WzBdLCBlbnRyeVsxXSk7IH0sIHRleHQpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9WRVJTSU9OID0gJzEuMic7XG52YXIgX1hNTE5TID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbnZhciBfREVGQVVMVF9TT1VSQ0VfTEFORyA9ICdlbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyA9ICd4JztcbnZhciBfRklMRV9UQUcgPSAnZmlsZSc7XG52YXIgX1NPVVJDRV9UQUcgPSAnc291cmNlJztcbnZhciBfVEFSR0VUX1RBRyA9ICd0YXJnZXQnO1xudmFyIF9VTklUX1RBRyA9ICd0cmFucy11bml0JztcbnZhciBYbGlmZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhsaWZmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhsaWZmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IG1lc3NhZ2UuaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUcsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig4KSwgbmV3IFRhZyhfVEFSR0VUX1RBRykpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgdHJhbnNVbml0cy5jb25jYXQoW25ldyBDUig0KV0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7XG4gICAgICAgICAgICAnc291cmNlLWxhbmd1YWdlJzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HLFxuICAgICAgICAgICAgZGF0YXR5cGU6ICdwbGFpbnRleHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnLFxuICAgICAgICB9LCBbbmV3IENSKDQpLCBib2R5LCBuZXcgQ1IoMildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHhsaWZmIHRvIHhtbCBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bGlmZlBhcnNlciA9IG5ldyBYbGlmZlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIG1sTm9kZXNCeU1zZ0lkID0gX2EubWxOb2Rlc0J5TXNnSWQsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1sTm9kZXNCeU1zZ0lkKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobWxOb2Rlc0J5TXNnSWRbbXNnSWRdKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBlKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInhsaWZmIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiBsb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQ6IGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QobWVzc2FnZSk7IH07XG4gICAgcmV0dXJuIFhsaWZmO1xufShTZXJpYWxpemVyKSk7XG52YXIgX1dyaXRlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZS52aXNpdChfdGhpcykpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4bGlmZiBkb2VzIG5vdCBzdXBwb3J0IG5lc3RlZCBJQ1UgbWVzc2FnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0luSWN1ID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogc3VwcG9ydCBJQ1UgbWVzc2FnZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9saXN0cy5vYXNpcy1vcGVuLm9yZy9hcmNoaXZlcy94bGlmZi8yMDEyMDEvbXNnMDAwMjguaHRtbFxuICAgICAgICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL3hsaWZmLXByb2ZpbGUtcG8veGxpZmYtcHJvZmlsZS1wby0xLjItY2QwMi5odG1sXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5jbG9zZU5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG59KCkpO1xudmFyIFhsaWZmUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbGlmZlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4bGlmZlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeGxpZmYsIHVybCkge1xuICAgICAgICB0aGlzLl91bml0TWxOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9tbE5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeGxpZmYsIHVybCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1sTm9kZXNCeU1zZ0lkOiB0aGlzLl9tbE5vZGVzQnlNc2dJZCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sTm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tbE5vZGVzQnlNc2dJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VuaXRNbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWxOb2Rlc0J5TXNnSWRbaWRdID0gdGhpcy5fdW5pdE1sTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIk1lc3NhZ2UgXCIgKyBpZCArIFwiIG1pc3NlcyBhIHRyYW5zbGF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfU09VUkNFX1RBRzpcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RBUkdFVF9UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sTm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfRklMRV9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAndGFyZ2V0LWxhbmd1YWdlJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCBmaWxlIHN0cnVjdHVyZSwgeGxpZmYgdmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgb25seSByZWN1cnNlIG9uIHVuaGFuZGxlZCBub2Rlc1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZlBhcnNlcjtcbn0oKSk7XG52YXIgWG1sVG9JMThuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogdmlzaXRBbGwodGhpcywgbm9kZXMpLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFRvSTE4bjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRDdHlwZUZvclRhZyh0YWcpIHtcbiAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgIHJldHVybiAnbGInO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJ4LVwiICsgdGFnO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVkVSU0lPTiQxID0gJzIuMCc7XG52YXIgX1hNTE5TJDEgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjIuMCc7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxudmFyIF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgPSAnZW4nO1xudmFyIF9QTEFDRUhPTERFUl9UQUckMSA9ICdwaCc7XG52YXIgX1BMQUNFSE9MREVSX1NQQU5OSU5HX1RBRyA9ICdwYyc7XG52YXIgX1hMSUZGX1RBRyA9ICd4bGlmZic7XG52YXIgX1NPVVJDRV9UQUckMSA9ICdzb3VyY2UnO1xudmFyIF9UQVJHRVRfVEFHJDEgPSAndGFyZ2V0JztcbnZhciBfVU5JVF9UQUckMSA9ICd1bml0JztcbnZhciBYbGlmZjIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbGlmZjIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGxpZmYyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvciQxKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXRzID0gW107XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSBuZXcgVGFnKF9VTklUX1RBRyQxLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gfHwgbWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90ZXMgPSBuZXcgVGFnKCdub3RlcycpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgY2F0ZWdvcnk6ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMihtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgbm90ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnbWVudCA9IG5ldyBUYWcoJ3NlZ21lbnQnKTtcbiAgICAgICAgICAgIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUckMSwge30sIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKSwgbmV3IENSKDYpKTtcbiAgICAgICAgICAgIHVuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNiksIHNlZ21lbnQsIG5ldyBDUig0KSk7XG4gICAgICAgICAgICB1bml0cy5wdXNoKG5ldyBDUig0KSwgdW5pdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlID0gbmV3IFRhZygnZmlsZScsIHsgJ29yaWdpbmFsJzogJ25nLnRlbXBsYXRlJywgaWQ6ICduZ2kxOG4nIH0sIHVuaXRzLmNvbmNhdChbbmV3IENSKDIpXSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bGlmZiA9IG5ldyBUYWcoX1hMSUZGX1RBRywgeyB2ZXJzaW9uOiBfVkVSU0lPTiQxLCB4bWxuczogX1hNTE5TJDEsIHNyY0xhbmc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyQxIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLCBuZXcgQ1IoKSwgeGxpZmYsIG5ldyBDUigpXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhsaWZmMlBhcnNlciA9IG5ldyBYbGlmZjJQYXJzZXIoKTtcbiAgICAgICAgdmFyIF9hID0geGxpZmYyUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBlKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInhsaWZmMiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogLyoqIEB0eXBlIHs/fSAqLyAoKGxvY2FsZSkpLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7IH07XG4gICAgcmV0dXJuIFhsaWZmMjtcbn0oU2VyaWFsaXplcikpO1xudmFyIF9Xcml0ZVZpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZS52aXNpdChfdGhpcykpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgW25ldyBUZXh0JDIoYyArIFwiIHtcIildLmNvbmNhdChpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IGdldFR5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlcXVpdjogcGguc3RhcnROYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGlzcDogXCI8XCIgKyBwaC50YWcgKyBcIi8+XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbdGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ1BjID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHLCB7XG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBlcXVpdlN0YXJ0OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICBlcXVpdkVuZDogcGguY2xvc2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRpc3BTdGFydDogXCI8XCIgKyBwaC50YWcgKyBcIj5cIixcbiAgICAgICAgICAgIGRpc3BFbmQ6IFwiPC9cIiArIHBoLnRhZyArIFwiPlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGFnUGMuY2hpbGRyZW4ucHVzaChub2RlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YWdQYy5jaGlsZHJlbi5wdXNoKG5ldyBUZXh0JDIoJycpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RhZ1BjXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlcXVpdjogcGgubmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwOiBcInt7XCIgKyBwaC52YWx1ZSArIFwifX1cIixcbiAgICAgICAgICAgIH0pXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCkgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvciQxLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmV4dFBsYWNlaG9sZGVySWQgPSAwO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1dyaXRlVmlzaXRvciQxO1xufSgpKTtcbnZhciBYbGlmZjJQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhsaWZmMlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4bGlmZlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2RlcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRyQxOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIkR1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5pdE1sU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IHRoaXMuX3VuaXRNbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiTWVzc2FnZSBcIiArIGlkICsgXCIgbWlzc2VzIGEgdHJhbnNsYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHJDE6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0U3RhcnQgPSAoKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSkuZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHRFbmQgPSAoKGVsZW1lbnQuZW5kU291cmNlU3BhbikpLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gKChlbGVtZW50LnN0YXJ0U291cmNlU3BhbikpLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1hMSUZGX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbGVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICd0cmdMYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmVyc2lvbkF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3ZlcnNpb24nOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmVyc2lvbiA9IHZlcnNpb25BdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gJzIuMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiVGhlIFhMSUZGIGZpbGUgdmVyc2lvbiBcIiArIHZlcnNpb24gKyBcIiBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFhMSUZGIDIuMCBzZXJpYWxpemVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvbkNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZjJQYXJzZXI7XG59KCkpO1xudmFyIFhtbFRvSTE4biQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4kMSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6IFtdLmNvbmNhdC5hcHBseShbXSwgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2RlcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGVsLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1BMQUNFSE9MREVSX1RBRyQxOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXYnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCBlbC5zb3VyY2VTcGFuKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdlxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmRBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXZFbmQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiZXF1aXZTdGFydFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZW5kQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiZXF1aXZFbmRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0SWQgPSBzdGFydEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZElkID0gZW5kQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzLmNvbmNhdC5hcHBseShub2RlcywgW25ldyBQbGFjZWhvbGRlcignJywgc3RhcnRJZCwgZWwuc291cmNlU3BhbildLmNvbmNhdChlbC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KSwgW25ldyBQbGFjZWhvbGRlcignJywgZW5kSWQsIGVsLnNvdXJjZVNwYW4pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLmNvbmNhdC5hcHBseShbXSwgdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG4kMTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfTUVTU0FHRVNfVEFHID0gJ21lc3NhZ2VidW5kbGUnO1xudmFyIF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xudmFyIF9QTEFDRUhPTERFUl9UQUckMiA9ICdwaCc7XG52YXIgX0VYRU1QTEVfVEFHID0gJ2V4JztcbnZhciBfRE9DVFlQRSA9IFwiPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxcbjwhQVRUTElTVCBtZXNzYWdlYnVuZGxlIGNsYXNzIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XFxuPCFBVFRMSVNUIG1zZyBpZCBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBkZXNjIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyB4bWw6c3BhY2UgKGRlZmF1bHR8cHJlc2VydmUpIFxcXCJkZWZhdWx0XFxcIj5cXG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cXG5cXG48IUVMRU1FTlQgcGggKCNQQ0RBVEF8ZXgpKj5cXG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XFxuXFxuPCFFTEVNRU5UIGV4ICgjUENEQVRBKT5cIjtcbnZhciBYbWIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBleGFtcGxlVmlzaXRvci5hZGREZWZhdWx0RXhhbXBsZXMocm9vdE5vZGUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfVmlzaXRvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRFeCA9IG5ldyBUYWcoX0VYRU1QTEVfVEFHLCB7fSwgW25ldyBUZXh0JDIoXCI8XCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaWdlc3QkMShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG59XG52YXIgRXhhbXBsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS5hZGREZWZhdWx0RXhhbXBsZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQyKSB7XG4gICAgICAgICAgICBpZiAoIXRhZy5jaGlsZHJlbiB8fCB0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleFRleHQgPSBuZXcgVGV4dCQyKHRhZy5hdHRyc1snbmFtZSddIHx8ICcuLi4nKTtcbiAgICAgICAgICAgICAgICB0YWcuY2hpbGRyZW4gPSBbbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbZXhUZXh0XSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGFnLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3R5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkgeyB9O1xuICAgIHJldHVybiBFeGFtcGxlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW50ZXJuYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b1B1YmxpY05hbWUoaW50ZXJuYWxOYW1lKSB7XG4gICAgcmV0dXJuIGludGVybmFsTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aMC05X10vZywgJ18nKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG52YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbnZhciBYdGIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYdGIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWHRiKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4dGIgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHh0YlBhcnNlciA9IG5ldyBYdGJQYXJzZXIoKTtcbiAgICAgICAgdmFyIF9hID0geHRiUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMigpO1xuICAgICAgICAvLyBCZWNhdXNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgeHRiIGZpbGVzIHRoYXQgcmVseSBvbiBmZWF0dXJlcyBub3Qgc3VwcG9ydGVkIGJ5IGFuZ3VsYXIsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGNvbnZlcnNpb24gb2YgaHRtbCB0byBpMThuIG5vZGVzIHNvIHRoYXQgbm9uIGFuZ3VsYXIgbWVzc2FnZXMgYXJlIG5vdFxuICAgICAgICAvLyBjb252ZXJ0ZWRcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpMThuTm9kZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3JlYXRlTGF6eVByb3BlcnR5KGkxOG5Ob2Rlc0J5TXNnSWQsIG1zZ0lkLCB2YWx1ZUZuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0Yi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYdGI7XG59KFNlcmlhbGl6ZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/fSB2YWx1ZUZuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJvcGVydHkobWVzc2FnZXMsIGlkLCB2YWx1ZUZuKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoXykgeyB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvdmVyd3JpdGUgYW4gWFRCIHRyYW5zbGF0aW9uJyk7IH0sXG4gICAgfSk7XG59XG52YXIgWHRiUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYdGJQYXJzZXIoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geHRiXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeHRiLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICAvLyBXZSBjYW4gbm90IHBhcnNlIHRoZSBJQ1UgbWVzc2FnZXMgYXQgdGhpcyBwb2ludCBhcyBzb21lIG1lc3NhZ2VzIG1pZ2h0IG5vdCBvcmlnaW5hdGVcbiAgICAgICAgLy8gZnJvbSBBbmd1bGFyIHRoYXQgY291bGQgbm90IGJlIGxleCdkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeHRiLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2J1bmRsZURlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTlNfVEFHICsgXCI+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYW5nQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbGFuZyc7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsYW5nQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05fVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0RW5kID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCAnVW5leHBlY3RlZCB0YWcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiUGFyc2VyO1xufSgpKTtcbnZhciBYbWxUb0kxOG4kMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sVG9JMThuJDIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpMThuTm9kZXM6IGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQzICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG4kMjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbFBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdldEh0bWxUYWdEZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFBhcnNlcjtcbn0oUGFyc2VyJDEpKTtcbkh0bWxQYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuSHRtbFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgdHJhbnNsYXRlZCBtZXNzYWdlc1xuICovXG52YXIgVHJhbnNsYXRpb25CdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pMThuTm9kZXNCeU1zZ0lkXG4gICAgICogQHBhcmFtIHs/PX0gbG9jYWxlXG4gICAgICogQHBhcmFtIHs/PX0gZGlnZXN0XG4gICAgICogQHBhcmFtIHs/PX0gbWFwcGVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHs/PX0gY29uc29sZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zbGF0aW9uQnVuZGxlKF9pMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKF9pMThuTm9kZXNCeU1zZ0lkID09PSB2b2lkIDApIHsgX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fTsgfVxuICAgICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IHZvaWQgMCkgeyBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdGhpcy5tYXBwZXJGYWN0b3J5ID0gbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5faTE4blRvSHRtbCA9IG5ldyBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3QsIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IHNlcmlhbGl6ZXJcbiAgICAgKiBAcGFyYW0gez99IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHs/PX0gY29uc29sZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNsYXRpb25CdW5kbGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIHNlcmlhbGl6ZXIsIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKSB7XG4gICAgICAgIHZhciBfYSA9IHNlcmlhbGl6ZXIubG9hZChjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQgPSBfYS5pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaWdlc3RGbiA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmRpZ2VzdChtKTsgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobSk7IH07XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3RGbiwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSB0aGlzLl9pMThuVG9IdG1sLmNvbnZlcnQoc3JjTXNnKTtcbiAgICAgICAgaWYgKGh0bWwuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGh0bWwuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5ub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjTXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHNyY01zZykgeyByZXR1cm4gdGhpcy5kaWdlc3Qoc3JjTXNnKSBpbiB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkOyB9O1xuICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbn0oKSk7XG52YXIgSTE4blRvSHRtbFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pMThuTm9kZXNCeU1zZ0lkXG4gICAgICogQHBhcmFtIHs/PX0gX2xvY2FsZVxuICAgICAqIEBwYXJhbSB7Pz19IF9kaWdlc3RcbiAgICAgKiBAcGFyYW0gez89fSBfbWFwcGVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuICAgICAqIEBwYXJhbSB7Pz19IF9jb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIF9sb2NhbGUsIF9kaWdlc3QsIF9tYXBwZXJGYWN0b3J5LCBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIF9jb25zb2xlKSB7XG4gICAgICAgIGlmIChfaTE4bk5vZGVzQnlNc2dJZCA9PT0gdm9pZCAwKSB7IF9pMThuTm9kZXNCeU1zZ0lkID0ge307IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIGkxOG4gdG8gdGV4dFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0ID0gdGhpcy5fY29udmVydFRvVGV4dChzcmNNc2cpO1xuICAgICAgICAvLyB0ZXh0IHRvIGh0bWxcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gc3JjTXNnLm5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSBuZXcgSHRtbFBhcnNlcigpLnBhcnNlKHRleHQsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogaHRtbC5yb290Tm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycy5jb25jYXQoaHRtbC5lcnJvcnMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBPbmNlIGFsbCBmb3JtYXQgc3dpdGNoIHRvIHVzaW5nIGV4cHJlc3Npb24gcGxhY2Vob2xkZXJzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aHJvdyB3aGVuIHRoZSBwbGFjZWhvbGRlciBpcyBub3QgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cCA9IHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkoaWN1LmV4cHJlc3Npb24pID9cbiAgICAgICAgICAgIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbaWN1LmV4cHJlc3Npb25dIDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHAgKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIGNhc2VzLmpvaW4oJyAnKSArIFwifVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoTmFtZSA9IHRoaXMuX21hcHBlcihwaC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbcGhOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgXCJVbmtub3duIHBsYWNlaG9sZGVyIFxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWcgPSBcIlwiICsgcGgudGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IE9iamVjdC5rZXlzKHBoLmF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIj1cXFwiXCIgKyBwaC5hdHRyc1tuYW1lXSArIFwiXFxcIlwiOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZyArIFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiPlwiICsgY2hpbGRyZW4gKyBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHNvdXJjZSBtZXNzYWdlIHRvIGEgdHJhbnNsYXRlZCB0ZXh0IHN0cmluZzpcbiAgICAgKiAtIHRleHQgbm9kZXMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgdHJhbnNsYXRpb24sXG4gICAgICogLSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgY29udGVudCxcbiAgICAgKiAtIElDVSBub2RlcyBhcmUgY29udmVydGVkIHRvIElDVSBleHByZXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHNyY01zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLl9jb252ZXJ0VG9UZXh0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5wdXNoKHsgbXNnOiB0aGlzLl9zcmNNc2csIG1hcHBlcjogdGhpcy5fbWFwcGVyIH0pO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBzcmNNc2c7XG4gICAgICAgIGlmICh0aGlzLl9pMThuTm9kZXNCeU1zZ0lkLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhIHRyYW5zbGF0aW9uIHVzZSBpdHMgbm9kZXMgYXMgdGhlIHNvdXJjZVxuICAgICAgICAgICAgLy8gQW5kIGNyZWF0ZSBhIG1hcHBlciB0byBjb252ZXJ0IHNlcmlhbGl6ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gaW50ZXJuYWwgbmFtZXNcbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5faTE4bk5vZGVzQnlNc2dJZFtpZF07XG4gICAgICAgICAgICB0aGlzLl9tYXBwZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWFwcGVyID8gbWFwcGVyLnRvSW50ZXJuYWxOYW1lKG5hbWUpIDogbmFtZTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbm8gdHJhbnNsYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgIC8vIC0gcmVwb3J0IGFuIGVycm9yIC8gYSB3YXJuaW5nIC8gbm90aGluZyxcbiAgICAgICAgICAgIC8vIC0gdXNlIHRoZSBub2RlcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gICAgICAgICAgICAvLyAtIHBsYWNlaG9sZGVycyBhcmUgYWxyZWFkeSBpbnRlcm5hbCBhbmQgbmVlZCBubyBtYXBwZXJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb25zb2xlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcXFwiXCIgKyBpZCArIFwiXFxcIlwiICsgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBjb250ZXh0Lm1zZztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gY29udGV4dC5tYXBwZXI7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKGVsLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihlbC5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9O1xuICAgIHJldHVybiBJMThuVG9IdG1sVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSTE4Tkh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNGb3JtYXRcbiAgICAgKiBAcGFyYW0gez89fSBtaXNzaW5nVHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gSTE4Tkh0bWxQYXJzZXIoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKG1pc3NpbmdUcmFuc2xhdGlvbiA9PT0gdm9pZCAwKSB7IG1pc3NpbmdUcmFuc2xhdGlvbiA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBwYXJzZUV4cGFuc2lvbkZvcm1zXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4Tkh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGVuYWJsZSBpMThuIHdoZW4gbm8gdHJhbnNsYXRpb24gYnVuZGxlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgcGFyc2VSZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VUcmFuc2xhdGlvbnMocGFyc2VSZXN1bHQucm9vdE5vZGVzLCB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgW10sIHt9KTtcbiAgICB9O1xuICAgIHJldHVybiBJMThOSHRtbFBhcnNlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7Pz19IGZvcm1hdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYyJzpcbiAgICAgICAgY2FzZSAneGxmMic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMigpO1xuICAgICAgICBjYXNlICd4bGlmZic6XG4gICAgICAgIGNhc2UgJ3hsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENPUkUgPSBhc3NldFVybCgnY29yZScpO1xudmFyIElkZW50aWZpZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJZGVudGlmaWVycygpIHtcbiAgICB9XG4gICAgcmV0dXJuIElkZW50aWZpZXJzO1xufSgpKTtcbklkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSB7XG4gICAgbmFtZTogJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnLFxuICAgIG1vZHVsZVVybDogQ09SRSxcbiAgICBydW50aW1lOiBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTXG59O1xuSWRlbnRpZmllcnMuRWxlbWVudFJlZiA9IHsgbmFtZTogJ0VsZW1lbnRSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IEVsZW1lbnRSZWYgfTtcbklkZW50aWZpZXJzLk5nTW9kdWxlUmVmID0geyBuYW1lOiAnTmdNb2R1bGVSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IE5nTW9kdWxlUmVmIH07XG5JZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmID0geyBuYW1lOiAnVmlld0NvbnRhaW5lclJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogVmlld0NvbnRhaW5lclJlZiB9O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSB7IG5hbWU6ICdDaGFuZ2VEZXRlY3RvclJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfTtcbklkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHsgbmFtZTogJ1F1ZXJ5TGlzdCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogUXVlcnlMaXN0IH07XG5JZGVudGlmaWVycy5UZW1wbGF0ZVJlZiA9IHsgbmFtZTogJ1RlbXBsYXRlUmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBUZW1wbGF0ZVJlZiB9O1xuSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICBuYW1lOiAnybVDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogybVDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgIG1vZHVsZVVybDogQ09SRSxcbiAgICBydW50aW1lOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbn07XG5JZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnQ29tcG9uZW50RmFjdG9yeScsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogQ29tcG9uZW50RmFjdG9yeSB9O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50UmVmID0geyBuYW1lOiAnQ29tcG9uZW50UmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBDb21wb25lbnRSZWYgfTtcbklkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSA9IHsgbmFtZTogJ05nTW9kdWxlRmFjdG9yeScsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogTmdNb2R1bGVGYWN0b3J5IH07XG5JZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yID0ge1xuICAgIG5hbWU6ICfJtU5nTW9kdWxlSW5qZWN0b3InLFxuICAgIG1vZHVsZVVybDogQ09SRSxcbiAgICBydW50aW1lOiDJtU5nTW9kdWxlSW5qZWN0b3IsXG59O1xuSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4gPSB7XG4gICAgbmFtZTogJ8m1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5JyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogybVyZWdpc3Rlck1vZHVsZUZhY3RvcnksXG59O1xuSWRlbnRpZmllcnMuSW5qZWN0b3IgPSB7IG5hbWU6ICdJbmplY3RvcicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogSW5qZWN0b3IgfTtcbklkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0geyBuYW1lOiAnVmlld0VuY2Fwc3VsYXRpb24nLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFZpZXdFbmNhcHN1bGF0aW9uIH07XG5JZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3knLFxuICAgIG1vZHVsZVVybDogQ09SRSxcbiAgICBydW50aW1lOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxufTtcbklkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCA9IHtcbiAgICBuYW1lOiAnU2VjdXJpdHlDb250ZXh0JyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogU2VjdXJpdHlDb250ZXh0LFxufTtcbklkZW50aWZpZXJzLkxPQ0FMRV9JRCA9IHsgbmFtZTogJ0xPQ0FMRV9JRCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogTE9DQUxFX0lEIH07XG5JZGVudGlmaWVycy5UUkFOU0xBVElPTlNfRk9STUFUID0geyBuYW1lOiAnVFJBTlNMQVRJT05TX0ZPUk1BVCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogVFJBTlNMQVRJT05TX0ZPUk1BVCB9O1xuSWRlbnRpZmllcnMuaW5saW5lSW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtWlubGluZUludGVycG9sYXRlJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWlubGluZUludGVycG9sYXRlIH07XG5JZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1aW50ZXJwb2xhdGUnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1aW50ZXJwb2xhdGUgfTtcbklkZW50aWZpZXJzLkVNUFRZX0FSUkFZID0geyBuYW1lOiAnybVFTVBUWV9BUlJBWScsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVFTVBUWV9BUlJBWSB9O1xuSWRlbnRpZmllcnMuRU1QVFlfTUFQID0geyBuYW1lOiAnybVFTVBUWV9NQVAnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1RU1QVFlfTUFQIH07XG5JZGVudGlmaWVycy5SZW5kZXJlciA9IHsgbmFtZTogJ1JlbmRlcmVyJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBSZW5kZXJlciB9O1xuSWRlbnRpZmllcnMudmlld0RlZiA9IHsgbmFtZTogJ8m1dmlkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXZpZCB9O1xuSWRlbnRpZmllcnMuZWxlbWVudERlZiA9IHsgbmFtZTogJ8m1ZWxkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWVsZCB9O1xuSWRlbnRpZmllcnMuYW5jaG9yRGVmID0geyBuYW1lOiAnybVhbmQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1YW5kIH07XG5JZGVudGlmaWVycy50ZXh0RGVmID0geyBuYW1lOiAnybV0ZWQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1dGVkIH07XG5JZGVudGlmaWVycy5kaXJlY3RpdmVEZWYgPSB7IG5hbWU6ICfJtWRpZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVkaWQgfTtcbklkZW50aWZpZXJzLnByb3ZpZGVyRGVmID0geyBuYW1lOiAnybVwcmQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1cHJkIH07XG5JZGVudGlmaWVycy5xdWVyeURlZiA9IHsgbmFtZTogJ8m1cXVkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXF1ZCB9O1xuSWRlbnRpZmllcnMucHVyZUFycmF5RGVmID0geyBuYW1lOiAnybVwYWQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1cGFkIH07XG5JZGVudGlmaWVycy5wdXJlT2JqZWN0RGVmID0geyBuYW1lOiAnybVwb2QnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1cG9kIH07XG5JZGVudGlmaWVycy5wdXJlUGlwZURlZiA9IHsgbmFtZTogJ8m1cHBkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBwZCB9O1xuSWRlbnRpZmllcnMucGlwZURlZiA9IHsgbmFtZTogJ8m1cGlkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBpZCB9O1xuSWRlbnRpZmllcnMubm9kZVZhbHVlID0geyBuYW1lOiAnybVub3YnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1bm92IH07XG5JZGVudGlmaWVycy5uZ0NvbnRlbnREZWYgPSB7IG5hbWU6ICfJtW5jZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVuY2QgfTtcbklkZW50aWZpZXJzLnVud3JhcFZhbHVlID0geyBuYW1lOiAnybV1bnYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1dW52IH07XG5JZGVudGlmaWVycy5jcmVhdGVSZW5kZXJlclR5cGUyID0geyBuYW1lOiAnybVjcnQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1Y3J0IH07XG5JZGVudGlmaWVycy5SZW5kZXJlclR5cGUyID0ge1xuICAgIG5hbWU6ICdSZW5kZXJlclR5cGUyJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgLy8gdHlwZSBvbmx5XG4gICAgcnVudGltZTogbnVsbFxufTtcbklkZW50aWZpZXJzLlZpZXdEZWZpbml0aW9uID0ge1xuICAgIG5hbWU6ICfJtVZpZXdEZWZpbml0aW9uJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgLy8gdHlwZSBvbmx5XG4gICAgcnVudGltZTogbnVsbFxufTtcbklkZW50aWZpZXJzLmNyZWF0ZUNvbXBvbmVudEZhY3RvcnkgPSB7IG5hbWU6ICfJtWNjZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVjY2YgfTtcbi8qKlxuICogQHBhcmFtIHs/fSBwa2dcbiAqIEBwYXJhbSB7Pz19IHBhdGhcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2V0VXJsKHBrZywgcGF0aCwgdHlwZSkge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSAnc3JjJzsgfVxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiQGFuZ3VsYXIvXCIgKyBwa2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJAYW5ndWxhci9cIiArIHBrZyArIFwiL1wiICsgdHlwZSArIFwiL1wiICsgcGF0aDtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBpZGVudGlmaWVyLm5hbWU7XG4gICAgcmV0dXJuIMm1cmVmbGVjdG9yLnJlc29sdmVJZGVudGlmaWVyKG5hbWUsIGlkZW50aWZpZXIubW9kdWxlVXJsLCBudWxsLCBpZGVudGlmaWVyLnJ1bnRpbWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB7IHJlZmVyZW5jZTogcmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllcikgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcikge1xuICAgIHJldHVybiB7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyVG9rZW4oY3JlYXRlSWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZW51bVR5cGVcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gaHR0cDovL2NsZHIudW5pY29kZS5vcmcvaW5kZXgvY2xkci1zcGVjL3BsdXJhbC1ydWxlc1xudmFyIFBMVVJBTF9DQVNFUyA9IFsnemVybycsICdvbmUnLCAndHdvJywgJ2ZldycsICdtYW55JywgJ290aGVyJ107XG4vKipcbiAqIEV4cGFuZHMgc3BlY2lhbCBmb3JtcyBpbnRvIGVsZW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICpcbiAqIGBgYFxuICogeyBtZXNzYWdlcy5sZW5ndGgsIHBsdXJhbCxcbiAqICAgPTAge3plcm99XG4gKiAgID0xIHtvbmV9XG4gKiAgIG90aGVyIHttb3JlIHRoYW4gb25lfVxuICogfVxuICogYGBgXG4gKlxuICogd2lsbCBiZSBleHBhbmRlZCBpbnRvXG4gKlxuICogYGBgXG4gKiA8bmctY29udGFpbmVyIFtuZ1BsdXJhbF09XCJtZXNzYWdlcy5sZW5ndGhcIj5cbiAqICAgPG5nLXRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0wXCI+emVybzwvbmctdGVtcGxhdGU+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MVwiPm9uZTwvbmctdGVtcGxhdGU+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCJvdGhlclwiPm1vcmUgdGhhbiBvbmU8L25nLXRlbXBsYXRlPlxuICogPC9uZy1jb250YWluZXI+XG4gKiBgYGBcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZE5vZGVzKG5vZGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5kZXIgPSBuZXcgX0V4cGFuZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBFeHBhbnNpb25SZXN1bHQodmlzaXRBbGwoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbn1cbnZhciBFeHBhbnNpb25SZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuZGVkXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb25SZXN1bHQobm9kZXMsIGV4cGFuZGVkLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gRXhwYW5zaW9uUmVzdWx0O1xufSgpKTtcbnZhciBFeHBhbnNpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JNc2dcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb25FcnJvcihzcGFuLCBlcnJvck1zZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBFeHBhbnNpb25FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xuLyoqXG4gKiBFeHBhbmQgZXhwYW5zaW9uIGZvcm1zIChwbHVyYWwsIHNlbGVjdCkgdG8gZGlyZWN0aXZlc1xuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfRXhwYW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9FeHBhbmRlcigpIHtcbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJzLCB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyByZXR1cm4gYXR0cmlidXRlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIGNvbW1lbnQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBpY3UudHlwZSA9PSAncGx1cmFsJyA/IF9leHBhbmRQbHVyYWxGb3JtKGljdSwgdGhpcy5lcnJvcnMpIDpcbiAgICAgICAgICAgIF9leHBhbmREZWZhdWx0Rm9ybShpY3UsIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYmUgcmVhY2hlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIF9FeHBhbmRlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZFBsdXJhbEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKFBMVVJBTF9DQVNFUy5pbmRleE9mKGMudmFsdWUpID09IC0xICYmICFjLnZhbHVlLm1hdGNoKC9ePVxcZCskLykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoXCJuZy10ZW1wbGF0ZVwiLCBbbmV3IEF0dHJpYnV0ZSQxKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzd2l0Y2hBdHRyID0gbmV3IEF0dHJpYnV0ZSQxKCdbbmdQbHVyYWxdJywgYXN0LnN3aXRjaFZhbHVlLCBhc3Quc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHBhbmREZWZhdWx0Rm9ybShhc3QsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBhbnNpb25SZXN1bHQgPSBleHBhbmROb2RlcyhjLmV4cHJlc3Npb24pO1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICBpZiAoYy52YWx1ZSA9PT0gJ290aGVyJykge1xuICAgICAgICAgICAgLy8gb3RoZXIgaXMgdGhlIGRlZmF1bHQgY2FzZSB3aGVuIG5vIHZhbHVlcyBtYXRjaFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hEZWZhdWx0JywgJycsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hDYXNlJywgXCJcIiArIGMudmFsdWUsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlckVycm9yKG1lc3NhZ2UsIHNwYW4pIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQcm92aWRlckVycm9yO1xufShQYXJzZUVycm9yKSk7XG52YXIgUHJvdmlkZXJWaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IF9nZXRWaWV3UXVlcmllcyhjb21wb25lbnQpO1xuICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbXBvbmVudC52aWV3UHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudmlld1Byb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlld1Byb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm92aWRlclZpZXdDb250ZXh0O1xufSgpKTtcbnZhciBQcm92aWRlckVsZW1lbnRDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBfcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBfaXNWaWV3Um9vdFxuICAgICAqIEBwYXJhbSB7P30gX2RpcmVjdGl2ZUFzdHNcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSByZWZzXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50UXVlcnlTdGFydElkXG4gICAgICogQHBhcmFtIHs/fSBfc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyRWxlbWVudENvbnRleHQodmlld0NvbnRleHQsIF9wYXJlbnQsIF9pc1ZpZXdSb290LCBfZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZnMsIGlzVGVtcGxhdGUsIGNvbnRlbnRRdWVyeVN0YXJ0SWQsIF9zb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlld0NvbnRleHQgPSB2aWV3Q29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5faXNWaWV3Um9vdCA9IF9pc1ZpZXdSb290O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVBc3RzID0gX2RpcmVjdGl2ZUFzdHM7XG4gICAgICAgIHRoaXMuX3NvdXJjZVNwYW4gPSBfc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcXVlcmllZFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0cnMgPSB7fTtcbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gX3RoaXMuX2F0dHJzW2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlOyB9KTtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXNNZXRhID0gX2RpcmVjdGl2ZUFzdHMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHsgcmV0dXJuIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmU7IH0pO1xuICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMgPVxuICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzTWV0YSwgX3NvdXJjZVNwYW4sIHZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRRdWVyaWVzID0gX2dldENvbnRlbnRRdWVyaWVzKGNvbnRlbnRRdWVyeVN0YXJ0SWQsIGRpcmVjdGl2ZXNNZXRhKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci50b2tlbiwgX3RoaXMuX3F1ZXJpZWRUb2tlbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVJlZklkID0gY3JlYXRlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFF1ZXJ5UmVhZHNUbyh0ZW1wbGF0ZVJlZklkLCB0ZW1wbGF0ZVJlZklkLCB0aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZkFzdCkge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRRdWVyeVZhbHVlID0gcmVmQXN0LnZhbHVlIHx8IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5FbGVtZW50UmVmKTtcbiAgICAgICAgICAgIF90aGlzLl9hZGRRdWVyeVJlYWRzVG8oeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSwgZGVmYXVsdFF1ZXJ5VmFsdWUsIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9xdWVyaWVkVG9rZW5zLmdldChyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcHJvdmlkZXJzIHRoYXQgd2Uga25vdyBhcmUgZWFnZXIgZmlyc3RcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgZWFnZXIgPSBwcm92aWRlci5lYWdlciB8fCBfdGhpcy5fcXVlcmllZFRva2Vucy5nZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pKTtcbiAgICAgICAgICAgIGlmIChlYWdlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMudmFsdWVzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZFByb3ZpZGVyVHlwZXMgPSB0aGlzLnRyYW5zZm9ybVByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvcnRlZERpcmVjdGl2ZXMgPSB0aGlzLl9kaXJlY3RpdmVBc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWREaXJlY3RpdmVzLnNvcnQoZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHsgcmV0dXJuIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIxLmRpcmVjdGl2ZS50eXBlKSAtXG4gICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWREaXJlY3RpdmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1ZpZXdDb250YWluZXI7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJxdWVyeU1hdGNoZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcXVlcmllZFRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaGVzKSB7IGFsbE1hdGNoZXMucHVzaC5hcHBseShhbGxNYXRjaGVzLCBtYXRjaGVzKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWxsTWF0Y2hlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVJlYWRUb2tlbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIGRlZmF1bHRWYWx1ZSwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX2dldFF1ZXJpZXNGb3IodG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeVZhbHVlID0gcXVlcnkubWV0YS5yZWFkIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UocXVlcnlWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoZXMgPSBxdWVyeVJlYWRUb2tlbnMuZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgcXVlcnlSZWFkVG9rZW5zLnNldCh0b2tlblJlZiwgcXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5wdXNoKHsgcXVlcnlJZDogcXVlcnkucXVlcnlJZCwgdmFsdWU6IHF1ZXJ5VmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRFbCA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fY29udGVudFF1ZXJpZXMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgICAgICBpZiAocXVlcmllcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcy5maWx0ZXIoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5tZXRhLmRlc2NlbmRhbnRzIHx8IGRpc3RhbmNlIDw9IDE7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwuX2RpcmVjdGl2ZUFzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBxdWVyaWVzID0gdGhpcy52aWV3Q29udGV4dC52aWV3UXVlcmllcy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGVhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIHRva2VuLCBlYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIgfHwgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW5OYW1lKHRva2VuKSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cnVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gcHJvdmlkZXIudXNlRXhpc3Rpbmc7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZERlcHM7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSwgZWFnZXIpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcGFyYW0gez89fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICBpZiAoZGVwLmlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyVmFsdWUgPSB0aGlzLl9hdHRyc1tkZXAudG9rZW4udmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IGF0dHJWYWx1ZSA9PSBudWxsID8gbnVsbCA6IGF0dHJWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXAudG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW50c1xuICAgICAgICAgICAgaWYgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgaW5qZWN0b3JcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXNzIHByb3ZpZGVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAudG9rZW4sIGVhZ2VyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGVwXG4gICAgICogQHBhcmFtIHs/PX0gZWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJFbGVtZW50ID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckVhZ2VyID0gZWFnZXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsRGVwZW5kZW5jeShyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwLmlzU2VsZikge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmIGN1cnJFbGVtZW50Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2RWxlbWVudCA9IGN1cnJFbGVtZW50O1xuICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVhZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGRlcCwgY3VyckVhZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC52aWV3UHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcC5pc09wdGlvbmFsID8gcmVzdWx0ID0geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9IDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyB0b2tlbk5hbWUoZGVwLnRva2VuKSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdmlkZXJFbGVtZW50Q29udGV4dDtcbn0oKSk7XG52YXIgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBleHRyYVByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihuZ01vZHVsZSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBuZ01vZHVsZVByb3ZpZGVyID0geyB0b2tlbjogeyBpZGVudGlmaWVyOiBuZ01vZHVsZVR5cGUgfSwgdXNlQ2xhc3M6IG5nTW9kdWxlVHlwZSB9O1xuICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW25nTW9kdWxlUHJvdmlkZXJdLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgdHJ1ZSwgc291cmNlU3BhbiwgX3RoaXMuX2Vycm9ycywgX3RoaXMuX2FsbFByb3ZpZGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5wcm92aWRlcjsgfSkuY29uY2F0KGV4dHJhUHJvdmlkZXJzKSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0aGlzLl9lcnJvcnMsIHRoaXMuX2FsbFByb3ZpZGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5lYWdlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yU3RyaW5nID0gdGhpcy5fZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnZhbHVlcygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGVhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAodG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9IHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWRQcm92aWRlckFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NlZW5Qcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW5OYW1lKHRva2VuKSwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIHRydWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBwcm92aWRlci51c2VFeGlzdGluZztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkRGVwcztcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhpc3RpbmdEaURlcCA9IF90aGlzLl9nZXREZXBlbmRlbmN5KHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0sIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlcFxuICAgICAqIEBwYXJhbSB7Pz19IGVhZ2VyXG4gICAgICogQHBhcmFtIHs/PX0gcmVxdWVzdG9yU291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChkZXAsIGVhZ2VyLCByZXF1ZXN0b3JTb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3VuZExvY2FsID0gZmFsc2U7XG4gICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYgJiYgZGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgaW5qZWN0b3JcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikgfHxcbiAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIoZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgaWYgKGRlcC5pc1NlbGYgJiYgIWZvdW5kTG9jYWwpIHtcbiAgICAgICAgICAgIGlmIChkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgdG9rZW5OYW1lKGRlcC50b2tlbiksIHJlcXVlc3RvclNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAqIEBwYXJhbSB7P30gX18xXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIF9hKSB7XG4gICAgdmFyIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIGRlcHMgPSBfYS5kZXBzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBwcm92aWRlci50b2tlbixcbiAgICAgICAgdXNlQ2xhc3M6IHByb3ZpZGVyLnVzZUNsYXNzLFxuICAgICAgICB1c2VFeGlzdGluZzogdXNlRXhpc3RpbmcsXG4gICAgICAgIHVzZUZhY3Rvcnk6IHByb3ZpZGVyLnVzZUZhY3RvcnksXG4gICAgICAgIHVzZVZhbHVlOiB1c2VWYWx1ZSxcbiAgICAgICAgZGVwczogZGVwcyxcbiAgICAgICAgbXVsdGk6IHByb3ZpZGVyLm11bHRpXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlclxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlckFzdChwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgZWFnZXIgPSBfYS5lYWdlciwgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzO1xuICAgIHJldHVybiBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHByb3ZpZGVyLmVhZ2VyIHx8IGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIubGlmZWN5Y2xlSG9va3MsIHByb3ZpZGVyLnNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICogQHBhcmFtIHs/fSB0YXJnZXRFcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlcywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJQcm92aWRlciA9IHsgdG9rZW46IHsgaWRlbnRpZmllcjogZGlyZWN0aXZlLnR5cGUgfSwgdXNlQ2xhc3M6IGRpcmVjdGl2ZS50eXBlIH07XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtkaXJQcm92aWRlcl0sIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQgOiBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlLCB0cnVlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgIH0pO1xuICAgIC8vIE5vdGU6IGRpcmVjdGl2ZXMgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJ3cml0ZSBwcm92aWRlcnMgb2YgYSBjb21wb25lbnQhXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdCA9IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pc0NvbXBvbmVudDsgfSkuY29uY2F0KGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICFkaXIuaXNDb21wb25lbnQ7IH0pKTtcbiAgICBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0LmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLCBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm92aWRlcnNCeVRva2VuO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAqIEBwYXJhbSB7P30gZWFnZXJcbiAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICogQHBhcmFtIHs/fSB0YXJnZXRFcnJvcnNcbiAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvdmlkZXJzQnlUb2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnMocHJvdmlkZXJzLCBwcm92aWRlclR5cGUsIGVhZ2VyLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4pIHtcbiAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlciA9IHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSk7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb3ZpZGVyICE9IG51bGwgJiYgISFyZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09ICEhcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgIHRhcmdldEVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTWl4aW5nIG11bHRpIGFuZCBub24gbXVsdGkgcHJvdmlkZXIgaXMgbm90IHBvc3NpYmxlIGZvciB0b2tlbiBcIiArIHRva2VuTmFtZShyZXNvbHZlZFByb3ZpZGVyLnRva2VuKSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlmZWN5Y2xlSG9va3MgPSBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyICYmXG4gICAgICAgICAgICAgICAgKChwcm92aWRlci50b2tlbi5pZGVudGlmaWVyKSkubGlmZWN5Y2xlSG9va3MgP1xuICAgICAgICAgICAgICAgICgocHJvdmlkZXIudG9rZW4uaWRlbnRpZmllcikpLmxpZmVjeWNsZUhvb2tzIDpcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVXNlVmFsdWUgPSAhKHByb3ZpZGVyLnVzZUNsYXNzIHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkpO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGksIGVhZ2VyIHx8IGlzVXNlVmFsdWUsIFtwcm92aWRlcl0sIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbi5zZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pLCByZXNvbHZlZFByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIubXVsdGkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRWaWV3UXVlcmllcyhjb21wb25lbnQpIHtcbiAgICAvLyBOb3RlOiBxdWVyaWVzIHN0YXJ0IHdpdGggaWQgMSBzbyB3ZSBjYW4gdXNlIHRoZSBudW1iZXIgaW4gYSBCbG9vbSBmaWx0ZXIhXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1F1ZXJ5SWQgPSAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGlmIChjb21wb25lbnQudmlld1F1ZXJpZXMpIHtcbiAgICAgICAgY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiB2aWV3UXVlcnlJZCsrIH0pOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdRdWVyaWVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbnRlbnRRdWVyeVN0YXJ0SWRcbiAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2dldENvbnRlbnRRdWVyaWVzKGNvbnRlbnRRdWVyeVN0YXJ0SWQsIGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UXVlcnlJZCA9IGNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFF1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUsIGRpcmVjdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmUucXVlcmllcykge1xuICAgICAgICAgICAgZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIF9hZGRRdWVyeVRvVG9rZW5NYXAoY29udGVudFF1ZXJpZXMsIHsgbWV0YTogcXVlcnksIHF1ZXJ5SWQ6IGNvbnRlbnRRdWVyeUlkKysgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnRRdWVyaWVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1hcFxuICogQHBhcmFtIHs/fSBxdWVyeVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChtYXAsIHF1ZXJ5KSB7XG4gICAgcXVlcnkubWV0YS5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSBtYXAuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgc2NoZW1hTWV0YXMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYU1ldGFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc0VsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEBwYXJhbSB7P30gaXNBdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuc2VjdXJpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuYWxsS25vd25FbGVtZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBjYW1lbENhc2VQcm9wXG4gICAgICogQHBhcmFtIHs/fSB1c2VyUHJvdmlkZWRQcm9wXG4gICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIChjYW1lbENhc2VQcm9wLCB1c2VyUHJvdmlkZWRQcm9wLCB2YWwpIHsgfTtcbiAgICByZXR1cm4gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTdHlsZVdpdGhJbXBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVVybHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlJCQxLCBzdHlsZVVybHMpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlJCQxO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlV2l0aEltcG9ydHM7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgaWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVtZU1hdGNoID0gdXJsLm1hdGNoKFVSTF9XSVRIX1NDSEVNQV9SRUdFWFApO1xuICAgIHJldHVybiBzY2hlbWVNYXRjaCA9PT0gbnVsbCB8fCBzY2hlbWVNYXRjaFsxXSA9PSAncGFja2FnZScgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ2Fzc2V0Jztcbn1cbi8qKlxuICogUmV3cml0ZXMgc3R5bGVzaGVldHMgYnkgcmVzb2x2aW5nIGFuZCByZW1vdmluZyB0aGUgXFxAaW1wb3J0IHVybHMgdGhhdFxuICogYXJlIGVpdGhlciByZWxhdGl2ZSBvciBkb24ndCBoYXZlIGEgYHBhY2thZ2U6YCBzY2hlbWVcbiAqIEBwYXJhbSB7P30gcmVzb2x2ZXJcbiAqIEBwYXJhbSB7P30gYmFzZVVybFxuICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm91bmRVcmxzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kaWZpZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKENTU19DT01NRU5UX1JFR0VYUCwgJycpLnJlcGxhY2UoQ1NTX0lNUE9SVF9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSBtWzFdIHx8IG1bMl07XG4gICAgICAgIGlmICghaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhtb2RpZmllZENzc1RleHQsIGZvdW5kVXJscyk7XG59XG52YXIgQ1NTX0lNUE9SVF9SRUdFWFAgPSAvQGltcG9ydFxccysoPzp1cmxcXCgpP1xccyooPzooPzpbJ1wiXShbXidcIl0qKSl8KFteO1xcKVxcc10qKSlbXjtdKjs/L2c7XG52YXIgQ1NTX0NPTU1FTlRfUkVHRVhQID0gL1xcL1xcKi4rP1xcKlxcLy9nO1xudmFyIFVSTF9XSVRIX1NDSEVNQV9SRUdFWFAgPSAvXihbXjovPyNdKyk6Lztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG52YXIgQVRUUklCVVRFX1BSRUZJWCA9ICdhdHRyJztcbnZhciBDTEFTU19QUkVGSVggPSAnY2xhc3MnO1xudmFyIFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG52YXIgQU5JTUFURV9QUk9QX1BSRUZJWCA9ICdhbmltYXRlLSc7XG52YXIgQm91bmRQcm9wZXJ0eVR5cGUgPSB7fTtcbkJvdW5kUHJvcGVydHlUeXBlLkRFRkFVTFQgPSAwO1xuQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSID0gMTtcbkJvdW5kUHJvcGVydHlUeXBlLkFOSU1BVElPTiA9IDI7XG5Cb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxUXSA9IFwiREVGQVVMVFwiO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSXSA9IFwiTElURVJBTF9BVFRSXCI7XG5Cb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT05dID0gXCJBTklNQVRJT05cIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIHBhcnNlZCBwcm9wZXJ0eS5cbiAqL1xudmFyIEJvdW5kUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kUHJvcGVydHkobmFtZSwgZXhwcmVzc2lvbiwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRQcm9wZXJ0eS5wcm90b3R5cGUsIFwiaXNMaXRlcmFsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRQcm9wZXJ0eS5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT047IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBCb3VuZFByb3BlcnR5O1xufSgpKTtcbi8qKlxuICogUGFyc2VzIGJpbmRpbmdzIGluIHRlbXBsYXRlcyBhbmQgaW4gdGhlIGRpcmVjdGl2ZSBob3N0IGFyZWEuXG4gKi9cbnZhciBCaW5kaW5nUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9leHByUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gX3RhcmdldEVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdQYXJzZXIoX2V4cHJQYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnLCBfc2NoZW1hUmVnaXN0cnksIHBpcGVzLCBfdGFyZ2V0RXJyb3JzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzID0gX3RhcmdldEVycm9ycztcbiAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdXNlZFBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBwaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5waXBlc0J5TmFtZS5zZXQocGlwZS5uYW1lLCBwaXBlKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuZ2V0VXNlZFBpcGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl91c2VkUGlwZXMudmFsdWVzKCkpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyTWV0YVxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGRpck1ldGEsIGVsZW1lbnRTZWxlY3Rvciwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlyTWV0YS5ob3N0UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRQcm9wc18xID0gW107XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSBkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlUHJvcGVydHlCaW5kaW5nKHByb3BOYW1lLCBleHByZXNzaW9uLCB0cnVlLCBzb3VyY2VTcGFuLCBbXSwgYm91bmRQcm9wc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IHByb3BlcnR5IGJpbmRpbmcgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHNfMS5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50U2VsZWN0b3IsIHByb3ApOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJNZXRhXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzID0gZnVuY3Rpb24gKGRpck1ldGEsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdExpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0RXZlbnRBc3RzXzEgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEuaG9zdExpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0TGlzdGVuZXJzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlRXZlbnQocHJvcE5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIFtdLCB0YXJnZXRFdmVudEFzdHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJWYWx1ZSBvZiB0aGUgaG9zdCBsaXN0ZW5lciBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0RXZlbnRBc3RzXzE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nID0gZnVuY3Rpb24gKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdzID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlU3Bhbik7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmcua2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRpbmcuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QoYmluZGluZy5rZXksIGJpbmRpbmcuZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2JpbmRpbmcua2V5LCAnJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaXRlcmFsQXR0cihiaW5kaW5nLmtleSwgbnVsbCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVmaXhUb2tlblxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAocHJlZml4VG9rZW4sIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nc1Jlc3VsdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlSW5mbyk7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGJpbmRpbmdzUmVzdWx0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1BpcGVzKGJpbmRpbmcuZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5kaW5nc1Jlc3VsdC53YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uICh3YXJuaW5nKSB7IF90aGlzLl9yZXBvcnRFcnJvcih3YXJuaW5nLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmdzUmVzdWx0LnRlbXBsYXRlQmluZGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpdGVyYWxBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgaWYgKF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkFzc2lnbmluZyBhbmltYXRpb24gdHJpZ2dlcnMgdmlhIEBwcm9wPVxcXCJleHBcXFwiIGF0dHJpYnV0ZXMgd2l0aCBhbiBleHByZXNzaW9uIGlzIGludmFsaWQuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBVc2UgcHJvcGVydHkgYmluZGluZ3MgKGUuZy4gW0Bwcm9wXT1cXFwiZXhwXFxcIikgb3IgdXNlIGFuIGF0dHJpYnV0ZSB3aXRob3V0IGEgdmFsdWUgKGUuZy4gQHByb3ApIGluc3RlYWQuXCIsIHNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgJycpLCBCb3VuZFByb3BlcnR5VHlwZS5MSVRFUkFMX0FUVFIsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBpc0hvc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNBbmltYXRpb25Qcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoQU5JTUFURV9QUk9QX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIGlzQW5pbWF0aW9uUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoQU5JTUFURV9QUk9QX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvblByb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBpc0hvc3QsIHNvdXJjZVNwYW4pLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IHRoaXMucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5QXN0ID0gZnVuY3Rpb24gKG5hbWUsIGFzdCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRQcm9wZXJ0eShuYW1lLCBhc3QsIEJvdW5kUHJvcGVydHlUeXBlLkRFRkFVTFQsIHNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBvY2N1ciB3aGVuIGEgQHRyaWdnZXIgaXMgbm90IHBhaXJlZCB3aXRoIGFuIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIEZvciBhbmltYXRpb25zIGl0IGlzIHZhbGlkIHRvIG5vdCBoYXZlIGFuIGV4cHJlc3Npb24gc2luY2UgKi92b2lkXG4gICAgICAgIC8vIHN0YXRlcyB3aWxsIGJlIGFwcGxpZWQgYnkgYW5ndWxhciB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkL2RldGFjaGVkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uIHx8ICdudWxsJywgZmFsc2UsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgYXN0LCBCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT04sIHNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGlzSG9zdEJpbmRpbmdcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGlzSG9zdEJpbmRpbmcsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IGlzSG9zdEJpbmRpbmcgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VTaW1wbGVCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBib3VuZFByb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcCkge1xuICAgICAgICBpZiAoYm91bmRQcm9wLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KGJvdW5kUHJvcC5uYW1lLCBQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbiwgU2VjdXJpdHlDb250ZXh0Lk5PTkUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBudWxsLCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pdCA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdUeXBlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZFByb3BlcnR5TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gYm91bmRQcm9wLm5hbWUuc3BsaXQoUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VjdXJpdHlDb250ZXh0cztcbiAgICAgICAgLy8gQ2hlY2sgY2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgKHByZWZpeCBzdHlsZSwgYXR0ciwgY2xhc3MpXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcGVydHlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZygwLCBuc1NlcGFyYXRvcklkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcobnNTZXBhcmF0b3JJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KGJvdW5kUHJvcGVydHlOYW1lLCBiaW5kaW5nVHlwZSwgc2VjdXJpdHlDb250ZXh0c1swXSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIHVuaXQsIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhhc2UgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgbnVsbCwgcGhhc2UsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBvdXRwdXQgZXZlbnQgKEBcIiArIGV2ZW50TmFtZSArIFwiKSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgIHZhciBfYSA9IHNwbGl0QXRDb2xvbihuYW1lLCBbbnVsbCwgbmFtZV0pLCB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgdGFyZ2V0LCBudWxsLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXN0IHx8IGFzdC5hc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXJyb3JzXzEgPSBlcnJvcnM7IF9pIDwgZXJyb3JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9jaGVja1BpcGVzID0gZnVuY3Rpb24gKGFzdCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0b3IgPSBuZXcgUGlwZUNvbGxlY3RvcigpO1xuICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICBjb2xsZWN0b3IucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0LCBwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gX3RoaXMucGlwZXNCeU5hbWUuZ2V0KHBpcGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwaXBlICdcIiArIHBpcGVOYW1lICsgXCInIGNvdWxkIG5vdCBiZSBmb3VuZFwiLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KGFzdC5zcGFuLnN0YXJ0KSwgc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoYXN0LnNwYW4uZW5kKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VzZWRQaXBlcy5zZXQocGlwZU5hbWUsIHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgLyBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVwb3J0ID0gaXNBdHRyID8gdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICBpZiAocmVwb3J0LmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihyZXBvcnQubXNnLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1BhcnNlcjtcbn0oKSk7XG52YXIgUGlwZUNvbGxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpcGVDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGlwZUNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBpcGVDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5waXBlcy5zZXQoYXN0Lm5hbWUsIGFzdCk7XG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlQ29sbGVjdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByZWdpc3RyeVxuICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICogQHBhcmFtIHs/fSBpc0F0dHJpYnV0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyhyZWdpc3RyeSwgc2VsZWN0b3IsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eHMgPSBbXTtcbiAgICBDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3RvcikuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE5hbWVzID0gc2VsZWN0b3IuZWxlbWVudCA/IFtzZWxlY3Rvci5lbGVtZW50XSA6IHJlZ2lzdHJ5LmFsbEtub3duRWxlbWVudE5hbWVzKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vdEVsZW1lbnROYW1lcyA9IG5ldyBTZXQoc2VsZWN0b3Iubm90U2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmlzRWxlbWVudFNlbGVjdG9yKCk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuZWxlbWVudDsgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NzaWJsZUVsZW1lbnROYW1lcyA9IGVsZW1lbnROYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSk7IH0pO1xuICAgICAgICBjdHhzLnB1c2guYXBwbHkoY3R4cywgcG9zc2libGVFbGVtZW50TmFtZXMubWFwKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gcmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpOyB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eHMubGVuZ3RoID09PSAwID8gW1NlY3VyaXR5Q29udGV4dC5OT05FXSA6IEFycmF5LmZyb20obmV3IFNldChjdHhzKSkuc29ydCgpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0JztcbnZhciBOR19DT05URU5UX0VMRU1FTlQgPSAnbmctY29udGVudCc7XG52YXIgTElOS19FTEVNRU5UID0gJ2xpbmsnO1xudmFyIExJTktfU1RZTEVfUkVMX0FUVFIgPSAncmVsJztcbnZhciBMSU5LX1NUWUxFX0hSRUZfQVRUUiA9ICdocmVmJztcbnZhciBMSU5LX1NUWUxFX1JFTF9WQUxVRSA9ICdzdHlsZXNoZWV0JztcbnZhciBTVFlMRV9FTEVNRU5UID0gJ3N0eWxlJztcbnZhciBTQ1JJUFRfRUxFTUVOVCA9ICdzY3JpcHQnO1xudmFyIE5HX05PTl9CSU5EQUJMRV9BVFRSID0gJ25nTm9uQmluZGFibGUnO1xudmFyIE5HX1BST0pFQ1RfQVMgPSAnbmdQcm9qZWN0QXMnO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcHJlcGFyc2VFbGVtZW50KGFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdEF0dHIgPSBudWxsO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhyZWZBdHRyID0gbnVsbDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWxBdHRyID0gbnVsbDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub25CaW5kYWJsZSA9IGZhbHNlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2plY3RBcyA9IG51bGw7XG4gICAgYXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobGNBdHRyTmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKSB7XG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XG4gICAgaWYgKHNwbGl0TnNOYW1lKG5vZGVOYW1lKVsxXSA9PSBOR19DT05URU5UX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbn1cbnZhciBQcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9O1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVCA9IDA7XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSA9IDE7XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUID0gMjtcblByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCA9IDM7XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUiA9IDQ7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UXSA9IFwiTkdfQ09OVEVOVFwiO1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVdID0gXCJTVFlMRVwiO1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVF0gPSBcIlNUWUxFU0hFRVRcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVF0gPSBcIlNDUklQVFwiO1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVJdID0gXCJPVEhFUlwiO1xudmFyIFByZXBhcnNlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0QXR0clxuICAgICAqIEBwYXJhbSB7P30gaHJlZkF0dHJcbiAgICAgKiBAcGFyYW0gez99IG5vbkJpbmRhYmxlXG4gICAgICogQHBhcmFtIHs/fSBwcm9qZWN0QXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VsZWN0QXR0ciA9IHNlbGVjdEF0dHI7XG4gICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcbiAgICAgICAgdGhpcy5ub25CaW5kYWJsZSA9IG5vbkJpbmRhYmxlO1xuICAgICAgICB0aGlzLnByb2plY3RBcyA9IHByb2plY3RBcztcbiAgICB9XG4gICAgcmV0dXJuIFByZXBhcnNlZEVsZW1lbnQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNlbGVjdEF0dHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKSB7XG4gICAgaWYgKHNlbGVjdEF0dHIgPT09IG51bGwgfHwgc2VsZWN0QXR0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcqJztcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdEF0dHI7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQklORF9OQU1FX1JFR0VYUCA9IC9eKD86KD86KD86KGJpbmQtKXwobGV0LSl8KHJlZi18Iyl8KG9uLSl8KGJpbmRvbi0pfChAKSkoLispKXxcXFtcXCgoW15cXCldKylcXClcXF18XFxbKFteXFxdXSspXFxdfFxcKChbXlxcKV0rKVxcKSkkLztcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbnZhciBLV19CSU5EX0lEWCA9IDE7XG4vLyBHcm91cCAyID0gXCJsZXQtXCJcbnZhciBLV19MRVRfSURYID0gMjtcbi8vIEdyb3VwIDMgPSBcInJlZi0vI1wiXG52YXIgS1dfUkVGX0lEWCA9IDM7XG4vLyBHcm91cCA0ID0gXCJvbi1cIlxudmFyIEtXX09OX0lEWCA9IDQ7XG4vLyBHcm91cCA1ID0gXCJiaW5kb24tXCJcbnZhciBLV19CSU5ET05fSURYID0gNTtcbi8vIEdyb3VwIDYgPSBcIkBcIlxudmFyIEtXX0FUX0lEWCA9IDY7XG4vLyBHcm91cCA3ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcImxldC1cIiwgXCJyZWYtLyNcIiwgXCJvbi1cIiwgXCJiaW5kb24tXCIgb3IgXCJAXCJcbnZhciBJREVOVF9LV19JRFggPSA3O1xuLy8gR3JvdXAgOCA9IGlkZW50aWZpZXIgaW5zaWRlIFsoKV1cbnZhciBJREVOVF9CQU5BTkFfQk9YX0lEWCA9IDg7XG4vLyBHcm91cCA5ID0gaWRlbnRpZmllciBpbnNpZGUgW11cbnZhciBJREVOVF9QUk9QRVJUWV9JRFggPSA5O1xuLy8gR3JvdXAgMTAgPSBpZGVudGlmaWVyIGluc2lkZSAoKVxudmFyIElERU5UX0VWRU5UX0lEWCA9IDEwO1xudmFyIE5HX1RFTVBMQVRFX0VMRU1FTlQgPSAnbmctdGVtcGxhdGUnO1xuLy8gZGVwcmVjYXRlZCBpbiA0LnhcbnZhciBURU1QTEFURV9FTEVNRU5UID0gJ3RlbXBsYXRlJztcbi8vIGRlcHJlY2F0ZWQgaW4gNC54XG52YXIgVEVNUExBVEVfQVRUUiA9ICd0ZW1wbGF0ZSc7XG52YXIgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG52YXIgQ0xBU1NfQVRUUiA9ICdjbGFzcyc7XG52YXIgVEVYVF9DU1NfU0VMRUNUT1IgPSBDc3NTZWxlY3Rvci5wYXJzZSgnKicpWzBdO1xudmFyIFRFTVBMQVRFX0VMRU1FTlRfREVQUkVDQVRJT05fV0FSTklORyA9ICdUaGUgPHRlbXBsYXRlPiBlbGVtZW50IGlzIGRlcHJlY2F0ZWQuIFVzZSA8bmctdGVtcGxhdGU+IGluc3RlYWQnO1xudmFyIFRFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORyA9ICdUaGUgdGVtcGxhdGUgYXR0cmlidXRlIGlzIGRlcHJlY2F0ZWQuIFVzZSBhbiBuZy10ZW1wbGF0ZSBlbGVtZW50IGluc3RlYWQuJztcbnZhciB3YXJuaW5nQ291bnRzID0ge307XG4vKipcbiAqIEBwYXJhbSB7P30gd2FybmluZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHdhcm5Pbmx5T25jZSh3YXJuaW5ncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHdhcm5pbmdzLmluZGV4T2YoZXJyb3IubXNnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmdDb3VudHNbZXJyb3IubXNnXSA9ICh3YXJuaW5nQ291bnRzW2Vycm9yLm1zZ10gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIHdhcm5pbmdDb3VudHNbZXJyb3IubXNnXSA8PSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIGFuIGFycmF5IG9mIHtAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtXG4gKiBwYXJzZWQgdGVtcGxhdGVzIGJlZm9yZSBjb21waWxhdGlvbiBpcyBpbnZva2VkLCBhbGxvd2luZyBjdXN0b20gZXhwcmVzc2lvbiBzeW50YXhcbiAqIGFuZCBvdGhlciBhZHZhbmNlZCB0cmFuc2Zvcm1hdGlvbnMuXG4gKlxuICogVGhpcyBpcyBjdXJyZW50bHkgYW4gaW50ZXJuYWwtb25seSBmZWF0dXJlIGFuZCBub3QgbWVhbnQgZm9yIGdlbmVyYWwgdXNlLlxuICovXG52YXIgVEVNUExBVEVfVFJBTlNGT1JNUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignVGVtcGxhdGVUcmFuc2Zvcm1zJyk7XG52YXIgVGVtcGxhdGVQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gbGV2ZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlRXJyb3IobWVzc2FnZSwgc3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UsIGxldmVsKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZUVycm9yO1xufShQYXJzZUVycm9yKSk7XG52YXIgVGVtcGxhdGVQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdGVtcGxhdGVBc3RcbiAgICAgKiBAcGFyYW0gez89fSB1c2VkUGlwZXNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlUmVzdWx0KHRlbXBsYXRlQXN0LCB1c2VkUGlwZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLnRlbXBsYXRlQXN0ID0gdGVtcGxhdGVBc3Q7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzID0gdXNlZFBpcGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VSZXN1bHQ7XG59KCkpO1xudmFyIFRlbXBsYXRlUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9leHByUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hUmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gez99IF9odG1sUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfY29uc29sZVxuICAgICAqIEBwYXJhbSB7P30gdHJhbnNmb3Jtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VyKF9jb25maWcsIF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnksIF9odG1sUGFyc2VyLCBfY29uc29sZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy50cnlQYXJzZShjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXJuaW5ncyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KS5maWx0ZXIod2Fybk9ubHlPbmNlKFtcbiAgICAgICAgICAgIFRFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORywgVEVNUExBVEVfRUxFTUVOVF9ERVBSRUNBVElPTl9XQVJOSU5HXG4gICAgICAgIF0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9KTtcbiAgICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIlRlbXBsYXRlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0ZW1wbGF0ZTogcmVzdWx0LnRlbXBsYXRlQXN0LCBwaXBlczogcmVzdWx0LnVzZWRQaXBlcyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5UGFyc2VIdG1sKHRoaXMuZXhwYW5kSHRtbCh0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgdHJ1ZSwgdGhpcy5nZXRJbnRlcnBvbGF0aW9uQ29uZmlnKGNvbXBvbmVudCkpKSwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGh0bWxBc3RXaXRoRXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VIdG1sID0gZnVuY3Rpb24gKGh0bWxBc3RXaXRoRXJyb3JzLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VkUGlwZXMgPSBbXTtcbiAgICAgICAgaWYgKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmlxRGlyZWN0aXZlcyA9IHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcVBpcGVzID0gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMocGlwZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJWaWV3Q29udGV4dCA9IG5ldyBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSAmJiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblsxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nUGFyc2VyID0gbmV3IEJpbmRpbmdQYXJzZXIodGhpcy5fZXhwclBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHVuaXFQaXBlcywgZXJyb3JzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVBhcnNlVmlzaXRvcih0aGlzLl9jb25maWcsIHByb3ZpZGVyVmlld0NvbnRleHQsIHVuaXFEaXJlY3RpdmVzLCBiaW5kaW5nUGFyc2VyLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSwgc2NoZW1hcywgZXJyb3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZpc2l0QWxsKHBhcnNlVmlzaXRvciwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBwcm92aWRlclZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgICB1c2VkUGlwZXMucHVzaC5hcHBseSh1c2VkUGlwZXMsIGJpbmRpbmdQYXJzZXIuZ2V0VXNlZFBpcGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIHVzZWRQaXBlcywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtKSB7IHJlc3VsdCA9IHRlbXBsYXRlVmlzaXRBbGwodHJhbnNmb3JtLCByZXN1bHQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCB1c2VkUGlwZXMsIGVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGh0bWxBc3RXaXRoRXJyb3JzXG4gICAgICogQHBhcmFtIHs/PX0gZm9yY2VkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZXhwYW5kSHRtbCA9IGZ1bmN0aW9uIChodG1sQXN0V2l0aEVycm9ycywgZm9yY2VkKSB7XG4gICAgICAgIGlmIChmb3JjZWQgPT09IHZvaWQgMCkgeyBmb3JjZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09IDAgfHwgZm9yY2VkKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSUNVIG1lc3NhZ2VzIHRvIGFuZ3VsYXIgZGlyZWN0aXZlc1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5kZWRIdG1sQXN0ID0gZXhwYW5kTm9kZXMoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZXhwYW5kZWRIdG1sQXN0LmVycm9ycyk7XG4gICAgICAgICAgICBodG1sQXN0V2l0aEVycm9ycyA9IG5ldyBQYXJzZVRyZWVSZXN1bHQoZXhwYW5kZWRIdG1sQXN0Lm5vZGVzLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sQXN0V2l0aEVycm9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlID0gZnVuY3Rpb24gKHJlc3VsdCwgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiAhISgoZWxlbWVudCkpLnJlZmVyZW5jZXM7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gKChlbGVtZW50KSkucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSByZWZlcmVuY2UubmFtZTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1JlZmVyZW5jZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1JlZmVyZW5jZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gbmV3IFRlbXBsYXRlUGFyc2VFcnJvcihcIlJlZmVyZW5jZSBcXFwiI1wiICsgbmFtZSArIFwiXFxcIiBpcyBkZWZpbmVkIHNldmVyYWwgdGltZXNcIiwgcmVmZXJlbmNlLnNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5FUlJPUik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XG59KCkpO1xuVGVtcGxhdGVQYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuVGVtcGxhdGVQYXJzZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICB7IHR5cGU6IFBhcnNlciwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICB7IHR5cGU6IEkxOE5IdG1sUGFyc2VyLCB9LFxuICAgIHsgdHlwZTogybVDb25zb2xlLCB9LFxuICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbVEVNUExBVEVfVFJBTlNGT1JNUyxdIH0sXSB9LFxuXTsgfTtcbnZhciBUZW1wbGF0ZVBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyVmlld0NvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IF9iaW5kaW5nUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hUmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFzXG4gICAgICogQHBhcmFtIHs/fSBfdGFyZ2V0RXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVZpc2l0b3IoY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBfYmluZGluZ1BhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfc2NoZW1hcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5wcm92aWRlclZpZXdDb250ZXh0ID0gcHJvdmlkZXJWaWV3Q29udGV4dDtcbiAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlciA9IF9iaW5kaW5nUGFyc2VyO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5fc2NoZW1hcyA9IF9zY2hlbWFzO1xuICAgICAgICB0aGlzLl90YXJnZXRFcnJvcnMgPSBfdGFyZ2V0RXJyb3JzO1xuICAgICAgICB0aGlzLnNlbGVjdG9yTWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmdDb250ZW50Q291bnQgPSAwO1xuICAgICAgICAvLyBOb3RlOiBxdWVyaWVzIHN0YXJ0IHdpdGggaWQgMSBzbyB3ZSBjYW4gdXNlIHRoZSBudW1iZXIgaW4gYSBCbG9vbSBmaWx0ZXIhXG4gICAgICAgIHRoaXMuY29udGVudFF1ZXJ5U3RhcnRJZCA9IHByb3ZpZGVyVmlld0NvbnRleHQuY29tcG9uZW50LnZpZXdRdWVyaWVzLmxlbmd0aCArIDE7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gQ3NzU2VsZWN0b3IucGFyc2UoZGlyZWN0aXZlLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdG9yTWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhzZWxlY3RvciwgZGlyZWN0aXZlKTtcbiAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZXNJbmRleC5zZXQoZGlyZWN0aXZlLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvbkNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBleHByID8gbmV3IEJvdW5kVGV4dEFzdChleHByLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKSA6XG4gICAgICAgICAgICBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlTdGFydEluZGV4ID0gdGhpcy5jb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlTmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGVtXG4gICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCAmJlxuICAgICAgICAgICAgaXNTdHlsZVVybFJlc29sdmFibGUocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cikpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIHN0eWxlc2hlZXRzIHdpdGggZWl0aGVyIHJlbGF0aXZlIHVybHMgb3IgcGFja2FnZSBzY2hlbWUgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgICAgIC8vIHRoZW0gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVNYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUVsZW1lbnRWYXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0lubGluZVRlbXBsYXRlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGUoZWxlbWVudCwgdGhpcy5jb25maWcuZW5hYmxlTGVnYWN5VGVtcGxhdGUsIGZ1bmN0aW9uIChtLCBzcGFuKSB7IHJldHVybiBfdGhpcy5fcmVwb3J0RXJyb3IobSwgc3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgZWxlbWVudC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNCaW5kaW5nID0gX3RoaXMuX3BhcnNlQXR0cihpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgbWF0Y2hhYmxlQXR0cnMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBldmVudHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnRWYXJzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlQmluZGluZ3NTb3VyY2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXhUb2tlbjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWROYW1lID0gX3RoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuZW5hYmxlTGVnYWN5VGVtcGxhdGUgJiYgbm9ybWFsaXplZE5hbWUgPT0gVEVNUExBVEVfQVRUUikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihURU1QTEFURV9BVFRSX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIGF0dHIuc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9ybWFsaXplZE5hbWUuc3RhcnRzV2l0aChURU1QTEFURV9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICBwcmVmaXhUb2tlbiA9IG5vcm1hbGl6ZWROYW1lLnN1YnN0cmluZyhURU1QTEFURV9BVFRSX1BSRUZJWC5sZW5ndGgpICsgJzonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzVGVtcGxhdGVCaW5kaW5nID0gdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSAhPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBuYW1lZCAndGVtcGxhdGUnIG9yIHByZWZpeGVkIHdpdGggKlwiLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNJbmxpbmVUZW1wbGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKHByZWZpeFRva2VuLCB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZVNwYW4sIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNCaW5kaW5nICYmICFoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goX3RoaXMudmlzaXRBdHRyaWJ1dGUoYXR0ciwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZUF0dHJzLnB1c2goW2F0dHIubmFtZSwgYXR0ci52YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudENzc1NlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKG5vZGVOYW1lLCBtYXRjaGFibGVBdHRycyk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSwgZGlyZWN0aXZlTWV0YXMgPSBfYS5kaXJlY3RpdmVzLCBtYXRjaEVsZW1lbnQgPSBfYS5tYXRjaEVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmREaXJlY3RpdmVQcm9wTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50Lm5hbWUsIGRpcmVjdGl2ZU1ldGFzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudC5zb3VyY2VTcGFuLCByZWZlcmVuY2VzLCBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1ZpZXdSb290ID0gcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50IHx8IGhhc0lubGluZVRlbXBsYXRlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBpc1ZpZXdSb290LCBkaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmZXJlbmNlcywgaXNUZW1wbGF0ZUVsZW1lbnQsIHF1ZXJ5U3RhcnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSB2aXNpdEFsbChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IgOiB0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBFbGVtZW50Q29udGV4dC5jcmVhdGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZUFzdHMsIGlzVGVtcGxhdGVFbGVtZW50ID8gcGFyZW50LnByb3ZpZGVyQ29udGV4dCA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgc2VsZWN0b3Igd2hlbiB0aGUgYG5nUHJvamVjdEFzYCBhdHRyaWJ1dGUgaXMgcHJvdmlkZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvamVjdGlvblNlbGVjdG9yID0gcHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMgIT0gbnVsbCA/XG4gICAgICAgICAgICBDc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkRWxlbWVudDtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiYgIWVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoX2lzRW1wdHlUZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuXCIsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IE5nQ29udGVudEFzdCh0aGlzLm5nQ29udGVudENvdW50KyssIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzKGRpcmVjdGl2ZUFzdHMsIGV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChhdHRycywgZXZlbnRzLCByZWZlcmVuY2VzLCBlbGVtZW50VmFycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgcHJvdmlkZXJDb250ZXh0LnF1ZXJ5TWF0Y2hlcywgY2hpbGRyZW4sIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEVsZW1lbnRFeGlzdHMobWF0Y2hFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQoZGlyZWN0aXZlQXN0cywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlUXVlcnlTdGFydEluZGV4ID0gdGhpcy5jb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihURU1QTEFURV9FTEVNRU5ULCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCB0ZW1wbGF0ZVNlbGVjdG9yKS5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVCb3VuZERpcmVjdGl2ZVByb3BOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHModHJ1ZSwgZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBbXSwgZWxlbWVudC5zb3VyY2VTcGFuLCBbXSwgdGVtcGxhdGVCb3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUodGVtcGxhdGVEaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZUVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgW10sIFtdLCB0cnVlLCB0ZW1wbGF0ZVF1ZXJ5U3RhcnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LmFmdGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KFtdLCBbXSwgW10sIHRlbXBsYXRlRWxlbWVudFZhcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnF1ZXJ5TWF0Y2hlcywgW3BhcnNlZEVsZW1lbnRdLCBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGF0dHJcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRSZWZzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXR0ciA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRFdmVudHMsIHRhcmdldFJlZnMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmNTcGFuID0gYXR0ci5zb3VyY2VTcGFuO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kUGFydHMgPSBuYW1lLm1hdGNoKEJJTkRfTkFNRV9SRUdFWFApO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChiaW5kUGFydHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19MRVRfSURYXSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFZhcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwibGV0LVxcXCIgaXMgb25seSBzdXBwb3J0ZWQgb24gdGVtcGxhdGUgZWxlbWVudHMuXCIsIHNyY1NwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19SRUZfSURYXSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0UmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfT05fSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0JJTkRPTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQVRfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNCaW5kaW5nID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0ck5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fbm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVmFyaWFibGUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFZhcnMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHZhcmlhYmxlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgVmFyaWFibGVBc3QoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFJlZnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFJlZnMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRSZWZzLnB1c2gobmV3IEVsZW1lbnRPckRpcmVjdGl2ZVJlZihpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KG5hbWUgKyBcIkNoYW5nZVwiLCBleHByZXNzaW9uICsgXCI9JGV2ZW50XCIsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck1hdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRDc3NTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTmVlZCB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIHNvIHRoYXQgd2UgZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0LFxuICAgICAgICAvLyBhcyBzZWxlY3Rvck1hdGNoZXIgdXNlcyBNYXBzIGluc2lkZS5cbiAgICAgICAgLy8gQWxzbyBkZWR1cGxpY2F0ZSBkaXJlY3RpdmVzIGFzIHRoZXkgbWlnaHQgbWF0Y2ggbW9yZSB0aGFuIG9uZSB0aW1lIVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzID0gbmV3IEFycmF5KHRoaXMuZGlyZWN0aXZlc0luZGV4LnNpemUpO1xuICAgICAgICAvLyBXaGV0aGVyIGFueSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyBvbiB0aGUgZWxlbWVudCBuYW1lXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICBzZWxlY3Rvck1hdGNoZXIubWF0Y2goZWxlbWVudENzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc1tfdGhpcy5kaXJlY3RpdmVzSW5kZXguZ2V0KGRpcmVjdGl2ZSldID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgbWF0Y2hFbGVtZW50ID0gbWF0Y2hFbGVtZW50IHx8IHNlbGVjdG9yLmhhc0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICEhZGlyOyB9KSxcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudDogbWF0Y2hFbGVtZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50T3JEaXJlY3RpdmVSZWZzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50U291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlQXN0cyA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZWxlbWVudE5hbWUsIGRpcmVjdGl2ZXMsIHByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50U291cmNlU3BhbiwgdGFyZ2V0UmVmZXJlbmNlcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZUFzdHMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihlbGVtZW50U291cmNlU3Bhbi5zdGFydCwgZWxlbWVudFNvdXJjZVNwYW4uZW5kLCBcIkRpcmVjdGl2ZSBcIiArIGlkZW50aWZpZXJOYW1lKGRpcmVjdGl2ZS50eXBlKSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFByb3BlcnRpZXMgPSBfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGRpcmVjdGl2ZSwgZWxlbWVudE5hbWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjaGVjayB0aGUgaG9zdCBwcm9wZXJ0aWVzIGhlcmUgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIGFzIHdlIGRvbid0IGtub3cgdGhlIGVsZW1lbnQgbmFtZSBpbiB0aGUgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyIHlldC5cbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzID0gX3RoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBob3N0UHJvcGVydGllcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0RXZlbnRzID0gX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhkaXJlY3RpdmUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmUuaXNDb21wb25lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUuZXhwb3J0QXMgPT0gZWxPckRpclJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCBpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlLnR5cGUpLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFJlZmVyZW5jZXMuYWRkKGVsT3JEaXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UXVlcnlTdGFydElkID0gX3RoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgICAgIF90aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgKz0gZGlyZWN0aXZlLnF1ZXJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgIGlmIChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRSZWZlcmVuY2VzLmhhcyhlbE9yRGlyUmVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZXJlIGlzIG5vIGRpcmVjdGl2ZSB3aXRoIFxcXCJleHBvcnRBc1xcXCIgc2V0IHRvIFxcXCJcIiArIGVsT3JEaXJSZWYudmFsdWUgKyBcIlxcXCJcIiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWZUb2tlbiA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgcmVmVG9rZW4sIGVsT3JEaXJSZWYuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUFzdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gez99IGJvdW5kUHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBib3VuZFByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lcykge1xuICAgICAgICBpZiAoZGlyZWN0aXZlUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRQcm9wc0J5TmFtZV8xID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2VmFsdWUgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZWYWx1ZSB8fCBwcmV2VmFsdWUuaXNMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdpdmUgW2FdPVwiYlwiIGEgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBhPVwiYlwiIG9uIHRoZSBzYW1lIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wc0J5TmFtZV8xLnNldChib3VuZFByb3AubmFtZSwgYm91bmRQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZVByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGRpclByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbFByb3AgPSBkaXJlY3RpdmVQcm9wZXJ0aWVzW2RpclByb3BdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcCA9IGJvdW5kUHJvcHNCeU5hbWVfMS5nZXQoZWxQcm9wKTtcbiAgICAgICAgICAgICAgICAvLyBCaW5kaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHRoaXMgYmluZGluZyBvbmx5IG5lZWRzIHRvIGJlIHNldCB1cCBpZiBhbiBleHByZXNzaW9uIGlzIGdpdmVuLlxuICAgICAgICAgICAgICAgIGlmIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMuYWRkKGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5RXhwcmVzc2lvbihib3VuZFByb3AuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMucHVzaChuZXcgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJQcm9wLCBib3VuZFByb3AubmFtZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIGJvdW5kUHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcHNcbiAgICAgKiBAcGFyYW0gez99IGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BzLCBib3VuZERpcmVjdGl2ZVByb3BOYW1lcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZEVsZW1lbnRQcm9wcyA9IFtdO1xuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXByb3AuaXNMaXRlcmFsICYmICFib3VuZERpcmVjdGl2ZVByb3BOYW1lcy5oYXMocHJvcC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudFByb3BzLnB1c2goX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEoZWxlbWVudE5hbWUsIGJvdW5kRWxlbWVudFByb3BzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMoZGlyZWN0aXZlcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0T25seU9uZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIk1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG1hdGNoZWQgb24gdGhpcyBlbGVtZW50LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0aGF0IG9ubHkgb25lIGNvbXBvbmVudCdzIHNlbGVjdG9yIGNhbiBtYXRjaCBhIGdpdmVuIGVsZW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIChcIkNvbmZsaWN0aW5nIGNvbXBvbmVudHM6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSksIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCBub24tYW5ndWxhciB0YWdzIGNvbmZvcm0gdG8gdGhlIHNjaGVtYXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgYW4gYW5ndWxhciB0YWcgd2hlbiBhdCBsZWFzdCBvbmUgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgdGhlXG4gICAgICogdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IG1hdGNoRWxlbWVudCBXaGV0aGVyIGFueSBkaXJlY3RpdmUgaGFzIG1hdGNoZWQgb24gdGhlIHRhZyBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50IHRoZSBodG1sIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0RWxlbWVudEV4aXN0cyA9IGZ1bmN0aW9uIChtYXRjaEVsZW1lbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxOYW1lID0gZWxlbWVudC5uYW1lLnJlcGxhY2UoL146eGh0bWw6LywgJycpO1xuICAgICAgICBpZiAoIW1hdGNoRWxlbWVudCAmJiAhdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzRWxlbWVudChlbE5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9IFwiJ1wiICsgZWxOYW1lICsgXCInIGlzIG5vdCBhIGtub3duIGVsZW1lbnQ6XFxuXCI7XG4gICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgIFwiMS4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50LCB0aGVuIHZlcmlmeSB0aGF0IGl0IGlzIHBhcnQgb2YgdGhpcyBtb2R1bGUuXFxuXCI7XG4gICAgICAgICAgICBpZiAoZWxOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgXCIyLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIjIuIFRvIGFsbG93IGFueSBlbGVtZW50IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvck1zZywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiQE5nTW9kdWxlLmRlY2xhcmF0aW9uc1xcXCIuXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gZXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBldmVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnROYW1lID0gZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzW2tdO1xuICAgICAgICAgICAgICAgIGFsbERpcmVjdGl2ZUV2ZW50cy5hZGQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9IG51bGwgfHwgIWFsbERpcmVjdGl2ZUV2ZW50cy5oYXMoZXZlbnQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJFdmVudCBiaW5kaW5nIFwiICsgZXZlbnQuZnVsbE5hbWUgKyBcIiBub3QgZW1pdHRlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlLiBNYWtlIHN1cmUgdGhhdCB0aGUgZXZlbnQgbmFtZSBpcyBzcGVsbGVkIGNvcnJlY3RseSBhbmQgYWxsIGRpcmVjdGl2ZXMgYXJlIGxpc3RlZCBpbiB0aGUgXFxcIkBOZ01vZHVsZS5kZWNsYXJhdGlvbnNcXFwiLlwiLCBldmVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBib3VuZFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBib3VuZFByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vdGU6IFdlIGNhbid0IGZpbHRlciBvdXQgZW1wdHkgZXhwcmVzc2lvbnMgYmVmb3JlIHRoaXMgbWV0aG9kLFxuICAgICAgICAvLyBhcyB3ZSBzdGlsbCB3YW50IHRvIHZhbGlkYXRlIHRoZW0hXG4gICAgICAgIHJldHVybiBib3VuZFByb3BzLmZpbHRlcihmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRQcm9wLnR5cGUgPT09IFByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMuX3NjaGVtYVJlZ2lzdHJ5Lmhhc1Byb3BlcnR5KGVsZW1lbnROYW1lLCBib3VuZFByb3AubmFtZSwgX3RoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNc2cgPSBcIkNhbid0IGJpbmQgdG8gJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgc2luY2UgaXQgaXNuJ3QgYSBrbm93biBwcm9wZXJ0eSBvZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJy5cIjtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE5hbWUuc3RhcnRzV2l0aCgnbmctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMS4gSWYgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBkaXJlY3RpdmUsIHRoZW4gYWRkICdDb21tb25Nb2R1bGUnIHRvIHRoZSAnQE5nTW9kdWxlLmltcG9ydHMnIG9mIHRoaXMgY29tcG9uZW50LlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjIuIFRvIGFsbG93IGFueSBwcm9wZXJ0eSBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50TmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4xLiBJZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGNvbXBvbmVudCBhbmQgaXQgaGFzICdcIiArIGJvdW5kUHJvcC5uYW1lICsgXCInIGlucHV0LCB0aGVuIHZlcmlmeSB0aGF0IGl0IGlzIHBhcnQgb2YgdGhpcyBtb2R1bGUuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlxcbjIuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGEgV2ViIENvbXBvbmVudCB0aGVuIGFkZCAnQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQgdG8gc3VwcHJlc3MgdGhpcyBtZXNzYWdlLlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4zLiBUbyBhbGxvdyBhbnkgcHJvcGVydHkgYWRkICdOT19FUlJPUlNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWlzRW1wdHlFeHByZXNzaW9uKGJvdW5kUHJvcC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/PX0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1I7IH1cbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFBhcnNlRXJyb3Ioc291cmNlU3BhbiwgbWVzc2FnZSwgbGV2ZWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlVmlzaXRvcjtcbn0oKSk7XG52YXIgTm9uQmluZGFibGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFIHx8XG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFuZCBzdHlsZXNoZWV0cyBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGVtXG4gICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWVBbmRWYWx1ZXMgPSBhc3QuYXR0cnMubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBbYXR0ci5uYW1lLCBhdHRyLnZhbHVlXTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChzZWxlY3Rvcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRBc3QoYXN0Lm5hbWUsIHZpc2l0QWxsKHRoaXMsIGFzdC5hdHRycyksIFtdLCBbXSwgW10sIFtdLCBbXSwgZmFsc2UsIFtdLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuLCBhc3QuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uQ2FzZTsgfTtcbiAgICByZXR1cm4gTm9uQmluZGFibGVWaXNpdG9yO1xufSgpKTtcbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50T3JEaXJlY3RpdmVSZWYobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gRWxlbWVudE9yRGlyZWN0aXZlUmVmO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjbGFzc0F0dHJWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cbnZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX25nQ29udGVudEluZGV4TWF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gX3dpbGRjYXJkTmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQ29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBfbmdDb250ZW50SW5kZXhNYXRjaGVyLCBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyID0gX25nQ29udGVudEluZGV4TWF0Y2hlcjtcbiAgICAgICAgdGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IF93aWxkY2FyZE5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnByb3ZpZGVyQ29udGV4dCA9IHByb3ZpZGVyQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJDb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBjb21wb25lbnQuZGlyZWN0aXZlLnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBuZ0NvbnRlbnRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RvciA9IG5nQ29udGVudFNlbGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIG1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyLm1hdGNoKHNlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG5nQ29udGVudEluZGV4KSB7IG5nQ29udGVudEluZGljZXMucHVzaChuZ0NvbnRlbnRJbmRleCk7IH0pO1xuICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnNvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbmdDb250ZW50SW5kaWNlcy5wdXNoKHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZ0NvbnRlbnRJbmRpY2VzLmxlbmd0aCA+IDAgPyBuZ0NvbnRlbnRJbmRpY2VzWzBdIDogbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50Q29udGV4dDtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAqIEBwYXJhbSB7P30gYXR0cmlidXRlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbE5hbWVOb05zID0gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpWzFdO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxOYW1lTm9Ocyk7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWUgPSBhdHRyaWJ1dGVzW2ldWzBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShhdHRyTmFtZSlbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbaV1bMV07XG4gICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZU5vTnMsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChhdHRyTmFtZS50b0xvd2VyQ2FzZSgpID09IENMQVNTX0FUVFIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzZXMgPSBzcGxpdENsYXNzZXMoYXR0clZhbHVlKTtcbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBjc3NTZWxlY3Rvci5hZGRDbGFzc05hbWUoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xufVxudmFyIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCA9IG5ldyBFbGVtZW50Q29udGV4dCh0cnVlLCBuZXcgU2VsZWN0b3JNYXRjaGVyKCksIG51bGwsIG51bGwpO1xudmFyIE5PTl9CSU5EQUJMRV9WSVNJVE9SID0gbmV3IE5vbkJpbmRhYmxlVmlzaXRvcigpO1xuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0VtcHR5VGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gaXRlbXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKGl0ZW1zKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwID0gbmV3IE1hcCgpO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFtYXAuZ2V0KGl0ZW0udHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGl0ZW0udHlwZS5yZWZlcmVuY2UsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obWFwLnZhbHVlcygpKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlFeHByZXNzaW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSB7XG4gICAgICAgIGFzdCA9IGFzdC5hc3Q7XG4gICAgfVxuICAgIHJldHVybiBhc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxcbiAqIEBwYXJhbSB7P30gZW5hYmxlTGVnYWN5VGVtcGxhdGVcbiAqIEBwYXJhbSB7P30gcmVwb3J0RGVwcmVjYXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwsIGVuYWJsZUxlZ2FjeVRlbXBsYXRlLCByZXBvcnREZXByZWNhdGlvbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05vTnMgPSBzcGxpdE5zTmFtZShlbC5uYW1lKVsxXTtcbiAgICAvLyBgPG5nLXRlbXBsYXRlPmAgaXMgYW4gYW5ndWxhciBjb25zdHJ1Y3QgYW5kIGlzIGxvd2VyIGNhc2VcbiAgICBpZiAodGFnTm9OcyA9PT0gTkdfVEVNUExBVEVfRUxFTUVOVClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gYDx0ZW1wbGF0ZT5gIGlzIEhUTUwgYW5kIGNhc2UgaW5zZW5zaXRpdmVcbiAgICBpZiAodGFnTm9Ocy50b0xvd2VyQ2FzZSgpID09PSBURU1QTEFURV9FTEVNRU5UKSB7XG4gICAgICAgIGlmIChlbmFibGVMZWdhY3lUZW1wbGF0ZSAmJiB0YWdOb05zLnRvTG93ZXJDYXNlKCkgPT09IFRFTVBMQVRFX0VMRU1FTlQpIHtcbiAgICAgICAgICAgIHJlcG9ydERlcHJlY2F0aW9uKFRFTVBMQVRFX0VMRU1FTlRfREVQUkVDQVRJT05fV0FSTklORywgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGJ5IFVSTCB0aGF0IHRoZSBjb21waWxlciB1c2VzXG4gKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAqL1xudmFyIFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBSZXNvdXJjZUxvYWRlcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZSBhIHtcXEBsaW5rIFVybFJlc29sdmVyfSB3aXRoIG5vIHBhY2thZ2UgcHJlZml4LlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCgpIHtcbiAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKCk7XG59XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcignLicpO1xufVxuLyoqXG4gKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICovXG52YXIgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBQQUNLQUdFX1JPT1RfVVJMLFxuICAgIHVzZVZhbHVlOiAnLydcbn07XG4vKipcbiAqIFVzZWQgYnkgdGhlIHtcXEBsaW5rIENvbXBpbGVyfSB3aGVuIHJlc29sdmluZyBIVE1MIGFuZCBDU1MgdGVtcGxhdGUgVVJMcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge1xcQGxpbmsgQ29tcGlsZXJ9XG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIHtcXEBleGFtcGxlIGNvbXBpbGVyL3RzL3VybF9yZXNvbHZlci91cmxfcmVzb2x2ZXIudHMgcmVnaW9uPSd1cmxfcmVzb2x2ZXInfVxuICpcbiAqIFxcQHNlY3VyaXR5IFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdFxuICogZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuXG4gKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAqL1xudmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcGFja2FnZVByZWZpeFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgIGlmIChfcGFja2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IF9wYWNrYWdlUHJlZml4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9wYWNrYWdlUHJlZml4ID0gX3BhY2thZ2VQcmVmaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxuICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgKiAtIGlmIGB1cmxgIGlzIHJlbGF0aXZlICgncGF0aC90by9oZXJlJywgJy4vcGF0aC90by9oZXJlJyksIHRoZSByZXNvbHZlZCB1cmwgaXMgYSBjb21iaW5hdGlvbiBvZlxuICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXG4gICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgKiByZXR1cm5lZCBhcyBpcyAoaWdub3JpbmcgdGhlIGBiYXNlVXJsYClcbiAgICAgKiBAcGFyYW0gez99IGJhc2VVcmxcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVXJsUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkVXJsID0gdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCAhPSBudWxsICYmIGJhc2VVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQYXJ0cyA9IF9zcGxpdChyZXNvbHZlZFVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IHRoaXMuX3BhY2thZ2VQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggIT0gbnVsbCAmJiByZXNvbHZlZFBhcnRzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJlc29sdmVyO1xufSgpKTtcblVybFJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblVybFJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQQUNLQUdFX1JPT1RfVVJMLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gX3NwbGl0KHVybCk7XG4gICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaFtfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkgfHwgJyc7XG59XG4vKipcbiAqIEJ1aWxkcyBhIFVSSSBzdHJpbmcgZnJvbSBhbHJlYWR5LWVuY29kZWQgcGFydHMuXG4gKlxuICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxuICogdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Pz19IG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cbiAqIEBwYXJhbSB7Pz19IG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ1xcQCcuXG4gKiBAcGFyYW0gez89fSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gKiAgICAgVVJJLWVuY29kZWQuXG4gKiBAcGFyYW0gez89fSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gez89fSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxuICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAqIEBwYXJhbSB7Pz19IG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0gez89fSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxuICovXG5mdW5jdGlvbiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKG9wdF9zY2hlbWUsIG9wdF91c2VySW5mbywgb3B0X2RvbWFpbiwgb3B0X3BvcnQsIG9wdF9wYXRoLCBvcHRfcXVlcnlEYXRhLCBvcHRfZnJhZ21lbnQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXQgPSBbXTtcbiAgICBpZiAob3B0X3NjaGVtZSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgIH1cbiAgICBpZiAob3B0X2RvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICBpZiAob3B0X3VzZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgIGlmIChvcHRfcG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF9wYXRoICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0X3F1ZXJ5RGF0YSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0X2ZyYWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiB7XFxAbGluayBodHRwOi8vd3d3LmdiaXYuY29tL3Byb3RvY29scy91cmkvcmZjL3JmYzM5ODYuaHRtbCNSRkMyMjM0fSBzYXlzXG4gKiBBcyB0aGUgXCJmaXJzdC1tYXRjaC13aW5zXCIgYWxnb3JpdGhtIGlzIGlkZW50aWNhbCB0byB0aGUgXCJncmVlZHlcIlxuICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcbiAqIGNvbXBvbmVudHMgb2YgYSBVUkkgcmVmZXJlbmNlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcbiAqIHdlbGwtZm9ybWVkIFVSSSByZWZlcmVuY2UgaW50byBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiA8cHJlPlxuICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICogPC9wcmU+XG4gKlxuICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcbiAqIHBhcmVudGhlc2lzKS4gV2UgcmVmZXIgdG8gdGhlIHZhbHVlIG1hdGNoZWQgZm9yIHN1YmV4cHJlc3Npb24gPG4+IGFzICQ8bj4uXG4gKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAqIDxwcmU+XG4gKiAgICAgaHR0cDovL3d3dy5pY3MudWNpLmVkdS9wdWIvaWV0Zi91cmkvI1JlbGF0ZWRcbiAqIDwvcHJlPlxuICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHA6XG4gKiAgICAkMiA9IGh0dHBcbiAqICAgICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+XG4gKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gKiAgICAkOCA9ICNSZWxhdGVkXG4gKiAgICAkOSA9IFJlbGF0ZWRcbiAqIDwvcHJlPlxuICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXG4gKiBjYXNlIGZvciB0aGUgcXVlcnkgY29tcG9uZW50IGluIHRoZSBhYm92ZSBleGFtcGxlLiBUaGVyZWZvcmUsIHdlIGNhblxuICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gKiA8cHJlPlxuICogICAgc2NoZW1lICAgID0gJDJcbiAqICAgIGF1dGhvcml0eSA9ICQ0XG4gKiAgICBwYXRoICAgICAgPSAkNVxuICogICAgcXVlcnkgICAgID0gJDdcbiAqICAgIGZyYWdtZW50ICA9ICQ5XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcbiAqIHVzZXJJbmZvLCBkb21haW4sIGFuZCBwb3J0IHNlcGFyYXRlbHkgZnJvbSB0aGUgYXV0aG9yaXR5LlxuICogVGhlIG1vZGlmaWVkIHZlcnNpb24geWllbGRzXG4gKiA8cHJlPlxuICogICAgJDEgPSBodHRwICAgICAgICAgICAgICBzY2hlbWVcbiAqICAgICQyID0gPHVuZGVmaW5lZD4gICAgICAgdXNlckluZm8gLVxcXG4gKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgLS9cbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS8gICAgcGF0aFxuICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXG4gKiA8L3ByZT5cbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAnKD86JyArXG4gICAgJyhbXjovPyMuXSspJyArXG4gICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxuICAgIC8vID8sIC8sICMsIGFuZCAuXG4gICAgJzopPycgK1xuICAgICcoPzovLycgK1xuICAgICcoPzooW14vPyNdKilAKT8nICtcbiAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICtcbiAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxuICAgIC8vIGVzY2FwZXMsIGFuZCB1bmljb2RlIGNoYXJhY3RlcnMuXG4gICAgJyg/OjooWzAtOV0rKSk/JyArXG4gICAgJyk/JyArXG4gICAgJyhbXj8jXSspPycgK1xuICAgICcoPzpcXFxcPyhbXiNdKikpPycgK1xuICAgICcoPzojKC4qKSk/JyArXG4gICAgJyQnKTtcbnZhciBfQ29tcG9uZW50SW5kZXggPSB7fTtcbl9Db21wb25lbnRJbmRleC5TY2hlbWUgPSAxO1xuX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvID0gMjtcbl9Db21wb25lbnRJbmRleC5Eb21haW4gPSAzO1xuX0NvbXBvbmVudEluZGV4LlBvcnQgPSA0O1xuX0NvbXBvbmVudEluZGV4LlBhdGggPSA1O1xuX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YSA9IDY7XG5fQ29tcG9uZW50SW5kZXguRnJhZ21lbnQgPSA3O1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gXCJTY2hlbWVcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguVXNlckluZm9dID0gXCJVc2VySW5mb1wiO1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5Eb21haW5dID0gXCJEb21haW5cIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUG9ydF0gPSBcIlBvcnRcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBcIlBhdGhcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSA9IFwiUXVlcnlEYXRhXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSA9IFwiRnJhZ21lbnRcIjtcbi8qKlxuICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiBFYWNoIGNvbXBvbmVudCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBjb21wb25lbnQgaW5kaWNlczsgZm9yIGV4YW1wbGU6XG4gKiA8cHJlPlxuICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICogPC9wcmU+XG4gKlxuICogQHBhcmFtIHs/fSB1cmkgVGhlIFVSSSBzdHJpbmcgdG8gZXhhbWluZS5cbiAqIEByZXR1cm4gez99IEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICovXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuIHVyaS5tYXRjaChfc3BsaXRSZSk7XG59XG4vKipcbiAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIGluIGdpdmVuIHBhdGggY29tcG9uZW50LCBhcyBkZXNjcmliZWQgaW5cbiAqIFJGQyAzOTg2LCBzZWN0aW9uIDUuMi40LlxuICpcbiAqIEBwYXJhbSB7P30gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cbiAqIEByZXR1cm4gez99IFBhdGggY29tcG9uZW50IHdpdGggcmVtb3ZlZCBkb3Qgc2VnbWVudHMuXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKSB7XG4gICAgaWYgKHBhdGggPT0gJy8nKVxuICAgICAgICByZXR1cm4gJy8nO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlYWRpbmdTbGFzaCA9IHBhdGhbMF0gPT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhaWxpbmdTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0ID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXAgPSAwO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zID0gMDsgcG9zIDwgc2VnbWVudHMubGVuZ3RoOyBwb3MrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWdtZW50ID0gc2VnbWVudHNbcG9zXTtcbiAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XG4gICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcuLic6XG4gICAgICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXQucHVzaChzZWdtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVhZGluZ1NsYXNoID09ICcnKSB7XG4gICAgICAgIHdoaWxlICh1cC0tID4gMCkge1xuICAgICAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBvdXQucHVzaCgnLicpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhZGluZ1NsYXNoICsgb3V0LmpvaW4oJy8nKSArIHRyYWlsaW5nU2xhc2g7XG59XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHRoZSBwYXJ0cyBmcm9tIHNwbGl0IGFuZCBjYW5vbmljYWxpemVzIHRoZSBwYXRoIHBhcnRcbiAqIGFuZCB0aGVuIGpvaW5zIGFsbCB0aGUgcGFydHMuXG4gKiBAcGFyYW0gez99IHBhcnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIHBhdGggPSBwYXRoID09IG51bGwgPyAnJyA6IF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgIHJldHVybiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguVXNlckluZm9dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRG9tYWluXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlBvcnRdLCBwYXRoLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSk7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgVVJMLlxuICogQHBhcmFtIHs/fSBiYXNlIFRoZSBVUkwgYWN0aW5nIGFzIHRoZSBiYXNlIFVSTC5cbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVVybChiYXNlLCB1cmwpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IF9zcGxpdChlbmNvZGVVUkkodXJsKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVBhcnRzID0gX3NwbGl0KGJhc2UpO1xuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV07XG4gICAgfVxuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IF9Db21wb25lbnRJbmRleC5TY2hlbWU7IGkgPD0gX0NvbXBvbmVudEluZGV4LlBvcnQ7IGkrKykge1xuICAgICAgICBpZiAocGFydHNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXVswXSA9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhdGggPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIGlmIChwYXRoID09IG51bGwpXG4gICAgICAgIHBhdGggPSAnLyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSkgKyBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBEaXJlY3RpdmVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9yZXNvdXJjZUxvYWRlclxuICAgICAqIEBwYXJhbSB7P30gX3VybFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfaHRtbFBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2NvbmZpZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZU5vcm1hbGl6ZXIoX3Jlc291cmNlTG9hZGVyLCBfdXJsUmVzb2x2ZXIsIF9odG1sUGFyc2VyLCBfY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyID0gX3Jlc291cmNlTG9hZGVyO1xuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuY2xlYXIoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZWREaXJlY3RpdmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAobm9ybWFsaXplZERpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWREaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmRlbGV0ZShub3JtYWxpemVkRGlyZWN0aXZlLnRlbXBsYXRlLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgbm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKHN0eWxlc2hlZXQubW9kdWxlVXJsKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXIuZ2V0KHVybCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlbm9ybURhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHByZW5vcm1EYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkVGVtcGxhdGVBc3luYztcbiAgICAgICAgaWYgKHByZW5vcm1EYXRhLnRlbXBsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCInXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiJyBjb21wb25lbnQgY2Fubm90IGRlZmluZSBib3RoIHRlbXBsYXRlIGFuZCB0ZW1wbGF0ZVVybFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlbm9ybURhdGEudGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUaGUgdGVtcGxhdGUgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgPSB0aGlzLm5vcm1hbGl6ZVRlbXBsYXRlU3luYyhwcmVub3JtRGF0YSk7XG4gICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVBc3luYyA9IFByb21pc2UucmVzb2x2ZShub3JtYWxpemVkVGVtcGxhdGVTeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRoZSB0ZW1wbGF0ZVVybCBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCIgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMgPSB0aGlzLm5vcm1hbGl6ZVRlbXBsYXRlQXN5bmMocHJlbm9ybURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybWFsaXplZFRlbXBsYXRlU3luYyAmJiBub3JtYWxpemVkVGVtcGxhdGVTeW5jLnN0eWxlVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHN5bmMgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobm9ybWFsaXplZFRlbXBsYXRlU3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhc3luYyBjYXNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBub3JtYWxpemVkVGVtcGxhdGVBc3luYy50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkVGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUV4dGVybmFsU3R5bGVzaGVldHMobm9ybWFsaXplZFRlbXBsYXRlKTsgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZW5vbURhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlU3luYyA9IGZ1bmN0aW9uIChwcmVub21EYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKHByZW5vbURhdGEsIHByZW5vbURhdGEudGVtcGxhdGUsIHByZW5vbURhdGEubW9kdWxlVXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlbm9tRGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVBc3luYyA9IGZ1bmN0aW9uIChwcmVub21EYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlVXJsID0gdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShwcmVub21EYXRhLm1vZHVsZVVybCwgcHJlbm9tRGF0YS50ZW1wbGF0ZVVybCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCh0ZW1wbGF0ZVVybClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUocHJlbm9tRGF0YSwgdmFsdWUsIHRlbXBsYXRlVXJsKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZW5vcm1EYXRhXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVBYnNVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKHByZW5vcm1EYXRhLCB0ZW1wbGF0ZSwgdGVtcGxhdGVBYnNVcmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNJbmxpbmUgPSAhIXByZW5vcm1EYXRhLnRlbXBsYXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkocHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3ROb2Rlc0FuZEVycm9ycyA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlU291cmNlVXJsKHsgcmVmZXJlbmNlOiBwcmVub3JtRGF0YS5uZ01vZHVsZVR5cGUgfSwgeyB0eXBlOiB7IHJlZmVyZW5jZTogcHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSB9IH0sIHsgaXNJbmxpbmU6IGlzSW5saW5lLCB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwgfSksIHRydWUsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAocm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvclN0cmluZyA9IHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzID0gdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHN0eWxlczogcHJlbm9ybURhdGEuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiBwcmVub3JtRGF0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICBtb2R1bGVVcmw6IHByZW5vcm1EYXRhLm1vZHVsZVVybFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKTtcbiAgICAgICAgdmlzaXRBbGwodmlzaXRvciwgcm9vdE5vZGVzQW5kRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlU3R5bGVzID0gdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiB2aXNpdG9yLnN0eWxlcywgc3R5bGVVcmxzOiB2aXNpdG9yLnN0eWxlVXJscywgbW9kdWxlVXJsOiB0ZW1wbGF0ZUFic1VybCB9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuY2Fwc3VsYXRpb24gPSBwcmVub3JtRGF0YS5lbmNhcHN1bGF0aW9uO1xuICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gdGhpcy5fY29uZmlnLmRlZmF1bHRFbmNhcHN1bGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZVVybHMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlVXJscy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVVcmxzKTtcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT09IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkICYmIHN0eWxlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHN0eWxlVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZUFic1VybCwgc3R5bGVzOiBzdHlsZXMsIHN0eWxlVXJsczogc3R5bGVVcmxzLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB2aXNpdG9yLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHByZW5vcm1EYXRhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBwcmVub3JtRGF0YS5pbnRlcnBvbGF0aW9uLCBpc0lubGluZTogaXNJbmxpbmVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlTWV0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyh0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGV4dGVybmFsU3R5bGVzaGVldHMpIHsgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVNZXRhLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGVtcGxhdGVNZXRhLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRlbXBsYXRlTWV0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogdGVtcGxhdGVNZXRhLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICBpc0lubGluZTogdGVtcGxhdGVNZXRhLmlzSW5saW5lLFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlVXJsc1xuICAgICAqIEBwYXJhbSB7Pz19IGxvYWRlZFN0eWxlc2hlZXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzID0gZnVuY3Rpb24gKHN0eWxlVXJscywgbG9hZGVkU3R5bGVzaGVldHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxvYWRlZFN0eWxlc2hlZXRzID09PSB2b2lkIDApIHsgbG9hZGVkU3R5bGVzaGVldHMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgIC5hbGwoc3R5bGVVcmxzLmZpbHRlcihmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuICFsb2FkZWRTdHlsZXNoZWV0cy5oYXMoc3R5bGVVcmwpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIF90aGlzLl9mZXRjaChzdHlsZVVybCkudGhlbihmdW5jdGlvbiAobG9hZGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc2hlZXQgPSBfdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBbbG9hZGVkU3R5bGVdLCBtb2R1bGVVcmw6IHN0eWxlVXJsIH0pKTtcbiAgICAgICAgICAgIGxvYWRlZFN0eWxlc2hlZXRzLnNldChzdHlsZVVybCwgc3R5bGVzaGVldCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyhzdHlsZXNoZWV0LnN0eWxlVXJscywgbG9hZGVkU3R5bGVzaGVldHMpO1xuICAgICAgICB9KTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gQXJyYXkuZnJvbShsb2FkZWRTdHlsZXNoZWV0cy52YWx1ZXMoKSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNoZWV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsU3R5bGVVcmxzID0gc3R5bGVzaGVldC5zdHlsZVVybHMuZmlsdGVyKGlzU3R5bGVVcmxSZXNvbHZhYmxlKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodXJsKSB7IHJldHVybiBfdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShzdHlsZXNoZWV0Lm1vZHVsZVVybCwgdXJsKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFN0eWxlcyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUkJDEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlV2l0aEltcG9ydHMgPSBleHRyYWN0U3R5bGVVcmxzKF90aGlzLl91cmxSZXNvbHZlciwgc3R5bGVzaGVldC5tb2R1bGVVcmwsIHN0eWxlJCQxKTtcbiAgICAgICAgICAgIGFsbFN0eWxlVXJscy5wdXNoLmFwcGx5KGFsbFN0eWxlVXJscywgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IGFsbFN0eWxlcywgc3R5bGVVcmxzOiBhbGxTdHlsZVVybHMsIG1vZHVsZVVybDogc3R5bGVzaGVldC5tb2R1bGVVcmwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlTm9ybWFsaXplcjtcbn0oKSk7XG5EaXJlY3RpdmVOb3JtYWxpemVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRpcmVjdGl2ZU5vcm1hbGl6ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZXNvdXJjZUxvYWRlciwgfSxcbiAgICB7IHR5cGU6IFVybFJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogSHRtbFBhcnNlciwgfSxcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuXTsgfTtcbnZhciBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKSB7XG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gW107XG4gICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICBzd2l0Y2ggKHByZXBhcnNlZEVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5zZWxlY3RBdHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRDb250ZW50XzEgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnRfMSArPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2godGV4dENvbnRlbnRfMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMucHVzaChwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdmlzaXRBbGwodGhpcywgYXN0LmNhc2VzKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9fYXNzaWduID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIERpcmVjdGl2ZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcmVmbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSDJtXJlZmxlY3RvcjsgfVxuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIHJldHVybiB0eXBlTWV0YWRhdGEgJiYgdHlwZU1ldGFkYXRhLnNvbWUoaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge1xcQGxpbmsgRGlyZWN0aXZlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgaWYgKHR5cGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YWRhdGEgPSBmaW5kTGFzdCh0eXBlTWV0YWRhdGEsIGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcGVydHlNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5wcm9wTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEobWV0YWRhdGEsIHByb3BlcnR5TWV0YWRhdGEsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIERpcmVjdGl2ZSBhbm5vdGF0aW9uIGZvdW5kIG9uIFwiICsgybVzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkbVxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlNZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhID0gZnVuY3Rpb24gKGRtLCBwcm9wZXJ0eU1ldGFkYXRhLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3QgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0eU1ldGFkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXQgPSBmaW5kTGFzdChwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBJbnB1dDsgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIGlucHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dCA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIE91dHB1dDsgfSk7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIG91dHB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICYmIGEgaW5zdGFuY2VvZiBIb3N0QmluZGluZzsgfSk7XG4gICAgICAgICAgICBob3N0QmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFdpdGggPSBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRXaXRoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBjYW4gbm90IGJpbmQgdG8gZXZlbnRzLiBVc2UgQEhvc3RMaXN0ZW5lciBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydFdpdGggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBwcm9wZXJ0eSBuYW1lLCAnY2xhc3MuPG5hbWU+Jywgb3IgJ2F0dHIuPG5hbWU+Jy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaG9zdFtcIltcIiArIGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIl0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RbXCJbXCIgKyBwcm9wTmFtZSArIFwiXVwiXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdExpc3RlbmVycyA9IHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAmJiBhIGluc3RhbmNlb2YgSG9zdExpc3RlbmVyOyB9KTtcbiAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGhvc3RMaXN0ZW5lci5hcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGhvc3RbXCIoXCIgKyBob3N0TGlzdGVuZXIuZXZlbnROYW1lICsgXCIpXCJdID0gcHJvcE5hbWUgKyBcIihcIiArIGFyZ3Muam9pbignLCcpICsgXCIpXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgUXVlcnk7IH0pO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcXVlcmllc1twcm9wTmFtZV0gPSBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShkbSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBkaXJlY3RpdmVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX2V4dHJhY3RQdWJsaWNOYW1lID0gZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gc3BsaXRBdENvbG9uKGRlZiwgW251bGwsIGRlZl0pWzFdLnRyaW0oKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGJpbmRpbmdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX2RlZHVwZUJpbmRpbmdzID0gZnVuY3Rpb24gKGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXZlcnNlZFJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBnbyBsYXN0IHRvIGZpcnN0IHRvIGFsbG93IGxhdGVyIGVudHJpZXMgdG8gb3ZlcndyaXRlIHByZXZpb3VzIGVudHJpZXNcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gYmluZGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9leHRyYWN0UHVibGljTmFtZShiaW5kaW5nKTtcbiAgICAgICAgICAgIGlmICghbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldmVyc2VkUmVzdWx0LnB1c2goYmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldmVyc2VkUmVzdWx0LnJldmVyc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0gez99IG91dHB1dHNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJpZXNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVyZ2VkSW5wdXRzID0gdGhpcy5fZGVkdXBlQmluZGluZ3MoZGlyZWN0aXZlLmlucHV0cyA/IGRpcmVjdGl2ZS5pbnB1dHMuY29uY2F0KGlucHV0cykgOiBpbnB1dHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRPdXRwdXRzID0gdGhpcy5fZGVkdXBlQmluZGluZ3MoZGlyZWN0aXZlLm91dHB1dHMgPyBkaXJlY3RpdmUub3V0cHV0cy5jb25jYXQob3V0cHV0cykgOiBvdXRwdXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVyZ2VkSG9zdCA9IGRpcmVjdGl2ZS5ob3N0ID8gX19hc3NpZ24oe30sIGRpcmVjdGl2ZS5ob3N0LCBob3N0KSA6IGhvc3Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZFF1ZXJpZXMgPSBkaXJlY3RpdmUucXVlcmllcyA/IF9fYXNzaWduKHt9LCBkaXJlY3RpdmUucXVlcmllcywgcXVlcmllcykgOiBxdWVyaWVzO1xuICAgICAgICBpZiAoZGlyZWN0aXZlIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogZGlyZWN0aXZlLm1vZHVsZUlkLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBkaXJlY3RpdmUudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpcmVjdGl2ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGlyZWN0aXZlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgIHN0eWxlczogZGlyZWN0aXZlLnN0eWxlcyxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpcmVjdGl2ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZGlyZWN0aXZlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogZGlyZWN0aXZlLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyZWN0aXZlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlUmVzb2x2ZXI7XG59KCkpO1xuRGlyZWN0aXZlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRGlyZWN0aXZlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiDJtVJlZmxlY3RvclJlYWRlciwgfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNEaXJlY3RpdmVNZXRhZGF0YSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBEaXJlY3RpdmU7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGFyclxuICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZpbmRMYXN0KGFyciwgY29uZGl0aW9uKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTVFJJUF9TUkNfRklMRV9TVUZGSVhFUyA9IC8oXFwudHN8XFwuZFxcLnRzfFxcLmpzfFxcLmpzeHxcXC50c3gpJC87XG52YXIgTkdfRkFDVE9SWSA9IC9cXC5uZ2ZhY3RvcnlcXC4vO1xuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZ2ZhY3RvcnlGaWxlUGF0aChmaWxlUGF0aCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybFdpdGhTdWZmaXggPSBzcGxpdFR5cGVzY3JpcHRTdWZmaXgoZmlsZVBhdGgpO1xuICAgIHJldHVybiB1cmxXaXRoU3VmZml4WzBdICsgXCIubmdmYWN0b3J5XCIgKyB1cmxXaXRoU3VmZml4WzFdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpcE5nRmFjdG9yeShmaWxlUGF0aCkge1xuICAgIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKE5HX0ZBQ1RPUlksICcuJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTmdGYWN0b3J5RmlsZShmaWxlUGF0aCkge1xuICAgIHJldHVybiBOR19GQUNUT1JZLnRlc3QoZmlsZVBhdGgpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy5kLnRzJykpIHtcbiAgICAgICAgcmV0dXJuIFtwYXRoLnNsaWNlKDAsIC01KSwgJy50cyddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0RG90ID0gcGF0aC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIGxhc3REb3QpLCBwYXRoLnN1YnN0cmluZyhsYXN0RG90KV07XG4gICAgfVxuICAgIHJldHVybiBbcGF0aCwgJyddO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdW1tYXJ5RmlsZU5hbWUoZmlsZU5hbWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlTmFtZVdpdGhvdXRTdWZmaXggPSBmaWxlTmFtZS5yZXBsYWNlKFNUUklQX1NSQ19GSUxFX1NVRkZJWEVTLCAnJyk7XG4gICAgcmV0dXJuIGZpbGVOYW1lV2l0aG91dFN1ZmZpeCArIFwiLm5nc3VtbWFyeS5qc29uXCI7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gaG9va1xuICogQHBhcmFtIHs/fSB0b2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzTGlmZWN5Y2xlSG9vayhob29rLCB0b2tlbikge1xuICAgIHJldHVybiDJtXJlZmxlY3Rvci5oYXNMaWZlY3ljbGVIb29rKHRva2VuLCBnZXRIb29rTmFtZShob29rKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaG9va1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0SG9va05hbWUoaG9vaykge1xuICAgIHN3aXRjaCAoaG9vaykge1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuT25Jbml0OlxuICAgICAgICAgICAgcmV0dXJuICduZ09uSW5pdCc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3k6XG4gICAgICAgICAgICByZXR1cm4gJ25nT25EZXN0cm95JztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICByZXR1cm4gJ25nRG9DaGVjayc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XG4gICAgICAgICAgICByZXR1cm4gJ25nT25DaGFuZ2VzJztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJDb250ZW50SW5pdCc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudENoZWNrZWQnO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdJbml0JztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3Q2hlY2tlZCc7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzTmdNb2R1bGVNZXRhZGF0YShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTmdNb2R1bGU7XG59XG4vKipcbiAqIFJlc29sdmVzIHR5cGVzIHRvIHtcXEBsaW5rIE5nTW9kdWxlfS5cbiAqL1xudmFyIE5nTW9kdWxlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9yZWZsZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gybVyZWZsZWN0b3I7IH1cbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZVJlc29sdmVyLnByb3RvdHlwZS5pc05nTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKS5zb21lKF9pc05nTW9kdWxlTWV0YWRhdGEpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVNZXRhID0gZmluZExhc3QodGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpLCBfaXNOZ01vZHVsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKG5nTW9kdWxlTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5nTW9kdWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOZ01vZHVsZSBtZXRhZGF0YSBmb3VuZCBmb3IgJ1wiICsgybVzdHJpbmdpZnkodHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZVJlc29sdmVyO1xufSgpKTtcbk5nTW9kdWxlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuTmdNb2R1bGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IMm1UmVmbGVjdG9yUmVhZGVyLCB9LFxuXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNQaXBlTWV0YWRhdGEodHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgUGlwZTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige1xcQGxpbmsgUGlwZX0uXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICpcbiAqIFNlZSB7XFxAbGluayBDb21waWxlcn1cbiAqL1xudmFyIFBpcGVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX3JlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBpcGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IMm1cmVmbGVjdG9yOyB9XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICByZXR1cm4gdHlwZU1ldGFkYXRhICYmIHR5cGVNZXRhZGF0YS5zb21lKF9pc1BpcGVNZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge1xcQGxpbmsgUGlwZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhcyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIGlmIChtZXRhcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbiA9IGZpbmRMYXN0KG1ldGFzLCBfaXNQaXBlTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIMm1c3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlUmVzb2x2ZXI7XG59KCkpO1xuUGlwZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBpcGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IMm1UmVmbGVjdG9yUmVhZGVyLCB9LFxuXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTdW1tYXJ5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1bW1hcnlSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5pc0xpYnJhcnlGaWxlID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRMaWJyYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZVN1bW1hcnkgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IHJldHVybiBudWxsOyB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkgeyByZXR1cm4gW107IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW1wb3J0QXMgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IHJldHVybiByZWZlcmVuY2U7IH07XG4gICAgcmV0dXJuIFN1bW1hcnlSZXNvbHZlcjtcbn0oKSk7XG5TdW1tYXJ5UmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU3VtbWFyeVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRVJST1JfQ09MTEVDVE9SX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdFcnJvckNvbGxlY3RvcicpO1xudmFyIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9uZ01vZHVsZVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfZGlyZWN0aXZlUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9waXBlUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9zdW1tYXJ5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gX2RpcmVjdGl2ZU5vcm1hbGl6ZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25zb2xlXG4gICAgICogQHBhcmFtIHs/fSBfc3RhdGljU3ltYm9sQ2FjaGVcbiAgICAgKiBAcGFyYW0gez89fSBfcmVmbGVjdG9yXG4gICAgICogQHBhcmFtIHs/PX0gX2Vycm9yQ29sbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX2NvbmZpZywgX25nTW9kdWxlUmVzb2x2ZXIsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3BpcGVSZXNvbHZlciwgX3N1bW1hcnlSZXNvbHZlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfZGlyZWN0aXZlTm9ybWFsaXplciwgX2NvbnNvbGUsIF9zdGF0aWNTeW1ib2xDYWNoZSwgX3JlZmxlY3RvciwgX2Vycm9yQ29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IMm1cmVmbGVjdG9yOyB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUgPSBfc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yID0gX2Vycm9yQ29sbGVjdG9yO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9waXBlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZGVsZXRlKHR5cGUpO1xuICAgICAgICAvLyBDbGVhciBhbGwgb2YgdGhlIE5nTW9kdWxlIGFzIHRoZXkgY29udGFpbiB0cmFuc2l0aXZlIGluZm9ybWF0aW9uIVxuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIGlmIChkaXJNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGVGb3IoZGlyTWV0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiYXNlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9jcmVhdGVQcm94eUNsYXNzID0gZnVuY3Rpb24gKGJhc2VUeXBlLCBuYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJveHlDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ2xhc3MgXCIgKyBuYW1lICsgXCIgZm9yIHR5cGUgXCIgKyDJtXN0cmluZ2lmeShiYXNlVHlwZSkgKyBcIiBpcyBub3QgY29tcGlsZWQgeWV0IVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJveHlDbGFzcy5zZXREZWxlZ2F0ZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZSA9IGQ7XG4gICAgICAgICAgICAoKHByb3h5Q2xhc3MpKS5wcm90b3R5cGUgPSBkLnByb3RvdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWFrZSBzdHJpbmdpZnkgd29yayBjb3JyZWN0bHlcbiAgICAgICAgKChwcm94eUNsYXNzKSkub3ZlcnJpZGRlbk5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gcHJveHlDbGFzcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEdlbmVyYXRlZENsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb3h5Q2xhc3MoZGlyVHlwZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldENvbXBvbmVudFZpZXdDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYXRlZENsYXNzKGRpclR5cGUsIHZpZXdDbGFzc05hbWUoZGlyVHlwZSwgMCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYXRlZENsYXNzKGRpclR5cGUsIGhvc3RWaWV3Q2xhc3NOYW1lKGRpclR5cGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEhvc3RDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBkaXJUeXBlIH0pICsgXCJfSG9zdFwiO1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChkaXJUeXBlLmZpbGVQYXRoLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEhvc3RDbGFzcyA9IChmdW5jdGlvbiBIb3N0Q2xhc3MoKSB7IH0pO1xuICAgICAgICAgICAgSG9zdENsYXNzLm92ZXJyaWRkZW5OYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBIb3N0Q2xhc3M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFJlbmRlcmVyVHlwZSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCByZW5kZXJlclR5cGVOYW1lKGRpclR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBhbiBvYmplY3QgYXMgcHJveHksXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGZpbGwgbGF0ZXIgZHVyaW5nIHJ1bnRpbWUgY29tcGlsYXRpb24uXG4gICAgICAgICAgICByZXR1cm4gKHt9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRzXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyVHlwZSwgaW5wdXRzLCBvdXRwdXRzKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCBjb21wb25lbnRGYWN0b3J5TmFtZShkaXJUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0VmlldyA9IHRoaXMuZ2V0SG9zdENvbXBvbmVudFZpZXdDbGFzcyhkaXJUeXBlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5nQ29udGVudFNlbGVjdG9ycyB3aWxsIGJlIGZpbGxlZCBsYXRlciBvbmNlIHRoZSB0ZW1wbGF0ZSBpc1xuICAgICAgICAgICAgLy8gbG9hZGVkLlxuICAgICAgICAgICAgcmV0dXJuIMm1Y2NmKHNlbGVjdG9yLCBkaXJUeXBlLCAvKiogQHR5cGUgez99ICovIChob3N0VmlldyksIGlucHV0cywgb3V0cHV0cywgW10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZhY3RvcnlcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudFNlbGVjdG9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmluaXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGZhY3RvcnksIG5nQ29udGVudFNlbGVjdG9ycykge1xuICAgICAgICBpZiAoIShmYWN0b3J5IGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgKF9hID0gZmFjdG9yeS5uZ0NvbnRlbnRTZWxlY3RvcnMpLnB1c2guYXBwbHkoX2EsIG5nQ29udGVudFNlbGVjdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBraW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRTdW1tYXJ5ID0gZnVuY3Rpb24gKHR5cGUsIGtpbmQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZVN1bW1hcnkgPSB0aGlzLl9zdW1tYXJ5Q2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXR5cGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5fc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHR5cGUpO1xuICAgICAgICAgICAgdHlwZVN1bW1hcnkgPSBzdW1tYXJ5ID8gc3VtbWFyeS50eXBlIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5zZXQodHlwZSwgdHlwZVN1bW1hcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlU3VtbWFyeSAmJiB0eXBlU3VtbWFyeS5zdW1tYXJ5S2luZCA9PT0ga2luZCA/IHR5cGVTdW1tYXJ5IDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZERpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSwgZGlyZWN0aXZlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3RpdmVDYWNoZS5oYXMoZGlyZWN0aXZlVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Tm9uTm9ybWFsaXplZERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpLCBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgbWV0YWRhdGEgPSBfYS5tZXRhZGF0YTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAodGVtcGxhdGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZERpck1ldGEgPSBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRhZGF0YS50eXBlLFxuICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiBtZXRhZGF0YS5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogbWV0YWRhdGEuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IG1ldGFkYXRhLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogbWV0YWRhdGEuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWV0YWRhdGEuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1ldGFkYXRhLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyczogbWV0YWRhdGEuaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBob3N0UHJvcGVydGllczogbWV0YWRhdGEuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IG1ldGFkYXRhLmhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogbWV0YWRhdGEucHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IG1ldGFkYXRhLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWV0YWRhdGEucXVlcmllcyxcbiAgICAgICAgICAgICAgICB2aWV3UXVlcmllczogbWV0YWRhdGEudmlld1F1ZXJpZXMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBtZXRhZGF0YS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IG1ldGFkYXRhLmNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogbWV0YWRhdGEucmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YWRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0Q29tcG9uZW50RmFjdG9yeShtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5LCB0ZW1wbGF0ZU1ldGFkYXRhLm5nQ29udGVudFNlbGVjdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZGlyZWN0aXZlQ2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG5vcm1hbGl6ZWREaXJNZXRhKTtcbiAgICAgICAgICAgIF90aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG5vcm1hbGl6ZWREaXJNZXRhLnRvU3VtbWFyeSgpKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRGlyTWV0YTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU1ldGEgPSB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLm5vcm1hbGl6ZVRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZVR5cGU6IG5nTW9kdWxlVHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlOiBkaXJlY3RpdmVUeXBlLFxuICAgICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcG9uZW50TW9kdWxlVXJsKHRoaXMuX3JlZmxlY3RvciwgZGlyZWN0aXZlVHlwZSwgYW5ub3RhdGlvbiksXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogbWV0YWRhdGEudGVtcGxhdGUuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbWV0YWRhdGEudGVtcGxhdGUudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IG1ldGFkYXRhLnRlbXBsYXRlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgIHN0eWxlczogbWV0YWRhdGEudGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogbWV0YWRhdGEudGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IG1ldGFkYXRhLnRlbXBsYXRlLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogbWV0YWRhdGEudGVtcGxhdGUuaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVNZXRhLnN5bmNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSh0ZW1wbGF0ZU1ldGEuc3luY1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yKGRpcmVjdGl2ZVR5cGUpLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZU1ldGEuYXN5bmNSZXN1bHQudGhlbihjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgICAgIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGRpcmVjdGl2ZVR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZihkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKCFkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWNoZUVudHJ5ID0gdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YTtcbiAgICAgICAgaWYgKGRpck1ldGEgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlcycsIGRpck1ldGEuc3R5bGVzKTtcbiAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZVVybHMnLCBkaXJNZXRhLnN0eWxlVXJscyk7XG4gICAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIGRpck1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25zID0gZGlyTWV0YS5hbmltYXRpb25zO1xuICAgICAgICAgICAgbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPSBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGRpck1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGlyTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGlyTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IGRpck1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogZGlyTWV0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBkaXJNZXRhLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAgICAgaXNJbmxpbmU6ICEhZGlyTWV0YS50ZW1wbGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UHJvdmlkZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBkaXJNZXRhLnNlbGVjdG9yO1xuICAgICAgICBpZiAoZGlyTWV0YSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGRpck1ldGEuY2hhbmdlRGV0ZWN0aW9uO1xuICAgICAgICAgICAgaWYgKGRpck1ldGEudmlld1Byb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnZpZXdQcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwidmlld1Byb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gZmxhdHRlbkFuZERlZHVwZUFycmF5KGRpck1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSh0eXBlKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChlbnRyeUNvbXBvbmVudE1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlyZWN0aXZlXG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCIgaGFzIG5vIHNlbGVjdG9yLCBwbGVhc2UgYWRkIGl0IVwiKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICBpZiAoZGlyTWV0YS5wcm92aWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwicHJvdmlkZXJzIGZvciBcXFwiXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCJcXFwiXCIsIFtdLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdRdWVyaWVzID0gW107XG4gICAgICAgIGlmIChkaXJNZXRhLnF1ZXJpZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcmllcyA9IHRoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIGZhbHNlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzID0gdGhpcy5fZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgdHJ1ZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YWRhdGEgPSBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJNZXRhLmV4cG9ydEFzLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IGRpck1ldGEub3V0cHV0cyxcbiAgICAgICAgICAgIGhvc3Q6IGRpck1ldGEuaG9zdCxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsXG4gICAgICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldENvbXBvbmVudFZpZXdDbGFzcyhkaXJlY3RpdmVUeXBlKSA6XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSA/IHRoaXMuZ2V0UmVuZGVyZXJUeXBlKGRpcmVjdGl2ZVR5cGUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgZGlyZWN0aXZlVHlwZSwgbWV0YWRhdGEuaW5wdXRzLCBtZXRhZGF0YS5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZUVudHJ5ID0geyBtZXRhZGF0YTogbWV0YWRhdGEsIGFubm90YXRpb246IGRpck1ldGEgfTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIGRpcmVjdGl2ZS5cbiAgICAgKiBUaGlzIGFzc3VtZXMgYGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YWAgaGFzIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldERpcmVjdGl2ZU1ldGFkYXRhIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEgZm9yIGEgbW9kdWxlIHRoYXQgZGVjbGFyZXMgaXQuIERpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIi5cIiksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlU3VtbWFyeSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpclN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkoZGlyVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkpO1xuICAgICAgICBpZiAoIWRpclN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ291bGQgbm90IGxvYWQgdGhlIHN1bW1hcnkgZm9yIGRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGlyVHlwZSkgKyBcIi5cIiksIGRpclR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJTdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIuaXNEaXJlY3RpdmUodHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNQaXBlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUodHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVTdW1tYXJ5ID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlU3VtbWFyeSA9ICh0aGlzLl9sb2FkU3VtbWFyeShtb2R1bGVUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpKTtcbiAgICAgICAgaWYgKCFtb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhID0gdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgIG1vZHVsZVN1bW1hcnkgPSBtb2R1bGVNZXRhID8gbW9kdWxlTWV0YS50b1N1bW1hcnkoKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5zZXQobW9kdWxlVHlwZSwgbW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZVN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgZGVjbGFyZWQgZGlyZWN0aXZlcyBhbmQgcGlwZXMgb2YgYW4gTmdNb2R1bGUuXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSB0aGlzLmdldE5nTW9kdWxlTWV0YWRhdGEobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9hZGluZyA9IFtdO1xuICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb21pc2UgPSBfdGhpcy5fbG9hZERpcmVjdGl2ZU1ldGFkYXRhKG1vZHVsZVR5cGUsIGlkLnJlZmVyZW5jZSwgaXNTeW5jKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZ01vZHVsZS5kZWNsYXJlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiBfdGhpcy5fbG9hZFBpcGVNZXRhZGF0YShpZC5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICBtb2R1bGVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYobW9kdWxlVHlwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVNZXRhID0gdGhpcy5fbmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgIGlmIChjb21waWxlTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGEgPSB0aGlzLl9uZ01vZHVsZVJlc29sdmVyLnJlc29sdmUobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJlZFBpcGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydGVkTW9kdWxlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib290c3RyYXBDb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVtYXMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGEuaW1wb3J0cykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuaW1wb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0ZWRNb2R1bGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVHlwZShpbXBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wb3J0ZWRUeXBlICYmIGltcG9ydGVkVHlwZS5uZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVXaXRoUHJvdmlkZXJzID0gaW1wb3J0ZWRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBtb2R1bGVXaXRoUHJvdmlkZXJzLm5nTW9kdWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoLmFwcGx5KHByb3ZpZGVycywgX3RoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKG1vZHVsZVdpdGhQcm92aWRlcnMucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGltcG9ydGVkTW9kdWxlVHlwZSkgKyBcIidcIiwgW10sIGltcG9ydGVkVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jaGVja1NlbGZJbXBvcnQobW9kdWxlVHlwZSwgaW1wb3J0ZWRNb2R1bGVUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5ID0gX3RoaXMuZ2V0TmdNb2R1bGVTdW1tYXJ5KGltcG9ydGVkTW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGltcG9ydGVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnlUeXBlKGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInLiBQbGVhc2UgYWRkIGEgQE5nTW9kdWxlIGFubm90YXRpb24uXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZXMucHVzaChpbXBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmV4cG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZXhwb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoZXhwb3J0ZWRUeXBlKSArIFwiJyBleHBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkTW9kdWxlU3VtbWFyeSA9IF90aGlzLmdldE5nTW9kdWxlU3VtbWFyeShleHBvcnRlZFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzLnB1c2goZXhwb3J0ZWRNb2R1bGVTdW1tYXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMucHVzaChfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKGV4cG9ydGVkVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgd2lsbCBiZSBtb2RpZmllZCBsYXRlciwgc28gd2UgcmVseSBvblxuICAgICAgICAvLyBnZXR0aW5nIGEgbmV3IGluc3RhbmNlIGV2ZXJ5IHRpbWUhXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpdmVNb2R1bGUgPSB0aGlzLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YShpbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcyk7XG4gICAgICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZGVjbGFyYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJlZElkZW50aWZpZXIgPSBfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5pc0RpcmVjdGl2ZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRGlyZWN0aXZlKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUeXBlVG9Nb2R1bGUoZGVjbGFyZWRUeXBlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZFBpcGUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmVkUGlwZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRlY2xhcmVkVHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGRlY2xhcmVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnlUeXBlKGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInLiBQbGVhc2UgYWRkIGEgQFBpcGUvQERpcmVjdGl2ZS9AQ29tcG9uZW50IGFubm90YXRpb24uXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkRGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRlZFBpcGVzID0gW107XG4gICAgICAgIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRJZCkge1xuICAgICAgICAgICAgaWYgKHRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlc1NldC5oYXMoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzLnB1c2goZXhwb3J0ZWRJZCk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRFeHBvcnRlZERpcmVjdGl2ZShleHBvcnRlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuaGFzKGV4cG9ydGVkSWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydGVkUGlwZXMucHVzaChleHBvcnRlZElkKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZEV4cG9ydGVkUGlwZShleHBvcnRlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkNhbid0IGV4cG9ydCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihleHBvcnRlZElkLnJlZmVyZW5jZSkgKyBcIiBcIiArIHN0cmluZ2lmeVR5cGUoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpICsgXCIgZnJvbSBcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIiBhcyBpdCB3YXMgbmVpdGhlciBkZWNsYXJlZCBub3IgaW1wb3J0ZWQhXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgcHJvdmlkZXJzIG9mIHRoZSBtb2R1bGUgaGF2ZSB0byBnbyBsYXN0XG4gICAgICAgIC8vIHNvIHRoYXQgdGhleSBvdmVyd3JpdGUgYW55IG90aGVyIHByb3ZpZGVyIHdlIGFscmVhZHkgYWRkZWQuXG4gICAgICAgIGlmIChtZXRhLnByb3ZpZGVycykge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2guYXBwbHkocHJvdmlkZXJzLCB0aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShtZXRhLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiLCBbXSwgbW9kdWxlVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEodHlwZSk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5ib290c3RyYXApIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmJvb3RzdHJhcCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCInIHVzZWQgaW4gdGhlIGJvb3RzdHJhcCBwcm9wZXJ0eSBvZiBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50cy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEodHlwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEodHlwZS5yZWZlcmVuY2UpOyB9KSk7XG4gICAgICAgIGlmIChtZXRhLnNjaGVtYXMpIHtcbiAgICAgICAgICAgIHNjaGVtYXMucHVzaC5hcHBseShzY2hlbWFzLCBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5zY2hlbWFzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZU1ldGEgPSBuZXcgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKG1vZHVsZVR5cGUpLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHM6IGJvb3RzdHJhcENvbXBvbmVudHMsXG4gICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzOiBkZWNsYXJlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IGV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGRlY2xhcmVkUGlwZXM6IGRlY2xhcmVkUGlwZXMsXG4gICAgICAgICAgICBleHBvcnRlZFBpcGVzOiBleHBvcnRlZFBpcGVzLFxuICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzOiBpbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICBleHBvcnRlZE1vZHVsZXM6IGV4cG9ydGVkTW9kdWxlcyxcbiAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGU6IHRyYW5zaXRpdmVNb2R1bGUsXG4gICAgICAgICAgICBpZDogbWV0YS5pZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdHJhbnNpdGl2ZU1vZHVsZS5hZGRFbnRyeUNvbXBvbmVudChpZCk7IH0pO1xuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHRyYW5zaXRpdmVNb2R1bGUuYWRkUHJvdmlkZXIocHJvdmlkZXIsIGNvbXBpbGVNZXRhLnR5cGUpOyB9KTtcbiAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRNb2R1bGUoY29tcGlsZU1ldGEudHlwZSk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuc2V0KG1vZHVsZVR5cGUsIGNvbXBpbGVNZXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZE1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY2hlY2tTZWxmSW1wb3J0ID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICBpZiAobW9kdWxlVHlwZSA9PT0gaW1wb3J0ZWRNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIidcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicgbW9kdWxlIGNhbid0IGltcG9ydCBpdHNlbGZcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RpcmVjdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncGlwZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIuaXNOZ01vZHVsZSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb2R1bGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKHR5cGUpKS5wcm92aWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Byb3ZpZGVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGRUeXBlVG9Nb2R1bGUgPSBmdW5jdGlvbiAodHlwZSwgbW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUeXBlIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiISBcIiArXG4gICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLlwiKSksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGltcG9ydGVkTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gZXhwb3J0ZWRNb2R1bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbmV3IFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgaW1wb3J0ZWRNb2R1bGVzLmNvbmNhdChleHBvcnRlZE1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG1vZFN1bW1hcnkpIHtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHsgcmV0dXJuIHJlc3VsdC5hZGRNb2R1bGUobW9kKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiByZXN1bHQuYWRkRW50cnlDb21wb25lbnQoY29tcCk7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkZWRUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UoZW50cnkucHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZNb2R1bGVzID0gbW9kdWxlc0J5VG9rZW4uZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzQnlUb2tlbi5zZXQodG9rZW5SZWYsIHByZXZNb2R1bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlUmVmID0gZW50cnkubW9kdWxlLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcHJvdmlkZXJzIG9mIG9uZSBtb2R1bGUgbWF5IHN0aWxsIGNvbnRhaW4gbXVsdGlwbGUgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLy8gcGVyIHRva2VuIChlLmcuIGZvciBtdWx0aSBwcm92aWRlcnMpLCBhbmQgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGVzZS5cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRUb2tlbnMuaGFzKHRva2VuUmVmKSB8fCAhcHJldk1vZHVsZXMuaGFzKG1vZHVsZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMuYWRkKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkVG9rZW5zLmFkZCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRQcm92aWRlcihlbnRyeS5wcm92aWRlciwgZW50cnkubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZEV4cG9ydGVkRGlyZWN0aXZlKGlkKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkUGlwZShpZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0eXBlID0gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogdHlwZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNJbmplY3RhYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgYW4gZXhhY3QgY2hlY2sgaGVyZSBhcyBAQ29tcG9uZW50IC8gQERpcmVjdGl2ZSAvIC4uLiBpbmhlcml0XG4gICAgICAgIC8vIGZyb20gQENvbXBpbGVySW5qZWN0YWJsZSFcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zLnNvbWUoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gYW5uLmNvbnN0cnVjdG9yID09PSBJbmplY3RhYmxlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEluamVjdGFibGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBudWxsLCBmYWxzZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJbmplY3RhYmxlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUpO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU3VtbWFyeS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93T25Vbmtub3duRGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IHRoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogaWRlbnRpZmllci5yZWZlcmVuY2UsXG4gICAgICAgICAgICBkaURlcHM6IHRoaXMuX2dldERlcGVuZGVuY2llc01ldGFkYXRhKGlkZW50aWZpZXIucmVmZXJlbmNlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcyksXG4gICAgICAgICAgICBsaWZlY3ljbGVIb29rczogybVMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gaGFzTGlmZWN5Y2xlSG9vayhob29rLCBpZGVudGlmaWVyLnJlZmVyZW5jZSk7IH0pLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmYWN0b3J5XG4gICAgICogQHBhcmFtIHs/PX0gZGVwZW5kZW5jaWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEZhY3RvcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgZmFjdG9yeSA9IHJlc29sdmVGb3J3YXJkUmVmKGZhY3RvcnkpO1xuICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IGZhY3RvcnksIGRpRGVwczogdGhpcy5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBwaXBlLlxuICAgICAqIFRoaXMgYXNzdW1lcyBgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhYCBoYXMgYmVlbiBjYWxsZWQgZmlyc3QuXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldFBpcGVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZU1ldGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBpcGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZVN1bW1hcnkgPSBmdW5jdGlvbiAocGlwZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZVN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkocGlwZVR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlKSk7XG4gICAgICAgIGlmICghcGlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ291bGQgbm90IGxvYWQgdGhlIHN1bW1hcnkgZm9yIHBpcGUgXCIgKyBzdHJpbmdpZnlUeXBlKHBpcGVUeXBlKSArIFwiLlwiKSwgcGlwZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlU3VtbWFyeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGlwZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRPckxvYWRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAocGlwZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZU1ldGEgPSB0aGlzLl9waXBlQ2FjaGUuZ2V0KHBpcGVUeXBlKTtcbiAgICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgICAgcGlwZU1ldGEgPSB0aGlzLl9sb2FkUGlwZU1ldGFkYXRhKHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZU1ldGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBpcGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAocGlwZVR5cGUpIHtcbiAgICAgICAgcGlwZVR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZihwaXBlVHlwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVBbm5vdGF0aW9uID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IG5ldyBDb21waWxlUGlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShwaXBlVHlwZSksXG4gICAgICAgICAgICBuYW1lOiBwaXBlQW5ub3RhdGlvbi5uYW1lLFxuICAgICAgICAgICAgcHVyZTogcGlwZUFubm90YXRpb24ucHVyZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLnNldChwaXBlVHlwZSwgcGlwZU1ldGEpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHBpcGVUeXBlLCBwaXBlTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEBwYXJhbSB7P30gZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dPblVua25vd25EZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY2llc01ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aHJvd09uVW5rbm93bkRlcHMgPT09IHZvaWQgMCkgeyB0aHJvd09uVW5rbm93bkRlcHMgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc1Vua25vd25EZXBzID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IGRlcGVuZGVuY2llcyB8fCB0aGlzLl9yZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKSB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNBdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSG9zdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1NraXBTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNIb3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2tpcFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LnRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBJbmplY3Rpb25Ub2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHBhcmFtRW50cnkpICYmIHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFzVW5rbm93bkRlcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZTogaXNBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgaXNIb3N0OiBpc0hvc3QsXG4gICAgICAgICAgICAgICAgaXNTZWxmOiBpc1NlbGYsXG4gICAgICAgICAgICAgICAgaXNTa2lwU2VsZjogaXNTa2lwU2VsZixcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsOiBpc09wdGlvbmFsLFxuICAgICAgICAgICAgICAgIHRva2VuOiBfdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YSh0b2tlbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzVW5rbm93bkRlcHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNUb2tlbnMgPSBkZXBlbmRlbmNpZXNNZXRhZGF0YS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwID8gc3RyaW5naWZ5VHlwZShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IFwiQ2FuJ3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGVPckZ1bmMpICsgXCI6IChcIiArIGRlcHNUb2tlbnMgKyBcIikuXCI7XG4gICAgICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IobWVzc2FnZSksIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiV2FybmluZzogXCIgKyBtZXNzYWdlICsgXCIgVGhpcyB3aWxsIGJlY29tZSBhbiBlcnJvciBpbiBBbmd1bGFyIHY1LnhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llc01ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUb2tlbk1ldGFkYXRhID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlVG9rZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSB7IHZhbHVlOiB0b2tlbiB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZVRva2VuID0geyBpZGVudGlmaWVyOiB7IHJlZmVyZW5jZTogdG9rZW4gfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlVG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RW50cnlDb21wb25lbnRzXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHBhcmFtIHs/PX0gY29tcGlsZVByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbywgY29tcGlsZVByb3ZpZGVycywgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVQcm92aWRlcnMgPSBbXTsgfVxuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIsIHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvLCBjb21waWxlUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyTWV0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyID09PSAnb2JqZWN0JyAmJiBwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgncHJvdmlkZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl92YWxpZGF0ZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlci5wcm92aWRlLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGEgPSBuZXcgUHJvdmlkZXJNZXRhKHByb3ZpZGVyLCB7IHVzZUNsYXNzOiBwcm92aWRlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJFbmNvdW50ZXJlZCB1bmRlZmluZWQgcHJvdmlkZXIhIFVzdWFsbHkgdGhpcyBtZWFucyB5b3UgaGF2ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAobWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nICdiYXJyZWwnIGluZGV4LnRzIGZpbGVzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyc0luZm8gPSAoKHByb3ZpZGVycy5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBzZWVuUHJvdmlkZXIsIHNlZW5Qcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Qcm92aWRlcklkeCA8IHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaChcIlwiICsgc3RyaW5naWZ5VHlwZShzZWVuUHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCI/XCIgKyBzdHJpbmdpZnlUeXBlKHNlZW5Qcm92aWRlcikgKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWVuUHJvdmlkZXJJZHggPT0gcHJvdmlkZXJJZHggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29GYXI7XG4gICAgICAgICAgICAgICAgICAgIH0sIFtdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS50b2tlbiA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkodGFyZ2V0RW50cnlDb21wb25lbnRzLCBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyKHByb3ZpZGVyTWV0YSwgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVycy5wdXNoKF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXJNZXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVQcm92aWRlcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3ZhbGlkYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyLmhhc093blByb3BlcnR5KCd1c2VDbGFzcycpICYmIHByb3ZpZGVyLnVzZUNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnlUeXBlKHByb3ZpZGVyLnByb3ZpZGUpICsgXCIuIHVzZUNsYXNzIGNhbm5vdCBiZSBcIiArIHByb3ZpZGVyLnVzZUNsYXNzICsgXCIuXFxuICAgICAgICAgICBVc3VhbGx5IGl0IGhhcHBlbnMgd2hlbjpcXG4gICAgICAgICAgIDEuIFRoZXJlJ3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5IChtaWdodCBiZSBjYXVzZWQgYnkgdXNpbmcgaW5kZXgudHMgKGJhcnJlbCkgZmlsZXMpLlxcbiAgICAgICAgICAgMi4gQ2xhc3Mgd2FzIHVzZWQgYmVmb3JlIGl0IHdhcyBkZWNsYXJlZC4gVXNlIGZvcndhcmRSZWYgaW4gdGhpcyBjYXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZElkZW50aWZpZXJzID0gW107XG4gICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgY29sbGVjdGVkSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnkgPSBfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyVHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJUeXBlKTtcbiAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5tZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50VHlwZTogZGlyVHlwZSwgY29tcG9uZW50RmFjdG9yeTogZGlyTWV0YS5tZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyU3VtbWFyeSA9ICh0aGlzLl9sb2FkU3VtbWFyeShkaXJUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlKSk7XG4gICAgICAgIGlmIChkaXJTdW1tYXJ5ICYmIGRpclN1bW1hcnkuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudFR5cGU6IGRpclR5cGUsIGNvbXBvbmVudEZhY3Rvcnk6IGRpclN1bW1hcnkuY29tcG9uZW50RmFjdG9yeSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKGRpclR5cGUubmFtZSArIFwiIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGVudHJ5IGNvbXBvbmVudC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQcm92aWRlck1ldGFkYXRhID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVEZXBzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlVHlwZU1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbik7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgY29tcGlsZVR5cGVNZXRhZGF0YSA9IHRoaXMuX2dldEluamVjdGFibGVNZXRhZGF0YShwcm92aWRlci51c2VDbGFzcywgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIGNvbXBpbGVEZXBzID0gY29tcGlsZVR5cGVNZXRhZGF0YS5kaURlcHM7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudG9rZW4gPT09IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjb21waWxlVHlwZU1ldGFkYXRhIGFzIGl0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGxpZmVjeWNsZUhvb2tzLi4uXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB7IGlkZW50aWZpZXI6IGNvbXBpbGVUeXBlTWV0YWRhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gdGhpcy5fZ2V0RmFjdG9yeU1ldGFkYXRhKHByb3ZpZGVyLnVzZUZhY3RvcnksIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICB1c2VDbGFzczogY29tcGlsZVR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgIHVzZVZhbHVlOiBwcm92aWRlci51c2VWYWx1ZSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogcHJvdmlkZXIudXNlRXhpc3RpbmcgPyB0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHByb3ZpZGVyLnVzZUV4aXN0aW5nKSA6IG51bGwsXG4gICAgICAgICAgICBkZXBzOiBjb21waWxlRGVwcyxcbiAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZpZXdRdWVyeVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnksIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHF1ZXJpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnkgPSBxdWVyaWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBpZiAocXVlcnkuaXNWaWV3UXVlcnkgPT09IGlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goX3RoaXMuX2dldFF1ZXJ5TWV0YWRhdGEocXVlcnksIHByb3BlcnR5TmFtZSwgZGlyZWN0aXZlVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fcXVlcnlWYXJCaW5kaW5ncyA9IGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoL1xccyosXFxzKi8pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcVxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFF1ZXJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAocSwgcHJvcGVydHlOYW1lLCB0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9ycztcbiAgICAgICAgaWYgKHR5cGVvZiBxLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZWN0b3JzID1cbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeVZhckJpbmRpbmdzKHEuc2VsZWN0b3IpLm1hcChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gX3RoaXMuX2dldFRva2VuTWV0YWRhdGEodmFyTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFxLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJDYW4ndCBjb25zdHJ1Y3QgYSBxdWVyeSBmb3IgdGhlIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5TmFtZSArIFwiXFxcIiBvZiBcXFwiXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGVPckZ1bmMpICsgXCJcXFwiIHNpbmNlIHRoZSBxdWVyeSBzZWxlY3RvciB3YXNuJ3QgZGVmaW5lZC5cIiksIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gW3RoaXMuX2dldFRva2VuTWV0YWRhdGEocS5zZWxlY3RvcildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycyxcbiAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHEuZGVzY2VuZGFudHMsIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgcmVhZDogcS5yZWFkID8gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShxLnJlYWQpIDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBvdGhlclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIHR5cGUsIG90aGVyVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yKGVycm9yLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChvdGhlclR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvckNvbGxlY3RvcihlcnJvciwgb3RoZXJUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXI7XG59KCkpO1xuQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICB7IHR5cGU6IE5nTW9kdWxlUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBEaXJlY3RpdmVSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IFBpcGVSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IFN1bW1hcnlSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICB7IHR5cGU6IERpcmVjdGl2ZU5vcm1hbGl6ZXIsIH0sXG4gICAgeyB0eXBlOiDJtUNvbnNvbGUsIH0sXG4gICAgeyB0eXBlOiBTdGF0aWNTeW1ib2xDYWNoZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgeyB0eXBlOiDJtVJlZmxlY3RvclJlYWRlciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtFUlJPUl9DT0xMRUNUT1JfVE9LRU4sXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gdHJlZVxuICogQHBhcmFtIHs/PX0gb3V0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IFtdOyB9XG4gICAgaWYgKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0gPSByZXNvbHZlRm9yd2FyZFJlZih0cmVlW2ldKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KGl0ZW0sIG91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFycmF5XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWR1cGVBcnJheShhcnJheSkge1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0cmVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuQW5kRGVkdXBlQXJyYXkodHJlZSkge1xuICAgIHJldHVybiBkZWR1cGVBcnJheShmbGF0dGVuQXJyYXkodHJlZSkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFR5cGUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcGFyYW0gez99IGNtcE1ldGFkYXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRNb2R1bGVVcmwocmVmbGVjdG9yLCB0eXBlLCBjbXBNZXRhZGF0YSkge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiByZWZsZWN0b3IucmVzb3VyY2VVcmkodHlwZSk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZUlkID0gY21wTWV0YWRhdGEubW9kdWxlSWQ7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NoZW1lID0gZ2V0VXJsU2NoZW1lKG1vZHVsZUlkKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtZSA/IG1vZHVsZUlkIDogXCJwYWNrYWdlOlwiICsgbW9kdWxlSWQgKyBNT0RVTEVfU1VGRklYO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2R1bGVJZCAhPT0gbnVsbCAmJiBtb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IHN5bnRheEVycm9yKFwibW9kdWxlSWQgc2hvdWxkIGJlIGEgc3RyaW5nIGluIFxcXCJcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIlxcXCIuIFNlZSBodHRwczovL2dvby5nbC93SUREaUwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXFxuXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UncmUgdXNpbmcgV2VicGFjayB5b3Ugc2hvdWxkIGlubGluZSB0aGUgdGVtcGxhdGUgYW5kIHRoZSBzdHlsZXMsIHNlZSBodHRwczovL2dvby5nbC9YMko4emMuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmbGVjdG9yLmltcG9ydFVyaSh0eXBlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSB0YXJnZXRJZGVudGlmaWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgIHZpc2l0VmFsdWUodmFsdWUsIG5ldyBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCksIHRhcmdldElkZW50aWZpZXJzKTtcbn1cbnZhciBfQ29tcGlsZVZhbHVlQ29udmVydGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0NvbXBpbGVWYWx1ZUNvbnZlcnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldElkZW50aWZpZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQ29tcGlsZVZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgICAgICB0YXJnZXRJZGVudGlmaWVycy5wdXNoKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBfQ29tcGlsZVZhbHVlQ29udmVydGVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSArIFwiIGluIFwiICsgdHlwZS5maWxlUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiDJtXN0cmluZ2lmeSh0eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGEgY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIGxvYWRlZCBpbiBhIHN5bmNocm9ub3VzIGNvbXBpbGUuXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihjb21wVHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gRXJyb3IoXCJDYW4ndCBjb21waWxlIHN5bmNocm9ub3VzbHkgYXMgXCIgKyDJtXN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiBpcyBzdGlsbCBiZWluZyBsb2FkZWQhXCIpO1xuICAgICgoZXJyb3IpKVvJtUVSUk9SX0NPTVBPTkVOVF9UWVBFXSA9IGNvbXBUeXBlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUeXBlTW9kaWZpZXIgPSB7fTtcblR5cGVNb2RpZmllci5Db25zdCA9IDA7XG5UeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyLkNvbnN0XSA9IFwiQ29uc3RcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBUeXBlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR5cGUkMShtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHlwZSQxLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFR5cGUkMS5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICByZXR1cm4gVHlwZSQxO1xufSgpKTtcbnZhciBCdWlsdGluVHlwZU5hbWUgPSB7fTtcbkJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljID0gMDtcbkJ1aWx0aW5UeXBlTmFtZS5Cb29sID0gMTtcbkJ1aWx0aW5UeXBlTmFtZS5TdHJpbmcgPSAyO1xuQnVpbHRpblR5cGVOYW1lLkludCA9IDM7XG5CdWlsdGluVHlwZU5hbWUuTnVtYmVyID0gNDtcbkJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbiA9IDU7XG5CdWlsdGluVHlwZU5hbWUuSW5mZXJyZWQgPSA2O1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5EeW5hbWljXSA9IFwiRHluYW1pY1wiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5Cb29sXSA9IFwiQm9vbFwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5TdHJpbmddID0gXCJTdHJpbmdcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuSW50XSA9IFwiSW50XCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLk51bWJlcl0gPSBcIk51bWJlclwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbl0gPSBcIkZ1bmN0aW9uXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkluZmVycmVkXSA9IFwiSW5mZXJyZWRcIjtcbnZhciBCdWlsdGluVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1aWx0aW5UeXBlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJ1aWx0aW5UeXBlKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnVpbHRpblR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpbnRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1aWx0aW5UeXBlO1xufShUeXBlJDEpKTtcbnZhciBFeHByZXNzaW9uVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cHJlc3Npb25UeXBlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uVHlwZSh2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb25UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25UeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25UeXBlO1xufShUeXBlJDEpKTtcbnZhciBBcnJheVR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvZlxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFycmF5VHlwZShvZiwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2YgPSBvZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFycmF5VHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlUeXBlO1xufShUeXBlJDEpKTtcbnZhciBNYXBUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlVHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcFR5cGUodmFsdWVUeXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIE1hcFR5cGU7XG59KFR5cGUkMSkpO1xudmFyIERZTkFNSUNfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRHluYW1pYyk7XG52YXIgSU5GRVJSRURfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW5mZXJyZWQpO1xudmFyIEJPT0xfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuQm9vbCk7XG52YXIgSU5UX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkludCk7XG52YXIgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG52YXIgU1RSSU5HX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG52YXIgRlVOQ1RJT05fVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24pO1xudmFyIEJpbmFyeU9wZXJhdG9yID0ge307XG5CaW5hcnlPcGVyYXRvci5FcXVhbHMgPSAwO1xuQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzID0gMTtcbkJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCA9IDI7XG5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwgPSAzO1xuQmluYXJ5T3BlcmF0b3IuTWludXMgPSA0O1xuQmluYXJ5T3BlcmF0b3IuUGx1cyA9IDU7XG5CaW5hcnlPcGVyYXRvci5EaXZpZGUgPSA2O1xuQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHkgPSA3O1xuQmluYXJ5T3BlcmF0b3IuTW9kdWxvID0gODtcbkJpbmFyeU9wZXJhdG9yLkFuZCA9IDk7XG5CaW5hcnlPcGVyYXRvci5PciA9IDEwO1xuQmluYXJ5T3BlcmF0b3IuTG93ZXIgPSAxMTtcbkJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzID0gMTI7XG5CaW5hcnlPcGVyYXRvci5CaWdnZXIgPSAxMztcbkJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscyA9IDE0O1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRXF1YWxzXSA9IFwiRXF1YWxzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHNdID0gXCJOb3RFcXVhbHNcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLklkZW50aWNhbF0gPSBcIklkZW50aWNhbFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsXSA9IFwiTm90SWRlbnRpY2FsXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NaW51c10gPSBcIk1pbnVzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5QbHVzXSA9IFwiUGx1c1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRGl2aWRlXSA9IFwiRGl2aWRlXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NdWx0aXBseV0gPSBcIk11bHRpcGx5XCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Nb2R1bG9dID0gXCJNb2R1bG9cIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkFuZF0gPSBcIkFuZFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuT3JdID0gXCJPclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJdID0gXCJMb3dlclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHNdID0gXCJMb3dlckVxdWFsc1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuQmlnZ2VyXSA9IFwiQmlnZ2VyXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHNdID0gXCJCaWdnZXJFcXVhbHNcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbih0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wcm9wID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkUHJvcEV4cHIodGhpcywgbmFtZSwgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIChpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtcywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEludm9rZU1ldGhvZEV4cHIodGhpcywgbmFtZSwgcGFyYW1zLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbEZuID0gZnVuY3Rpb24gKHBhcmFtcywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBwYXJhbXMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHJ1ZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBmYWxzZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jb25kaXRpb25hbCA9IGZ1bmN0aW9uICh0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1pbnVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5LCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQmxhbmsgPSBmdW5jdGlvbiAoc291cmNlU3Bhbikge1xuICAgICAgICAvLyBOb3RlOiBXZSB1c2UgZXF1YWxzIGJ5IHB1cnBvc2UgaGVyZSB0byBjb21wYXJlIHRvIG51bGwgYW5kIHVuZGVmaW5lZCBpbiBKUy5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSB0eXBlZCBudWxsIHRvIGFsbG93IHN0cmljdE51bGxDaGVja3MgdG8gbmFycm93IHR5cGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoVFlQRURfTlVMTF9FWFBSLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0bXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzKTsgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKSk7XG52YXIgQnVpbHRpblZhciA9IHt9O1xuQnVpbHRpblZhci5UaGlzID0gMDtcbkJ1aWx0aW5WYXIuU3VwZXIgPSAxO1xuQnVpbHRpblZhci5DYXRjaEVycm9yID0gMjtcbkJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayA9IDM7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuVGhpc10gPSBcIlRoaXNcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5TdXBlcl0gPSBcIlN1cGVyXCI7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuQ2F0Y2hFcnJvcl0gPSBcIkNhdGNoRXJyb3JcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5DYXRjaFN0YWNrXSA9IFwiQ2F0Y2hTdGFja1wiO1xudmFyIFJlYWRWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZFZhckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkVmFyRXhwcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVWYXJFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyaXRlVmFyRXhwcihuYW1lLCB2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXcml0ZUtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlS2V5RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlUHJvcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZVByb3BFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXcml0ZVByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXcml0ZVByb3BFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVQcm9wRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEJ1aWx0aW5NZXRob2QgPSB7fTtcbkJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXkgPSAwO1xuQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlID0gMTtcbkJ1aWx0aW5NZXRob2QuQmluZCA9IDI7XG5CdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXldID0gXCJDb25jYXRBcnJheVwiO1xuQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGVdID0gXCJTdWJzY3JpYmVPYnNlcnZhYmxlXCI7XG5CdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2QuQmluZF0gPSBcIkJpbmRcIjtcbnZhciBJbnZva2VNZXRob2RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlTWV0aG9kRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEludm9rZU1ldGhvZEV4cHIocmVjZWl2ZXIsIG1ldGhvZCwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBtZXRob2Q7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VNZXRob2RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludm9rZU1ldGhvZEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBJbnZva2VGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZva2VGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52b2tlRnVuY3Rpb25FeHByKGZuLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZm4gPSBmbjtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnZva2VGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludm9rZUZ1bmN0aW9uRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEluc3RhbnRpYXRlRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluc3RhbnRpYXRlRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzRXhwclxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5zdGFudGlhdGVFeHByKGNsYXNzRXhwciwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluc3RhbnRpYXRlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnN0YW50aWF0ZUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRXh0ZXJuYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZXJuYWxFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHRlcm5hbEV4cHIodmFsdWUsIHR5cGUsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlcm5hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb25kaXRpb25hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gez99IHRydWVDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gZmFsc2VDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHIoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB0cnVlQ2FzZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIF90aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgX3RoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbmRpdGlvbmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTm90RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm90RXhwcihjb25kaXRpb24sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgQk9PTF9UWVBFLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb3RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm90RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIENhc3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FzdEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYXN0RXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2FzdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FzdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FzdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBGblBhcmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRm5QYXJhbShuYW1lLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIEZuUGFyYW07XG59KCkpO1xudmFyIEZ1bmN0aW9uRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByKHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgX3RoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChuYW1lLCB0aGlzLnBhcmFtcywgdGhpcy5zdGF0ZW1lbnRzLCB0aGlzLnR5cGUsIG1vZGlmaWVycywgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbkV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBCaW5hcnlPcGVyYXRvckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7P30gbGhzXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IGxocy50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICBfdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIF90aGlzLmxocyA9IGxocztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmFyeU9wZXJhdG9yRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluYXJ5T3BlcmF0b3JFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgUmVhZFByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZFByb3BFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRQcm9wRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFJlYWRLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZEtleUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5pbmRleCwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZEtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsQXJyYXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbEFycmF5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxBcnJheUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsTWFwRW50cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHF1b3RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFbnRyeShrZXksIHZhbHVlLCBxdW90ZWQpIHtcbiAgICAgICAgaWYgKHF1b3RlZCA9PT0gdm9pZCAwKSB7IHF1b3RlZCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVvdGVkID0gcXVvdGVkO1xuICAgIH1cbiAgICByZXR1cm4gTGl0ZXJhbE1hcEVudHJ5O1xufSgpKTtcbnZhciBMaXRlcmFsTWFwRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxNYXBFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZW50cmllc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gdHlwZS52YWx1ZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxNYXBFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXBFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxNYXBFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQ29tbWFFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWFFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFydHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbWFFeHByKHBhcnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21tYUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWFFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbW1hRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFRISVNfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlRoaXMpO1xudmFyIFNVUEVSX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5TdXBlcik7XG52YXIgQ0FUQ0hfRVJST1JfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcik7XG52YXIgQ0FUQ0hfU1RBQ0tfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayk7XG52YXIgTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIG51bGwpO1xudmFyIFRZUEVEX05VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBJTkZFUlJFRF9UWVBFKTtcbnZhciBTdG10TW9kaWZpZXIgPSB7fTtcblN0bXRNb2RpZmllci5GaW5hbCA9IDA7XG5TdG10TW9kaWZpZXIuUHJpdmF0ZSA9IDE7XG5TdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyLkZpbmFsXSA9IFwiRmluYWxcIjtcblN0bXRNb2RpZmllcltTdG10TW9kaWZpZXIuUHJpdmF0ZV0gPSBcIlByaXZhdGVcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZW1lbnQobW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50O1xufSgpKTtcbnZhciBEZWNsYXJlVmFyU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY2xhcmVWYXJTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmVWYXJTdG10KG5hbWUsIHZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZSB8fCB2YWx1ZS50eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVjbGFyZVZhclN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlVmFyU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNsYXJlVmFyU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgRGVjbGFyZUZ1bmN0aW9uU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcbn0oU3RhdGVtZW50KSk7XG52YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0dXJuU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXR1cm5TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZXR1cm5TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcbn0oU3RhdGVtZW50KSk7XG52YXIgQWJzdHJhY3RDbGFzc1BhcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdENsYXNzUGFydCh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2RpZmllclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDbGFzc1BhcnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIEFic3RyYWN0Q2xhc3NQYXJ0O1xufSgpKTtcbnZhciBDbGFzc0ZpZWxkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NGaWVsZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NGaWVsZChuYW1lLCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc0ZpZWxkO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzTWV0aG9kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NNZXRob2QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NNZXRob2QobmFtZSwgcGFyYW1zLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc01ldGhvZDtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbnZhciBDbGFzc0dldHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzR2V0dGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzc0dldHRlcihuYW1lLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3NHZXR0ZXI7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBmaWVsZHNcbiAgICAgKiBAcGFyYW0gez99IGdldHRlcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbnN0cnVjdG9yTWV0aG9kXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RzXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsYXNzU3RtdChuYW1lLCBwYXJlbnQsIGZpZWxkcywgZ2V0dGVycywgY29uc3RydWN0b3JNZXRob2QsIG1ldGhvZHMsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgX3RoaXMuZ2V0dGVycyA9IGdldHRlcnM7XG4gICAgICAgIF90aGlzLmNvbnN0cnVjdG9yTWV0aG9kID0gY29uc3RydWN0b3JNZXRob2Q7XG4gICAgICAgIF90aGlzLm1ldGhvZHMgPSBtZXRob2RzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xhc3NTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc1N0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIElmU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElmU3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7P30gdHJ1ZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBmYWxzZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWZTdG10KGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgICBfdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJZlN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJZlN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSWZTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBUcnlDYXRjaFN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcnlDYXRjaFN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBib2R5U3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGNhdGNoU3RtdHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJ5Q2F0Y2hTdG10KGJvZHlTdG10cywgY2F0Y2hTdG10cywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ib2R5U3RtdHMgPSBib2R5U3RtdHM7XG4gICAgICAgIF90aGlzLmNhdGNoU3RtdHMgPSBjYXRjaFN0bXRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJ5Q2F0Y2hTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHJ5Q2F0Y2hTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyeUNhdGNoU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgVGhyb3dTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3dTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGhyb3dTdG10KGVycm9yLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUaHJvd1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3dTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBBc3RUcmFuc2Zvcm1lciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnRyYW5zZm9ybUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkgeyByZXR1cm4gZXhwcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnRyYW5zZm9ybVN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihhc3QsIGNvbnRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZVZhckV4cHIoZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVQcm9wRXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZCA9IGFzdC5idWlsdGluIHx8IGFzdC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnZva2VNZXRob2RFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIG1ldGhvZCwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENvbmRpdGlvbmFsRXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTm90RXhwcihhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBDYXN0RXhwcihhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgRnVuY3Rpb25FeHByKGFzdC5wYXJhbXMsIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEJpbmFyeU9wZXJhdG9yRXhwcihhc3Qub3BlcmF0b3IsIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFJlYWRQcm9wRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QubmFtZSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgUmVhZEtleUV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBMaXRlcmFsQXJyYXlFeHByKHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJpZXMgPSBhc3QuZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGVudHJ5LmtleSwgZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KSwgZW50cnkucXVvdGVkKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFR5cGUgPSBuZXcgTWFwVHlwZShhc3QudmFsdWVUeXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgbWFwVHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ29tbWFFeHByKHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByc1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHBycywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXhwcnMubWFwKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRGVjbGFyZVZhclN0bXQoc3RtdC5uYW1lLCBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC50eXBlLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdC5uYW1lLCBzdG10LnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjb250ZXh0KSwgc3RtdC50eXBlLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBSZXR1cm5TdGF0ZW1lbnQoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdldHRlcnMgPSBzdG10LmdldHRlcnMubWFwKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIG5ldyBDbGFzc0dldHRlcihnZXR0ZXIubmFtZSwgX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KSwgZ2V0dGVyLnR5cGUsIGdldHRlci5tb2RpZmllcnMpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3Rvck1ldGhvZCA9IHN0bXQuY29uc3RydWN0b3JNZXRob2QgJiZcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLm5hbWUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnR5cGUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QubW9kaWZpZXJzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0aG9kcyA9IHN0bXQubWV0aG9kcy5tYXAoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gbmV3IENsYXNzTWV0aG9kKG1ldGhvZC5uYW1lLCBtZXRob2QucGFyYW1zLCBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGNvbnRleHQpLCBtZXRob2QudHlwZSwgbWV0aG9kLm1vZGlmaWVycyk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBDbGFzc1N0bXQoc3RtdC5uYW1lLCBwYXJlbnQsIHN0bXQuZmllbGRzLCBnZXR0ZXJzLCBjdG9yTWV0aG9kLCBtZXRob2RzLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgSWZTdG10KHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVHJ5Q2F0Y2hTdG10KHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQoc3RtdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyJDE7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlQXN0VmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGNvbnRleHQpOyB9KTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBzdG10OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0bXRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yJDE7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0bXRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfUmVhZFZhclZpc2l0b3IoKTtcbiAgICB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgbnVsbCk7XG4gICAgcmV0dXJuIHZpc2l0b3IudmFyTmFtZXM7XG59XG52YXIgX1JlYWRWYXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX1JlYWRWYXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9SZWFkVmFyVmlzaXRvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgY2xhc3Nlc1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmFyTmFtZXMuYWRkKGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gX1JlYWRWYXJWaXNpdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yJDEpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdG10XG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbikge1xuICAgIGlmICghc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZXIgPSBuZXcgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyKHNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KHRyYW5zZm9ybWVyLCBudWxsKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIXNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVyID0gbmV3IF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24odHJhbnNmb3JtZXIsIG51bGwpO1xufVxudmFyIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIoc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb25lID0gT2JqZWN0LmNyZWF0ZShvYmouY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgY2xvbmVbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWV4cHIuc291cmNlU3Bhbikge1xuICAgICAgICAgICAgZXhwciA9IHRoaXMuX2Nsb25lKGV4cHIpO1xuICAgICAgICAgICAgZXhwci5zb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybVN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIXN0bXQuc291cmNlU3Bhbikge1xuICAgICAgICAgICAgc3RtdCA9IHRoaXMuX2Nsb25lKHN0bXQpO1xuICAgICAgICAgICAgc3RtdC5zb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgcmV0dXJuIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcjtcbn0oQXN0VHJhbnNmb3JtZXIkMSkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/PX0gdHlwZVBhcmFtc1xuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcywgc291cmNlU3Bhbikge1xuICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICByZXR1cm4gbmV3IEV4dGVybmFsRXhwcihpZCwgbnVsbCwgdHlwZVBhcmFtcywgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEBwYXJhbSB7Pz19IHR5cGVQYXJhbXNcbiAqIEBwYXJhbSB7Pz19IHR5cGVNb2RpZmllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBpZCAhPSBudWxsID8gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcyksIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez89fSB0eXBlTW9kaWZpZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHByZXNzaW9uVHlwZShleHByLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBleHByICE9IG51bGwgPyBuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykgOiBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlc1xuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEFycih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXlFeHByKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVzXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcGFyYW0gez89fSBxdW90ZWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxNYXAodmFsdWVzLCB0eXBlLCBxdW90ZWQpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgaWYgKHF1b3RlZCA9PT0gdm9pZCAwKSB7IHF1b3RlZCA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gbmV3IExpdGVyYWxNYXBFbnRyeShlbnRyeVswXSwgZW50cnlbMV0sIHF1b3RlZCk7IH0pLCB0eXBlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3QoZXhwciwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTm90RXhwcihleHByLCBzb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwYXJhbXNcbiAqIEBwYXJhbSB7P30gYm9keVxuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjbGFzcyBzdG10cyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZGF0YS5cbiAqIEBwYXJhbSB7P30gY29uZmlnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVDbGFzc1N0bXQoY29uZmlnKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50QXJncyA9IGNvbmZpZy5wYXJlbnRBcmdzIHx8IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1cGVyQ3RvclN0bXRzID0gY29uZmlnLnBhcmVudCA/IFtTVVBFUl9FWFBSLmNhbGxGbihwYXJlbnRBcmdzKS50b1N0bXQoKV0gOiBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBidWlsZGVyID0gY29uY2F0Q2xhc3NCdWlsZGVyUGFydHMoQXJyYXkuaXNBcnJheShjb25maWcuYnVpbGRlcnMpID8gY29uZmlnLmJ1aWxkZXJzIDogW2NvbmZpZy5idWlsZGVyc10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3IgPSBuZXcgQ2xhc3NNZXRob2QobnVsbCwgY29uZmlnLmN0b3JQYXJhbXMgfHwgW10sIHN1cGVyQ3RvclN0bXRzLmNvbmNhdChidWlsZGVyLmN0b3JTdG10cykpO1xuICAgIHJldHVybiBuZXcgQ2xhc3NTdG10KGNvbmZpZy5uYW1lLCBjb25maWcucGFyZW50LCBidWlsZGVyLmZpZWxkcywgYnVpbGRlci5nZXR0ZXJzLCBjdG9yLCBidWlsZGVyLm1ldGhvZHMsIGNvbmZpZy5tb2RpZmllcnMgfHwgW10sIGNvbmZpZy5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBidWlsZGVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29uY2F0Q2xhc3NCdWlsZGVyUGFydHMoYnVpbGRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZHM6IFtdLmNvbmNhdC5hcHBseShbXSwgYnVpbGRlcnMubWFwKGZ1bmN0aW9uIChidWlsZGVyKSB7IHJldHVybiBidWlsZGVyLmZpZWxkcyB8fCBbXTsgfSkpLFxuICAgICAgICBtZXRob2RzOiBbXS5jb25jYXQuYXBwbHkoW10sIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5tZXRob2RzIHx8IFtdOyB9KSksXG4gICAgICAgIGdldHRlcnM6IFtdLmNvbmNhdC5hcHBseShbXSwgYnVpbGRlcnMubWFwKGZ1bmN0aW9uIChidWlsZGVyKSB7IHJldHVybiBidWlsZGVyLmdldHRlcnMgfHwgW107IH0pKSxcbiAgICAgICAgY3RvclN0bXRzOiBbXS5jb25jYXQuYXBwbHkoW10sIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5jdG9yU3RtdHMgfHwgW107IH0pKSxcbiAgICB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFFVT1RFRF9LRVlTID0gJyRxdW90ZWQkJztcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFZhbHVlVG9PdXRwdXRBc3QodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIG5ldyBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcigpLCB0eXBlKTtcbn1cbnZhciBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXJyXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBudWxsKTsgfSksIHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cmllcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdW90ZWRTZXQgPSBuZXcgU2V0KG1hcCAmJiBtYXBbUVVPVEVEX0tFWVNdKTtcbiAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KGtleSwgdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIG51bGwpLCBxdW90ZWRTZXQuaGFzKGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgdHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHsgcmV0dXJuIGxpdGVyYWwodmFsdWUsIHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhpcyBpcyBjdXJyZW50bHkgbm90IHJlYWQsIGJ1dCB3aWxsIHByb2JhYmx5IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIFdlIGtlZXAgaXQgYXMgd2UgYWxyZWFkeSBwYXNzIGl0IHRocm91Z2ggYWxsIHRoZSByaWd0aCBwbGFjZXMuLi5cbiAqL1xudmFyIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koY29tcFR5cGUpIHtcbiAgICAgICAgdGhpcy5jb21wVHlwZSA9IGNvbXBUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3k7XG59KCkpO1xudmFyIE5nTW9kdWxlQ29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZUZhY3RvcnlWYXJcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcGVuZGVuY2llcykge1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICB0aGlzLm5nTW9kdWxlRmFjdG9yeVZhciA9IG5nTW9kdWxlRmFjdG9yeVZhcjtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIE5nTW9kdWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVNZXRhXG4gICAgICogQHBhcmFtIHs/fSBleHRyYVByb3ZpZGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVNwYW4gPSB0eXBlU291cmNlU3BhbignTmdNb2R1bGUnLCBuZ01vZHVsZU1ldGEudHlwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gbmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChuZ01vZHVsZU1ldGEuYm9vdHN0cmFwQ29tcG9uZW50cy5zb21lKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQucmVmZXJlbmNlID09PSBlbnRyeUNvbXBvbmVudC5jb21wb25lbnRUeXBlOyB9KSkge1xuICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5wdXNoKHsgcmVmZXJlbmNlOiBlbnRyeUNvbXBvbmVudC5jb21wb25lbnRGYWN0b3J5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwcy5wdXNoKG5ldyBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShlbnRyeUNvbXBvbmVudC5jb21wb25lbnRUeXBlKSk7XG4gICAgICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IGVudHJ5Q29tcG9uZW50LmNvbXBvbmVudEZhY3RvcnkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgX0luamVjdG9yQnVpbGRlcihuZ01vZHVsZU1ldGEsIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzLCBib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlclBhcnNlciA9IG5ldyBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIobmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycywgc291cmNlU3Bhbik7XG4gICAgICAgIHByb3ZpZGVyUGFyc2VyLnBhcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIGJ1aWxkZXIuYWRkUHJvdmlkZXIocHJvdmlkZXIpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qZWN0b3JDbGFzcyA9IGJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVGYWN0b3J5VmFyID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGVNZXRhLnR5cGUpICsgXCJOZ0ZhY3RvcnlcIjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVGYWN0b3J5U3RtdCA9IHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcilcbiAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSkpXG4gICAgICAgICAgICAuaW5zdGFudGlhdGUoW3ZhcmlhYmxlKGluamVjdG9yQ2xhc3MubmFtZSksIGltcG9ydEV4cHIobmdNb2R1bGVNZXRhLnR5cGUpXSwgaW1wb3J0VHlwZShjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSksIFtpbXBvcnRUeXBlKG5nTW9kdWxlTWV0YS50eXBlKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXRzID0gW2luamVjdG9yQ2xhc3MsIG5nTW9kdWxlRmFjdG9yeVN0bXRdO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmlkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdpc3RlckZhY3RvcnlTdG10ID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuKSlcbiAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKG5nTW9kdWxlTWV0YS5pZCksIHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcildKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICAgIHN0bXRzLnB1c2gocmVnaXN0ZXJGYWN0b3J5U3RtdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZ01vZHVsZUNvbXBpbGVSZXN1bHQoc3RtdHMsIG5nTW9kdWxlRmFjdG9yeVZhciwgZGVwcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlcjtcbn0oKSk7XG5OZ01vZHVsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk5nTW9kdWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbnZhciBfSW5qZWN0b3JCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ01vZHVsZU1ldGFcbiAgICAgKiBAcGFyYW0gez99IF9lbnRyeUNvbXBvbmVudEZhY3Rvcmllc1xuICAgICAqIEBwYXJhbSB7P30gX2Jvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllc1xuICAgICAqIEBwYXJhbSB7P30gX3NvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfSW5qZWN0b3JCdWlsZGVyKF9uZ01vZHVsZU1ldGEsIF9lbnRyeUNvbXBvbmVudEZhY3RvcmllcywgX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVNZXRhID0gX25nTW9kdWxlTWV0YTtcbiAgICAgICAgdGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBfZW50cnlDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIHRoaXMuX3NvdXJjZVNwYW4gPSBfc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IFtdO1xuICAgICAgICB0aGlzLmN0b3JTdG10cyA9IFtdO1xuICAgICAgICB0aGlzLl9sYXp5UHJvcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVN0bXRzID0gW107XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc29sdmVkUHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gX3RoaXMuX2dldFByb3ZpZGVyVmFsdWUocHJvdmlkZXIpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE5hbWUgPSBcIl9cIiArIHRva2VuTmFtZShyZXNvbHZlZFByb3ZpZGVyLnRva2VuKSArIFwiX1wiICsgdGhpcy5faW5zdGFuY2VzLnNpemU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlID0gdGhpcy5fY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eShwcm9wTmFtZSwgcmVzb2x2ZWRQcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCByZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHJlc29sdmVkUHJvdmlkZXIuZWFnZXIpO1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlci5saWZlY3ljbGVIb29rcy5pbmRleE9mKMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbGxOZ09uRGVzdHJveSA9IGluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyLmVhZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbE5nT25EZXN0cm95ID0gdGhpcy5fbGF6eVByb3BzLmdldChpbnN0YW5jZS5uYW1lKS5hbmQoY2FsbE5nT25EZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cy5wdXNoKGNhbGxOZ09uRGVzdHJveS50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2gocmVzb2x2ZWRQcm92aWRlci50b2tlbik7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlcy5zZXQodG9rZW5SZWZlcmVuY2UocmVzb2x2ZWRQcm92aWRlci50b2tlbiksIGluc3RhbmNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdldE1ldGhvZFN0bXRzID0gdGhpcy5fdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyRXhwciA9IF90aGlzLl9pbnN0YW5jZXMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChJbmplY3RNZXRob2RWYXJzLnRva2VuLmlkZW50aWNhbChjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikpLCBbbmV3IFJldHVyblN0YXRlbWVudChwcm92aWRlckV4cHIpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2RzID0gW1xuICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdjcmVhdGVJbnRlcm5hbCcsIFtdLCB0aGlzLl9jcmVhdGVTdG10cy5jb25jYXQobmV3IFJldHVyblN0YXRlbWVudCh0aGlzLl9pbnN0YW5jZXMuZ2V0KHRoaXMuX25nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSkpKSwgaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkpLFxuICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdnZXRJbnRlcm5hbCcsIFtcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzLnRva2VuLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdC5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgICBdLCBnZXRNZXRob2RTdG10cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQoSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdCldKSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHRoaXMuX2Rlc3Ryb3lTdG10cyksXG4gICAgICAgIF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudEFyZ3MgPSBbXG4gICAgICAgICAgICB2YXJpYWJsZShJbmplY3RvclByb3BzLnBhcmVudC5uYW1lKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudEZhY3RvcnkpIHsgcmV0dXJuIGltcG9ydEV4cHIoY29tcG9uZW50RmFjdG9yeSk7IH0pKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmpDbGFzc05hbWUgPSBpZGVudGlmaWVyTmFtZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkgKyBcIkluamVjdG9yXCI7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbGFzc1N0bXQoe1xuICAgICAgICAgICAgbmFtZTogaW5qQ2xhc3NOYW1lLFxuICAgICAgICAgICAgY3RvclBhcmFtczogW25ldyBGblBhcmFtKEluamVjdG9yUHJvcHMucGFyZW50Lm5hbWUsIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpKV0sXG4gICAgICAgICAgICBwYXJlbnQ6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yKSwgW2ltcG9ydFR5cGUodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUpXSksXG4gICAgICAgICAgICBwYXJlbnRBcmdzOiBwYXJlbnRBcmdzLFxuICAgICAgICAgICAgYnVpbGRlcnM6IFt7IG1ldGhvZHM6IG1ldGhvZHMgfSwgdGhpc11cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJWYWx1ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXREZXBlbmRlbmN5KHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5KS5jYWxsRm4oZGVwc0V4cHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwKTsgfSk7XG4gICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGlzTXVsdGlcbiAgICAgKiBAcGFyYW0gez99IGlzRWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQcm92aWRlclByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lLCBwcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCBpc011bHRpLCBpc0VhZ2VyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGU7XG4gICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgdHlwZSA9IG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIgPSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF07XG4gICAgICAgICAgICB0eXBlID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gRFlOQU1JQ19UWVBFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VhZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHByb3BOYW1lLCB0eXBlKSk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJuYWxGaWVsZFByb3AgPSBUSElTX0VYUFIucHJvcChcIl9cIiArIHByb3BOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoaW50ZXJuYWxGaWVsZFByb3AubmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgLy8gTm90ZTogRXF1YWxzIGlzIGltcG9ydGFudCBmb3IgSlMgc28gdGhhdCBpdCBhbHNvIGNoZWNrcyB0aGUgdW5kZWZpbmVkIGNhc2UhXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZXR0ZXJTdG10cyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgSWZTdG10KGludGVybmFsRmllbGRQcm9wLmlzQmxhbmsoKSwgW2ludGVybmFsRmllbGRQcm9wLnNldChyZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByKS50b1N0bXQoKV0pLFxuICAgICAgICAgICAgICAgIG5ldyBSZXR1cm5TdGF0ZW1lbnQoaW50ZXJuYWxGaWVsZFByb3ApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXJzLnB1c2gobmV3IENsYXNzR2V0dGVyKHByb3BOYW1lLCBnZXR0ZXJTdG10cywgdHlwZSkpO1xuICAgICAgICAgICAgdGhpcy5fbGF6eVByb3BzLnNldChwcm9wTmFtZSwgaW50ZXJuYWxGaWVsZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChwcm9wTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGl0ZXJhbChkZXAudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgICAgIGlmIChkZXAudG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRISVNfRVhQUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBUSElTX0VYUFIucHJvcCgnY29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9pbnN0YW5jZXMuZ2V0KHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gW2NyZWF0ZURpVG9rZW5FeHByZXNzaW9uKGRlcC50b2tlbildO1xuICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKE5VTExfRVhQUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBJbmplY3RvclByb3BzLnBhcmVudC5jYWxsTWV0aG9kKCdnZXQnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIF9JbmplY3RvckJ1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikge1xuICAgIGlmICh0b2tlbi52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHRva2VuLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpO1xuICAgIH1cbn1cbnZhciBJbmplY3RvclByb3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3RvclByb3BzKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5qZWN0b3JQcm9wcztcbn0oKSk7XG5JbmplY3RvclByb3BzLnBhcmVudCA9IFRISVNfRVhQUi5wcm9wKCdwYXJlbnQnKTtcbnZhciBJbmplY3RNZXRob2RWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3RNZXRob2RWYXJzKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbn0oKSk7XG5JbmplY3RNZXRob2RWYXJzLnRva2VuID0gdmFyaWFibGUoJ3Rva2VuJyk7XG5JbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXRcbnZhciBWRVJTSU9OJDEgPSAzO1xudmFyIEpTX0I2NF9QUkVGSVggPSAnIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJztcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGZpbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZSA9PT0gdm9pZCAwKSB7IGZpbGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQuc2V0KHVybCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saW5lcy5wdXNoKFtdKTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2wwXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlVXJsXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlTGluZTBcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VDb2wwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPSBmdW5jdGlvbiAoY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudExpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbGluZSBtdXN0IGJlIGFkZGVkIGJlZm9yZSBtYXBwaW5ncyBjYW4gYmUgYWRkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAhPSBudWxsICYmICF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyhzb3VyY2VVcmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNvdXJjZSBmaWxlIFxcXCJcIiArIHNvdXJjZVVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29sdW1uIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwIDwgdGhpcy5sYXN0Q29sMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBzaG91bGQgYmUgYWRkZWQgaW4gb3V0cHV0IG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgJiYgKHNvdXJjZUxpbmUwID09IG51bGwgfHwgc291cmNlQ29sMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBsb2NhdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYSBzb3VyY2UgdXJsIGlzIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gY29sMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZS5wdXNoKHsgY29sMDogY29sMCwgc291cmNlVXJsOiBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwOiBzb3VyY2VMaW5lMCwgc291cmNlQ29sMDogc291cmNlQ29sMCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZSwgXCJjdXJyZW50TGluZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc01hcHBpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNvdXJjZXNDb250ZW50LmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodXJsLCBpKSB7XG4gICAgICAgICAgICBzb3VyY2VzSW5kZXguc2V0KHVybCwgaSk7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2godXJsKTtcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LnB1c2goX3RoaXMuc291cmNlc0NvbnRlbnQuZ2V0KHVybCkgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwaW5ncyA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0Q29sMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VMaW5lMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnQXNTdHIgPSB0b0Jhc2U2NFZMUShzZWdtZW50LmNvbDAgLSBsYXN0Q29sMCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbDAgPSBzZWdtZW50LmNvbDA7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuc291cmNlVXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBpbmRleCBpbnRvIHRoZSDigJxzb3VyY2Vz4oCdIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmFzZTY0VkxRKHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpIC0gbGFzdFNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUluZGV4ID0gc291cmNlc0luZGV4LmdldChzZWdtZW50LnNvdXJjZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGxpbmUgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPSB0b0Jhc2U2NFZMUShzZWdtZW50LnNvdXJjZUxpbmUwIC0gbGFzdFNvdXJjZUxpbmUwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUxpbmUwID0gc2VnbWVudC5zb3VyY2VMaW5lMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHplcm8tYmFzZWQgc3RhcnRpbmcgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VDb2wwIC0gbGFzdFNvdXJjZUNvbDApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U291cmNlQ29sMCA9IHNlZ21lbnQuc291cmNlQ29sMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ0FzU3RyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gJzsnO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZmlsZSc6IHRoaXMuZmlsZSB8fCAnJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogVkVSU0lPTiQxLFxuICAgICAgICAgICAgJ3NvdXJjZVJvb3QnOiAnJyxcbiAgICAgICAgICAgICdzb3VyY2VzJzogc291cmNlcyxcbiAgICAgICAgICAgICdzb3VyY2VzQ29udGVudCc6IHNvdXJjZXNDb250ZW50LFxuICAgICAgICAgICAgJ21hcHBpbmdzJzogbWFwcGluZ3MsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9Kc0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRTdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiNjQgPSAnJztcbiAgICB2YWx1ZSA9IHV0ZjhFbmNvZGUodmFsdWUpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaXNOYU4oaTIpID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGlzTmFOKGkyKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgfHwgaXNOYU4oaTMpID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRWTFEodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIDwgMCA/ICgoLXZhbHVlKSA8PCAxKSArIDEgOiB2YWx1ZSA8PCAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0RGlnaXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGVuY29kZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDYzXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEI2NF9ESUdJVFNbdmFsdWVdO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbnZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xudmFyIF9JTkRFTlRfV0lUSCA9ICcgICc7XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSB2YXJpYWJsZSgnZXJyb3InKTtcbnZhciBDQVRDSF9TVEFDS19WQVIkMSA9IHZhcmlhYmxlKCdzdGFjaycpO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIF9FbWl0dGVkTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc3JjU3BhbnMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIF9FbWl0dGVkTGluZTtcbn0oKSk7XG52YXIgRW1pdHRlclZpc2l0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9leHBvcnRlZFZhcnNcbiAgICAgKiBAcGFyYW0gez99IF9pbmRlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2V4cG9ydGVkVmFycywgX2luZGVudCkge1xuICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cG9ydGVkVmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1pdHRlclZpc2l0b3JDb250ZXh0KGV4cG9ydGVkVmFycywgMCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pc0V4cG9ydGVkVmFyID0gZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIHRoaXMuX2V4cG9ydGVkVmFycy5pbmRleE9mKHZhck5hbWUpICE9PSAtMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBmcm9tXG4gICAgICogQHBhcmFtIHs/PX0gbGFzdFBhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnRsbiA9IGZ1bmN0aW9uIChmcm9tLCBsYXN0UGFydCkge1xuICAgICAgICBpZiAobGFzdFBhcnQgPT09IHZvaWQgMCkgeyBsYXN0UGFydCA9ICcnOyB9XG4gICAgICAgIHRoaXMucHJpbnQoZnJvbSwgbGFzdFBhcnQsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVJc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudExpbmUucGFydHMubGVuZ3RoID09PSAwOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZnJvbVxuICAgICAqIEBwYXJhbSB7P30gcGFydFxuICAgICAqIEBwYXJhbSB7Pz19IG5ld0xpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoZnJvbSwgcGFydCwgbmV3TGluZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuc3JjU3BhbnMucHVzaChmcm9tICYmIGZyb20uc291cmNlU3BhbiB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucHVzaChuZXcgX0VtaXR0ZWRMaW5lKHRoaXMuX2luZGVudCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlRW1wdHlMYXN0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pbmNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuZGVjSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjbGF6elxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wdXNoQ2xhc3MgPSBmdW5jdGlvbiAoY2xhenopIHsgdGhpcy5fY2xhc3Nlcy5wdXNoKGNsYXp6KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc2VzLnBvcCgpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5sZW5ndGggPiAwID8gdGhpcy5fY2xhc3Nlc1t0aGlzLl9jbGFzc2VzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VMaW5lc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5wYXJ0cy5sZW5ndGggPiAwID8gX2NyZWF0ZUluZGVudChsLmluZGVudCkgKyBsLnBhcnRzLmpvaW4oJycpIDogJyc7IH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZUZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0c0F0TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZU1hcEdlbmVyYXRvciA9IGZ1bmN0aW9uIChzb3VyY2VGaWxlUGF0aCwgZ2VuRmlsZVBhdGgsIHN0YXJ0c0F0TGluZSkge1xuICAgICAgICBpZiAoc3RhcnRzQXRMaW5lID09PSB2b2lkIDApIHsgc3RhcnRzQXRMaW5lID0gMDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGdlbkZpbGVQYXRoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlyc3RPZmZzZXRNYXBwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RPZmZzZXRNYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzaW5nbGUgc3BhY2Ugc28gdGhhdCB0b29scyB3b24ndCB0cnkgdG8gbG9hZCB0aGUgZmlsZSBmcm9tIGRpc2suXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgYXJlIHVzaW5nIHZpcnR1YWwgdXJscyBsaWtlIGBuZzovLy9gLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBhIGNvbnRlbnQgaGVyZS5cbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKHNvdXJjZUZpbGVQYXRoLCAnICcpLmFkZE1hcHBpbmcoMCwgc291cmNlRmlsZVBhdGgsIDAsIDApO1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0YXJ0c0F0TGluZTsgaSsrKSB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlTGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgbGluZUlkeCkge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwYW5zID0gbGluZS5zcmNTcGFucztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gbGluZS5wYXJ0cztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbDAgPSBsaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuSWR4ID0gMDtcbiAgICAgICAgICAgIC8vIHNraXAgbGVhZGluZyBwYXJ0cyB3aXRob3V0IHNvdXJjZSBzcGFuc1xuICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgIXNwYW5zW3NwYW5JZHhdKSB7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgbGluZUlkeCA9PT0gMCAmJiBjb2wwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RPZmZzZXRNYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuID0gc3BhbnNbc3BhbklkeF07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlID0gc3Bhbi5zdGFydC5maWxlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUxpbmUgPSBzcGFuLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlQ29sID0gc3Bhbi5zdGFydC5jb2w7XG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShzb3VyY2UudXJsLCBzb3VyY2UuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLmFkZE1hcHBpbmcoY29sMCwgc291cmNlLnVybCwgc291cmNlTGluZSwgc291cmNlQ29sKTtcbiAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHBhcnRzIHdpdGhvdXQgc3BhbiBvciB0aGUgc2FtZSBzcGFuIHRvIHRoZSBwcmV2aW91cyBzZWdtZW50XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgKHNwYW4gPT09IHNwYW5zW3NwYW5JZHhdIHx8ICFzcGFuc1tzcGFuSWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwic291cmNlTGluZXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVzLmxlbmd0aCAmJiB0aGlzLl9saW5lc1t0aGlzLl9saW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lc2NhcGVEb2xsYXJJblN0cmluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzID0gX2VzY2FwZURvbGxhckluU3RyaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJyZXR1cm4gXCIpO1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCAnOycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJpZiAoXCIpO1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNFbHNlQ2FzZSA9IHN0bXQuZmFsc2VDYXNlICE9IG51bGwgJiYgc3RtdC5mYWxzZUNhc2UubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHN0bXQudHJ1ZUNhc2UubGVuZ3RoIDw9IDEgJiYgIWhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInRocm93IFwiKTtcbiAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lcyA9IHN0bXQuY29tbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsgY3R4LnByaW50bG4oc3RtdCwgXCIvLyBcIiArIGxpbmUpOyB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiW1wiKTtcbiAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiXSA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5nZXRCdWlsdGluTWV0aG9kTmFtZShleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLlwiICsgbmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCBcIixcIik7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICdzdXBlcic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3RoaXMnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX0VSUk9SX1ZBUiQxLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDEubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHZhck5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwibmV3IFwiKTtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJz8gJyk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJzogJyk7XG4gICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyEnKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcFN0cjtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnJiYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICd8fCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnLyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJzwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz49JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIi5cIik7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJbXCIpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VOZXdMaW5lID0gYXN0LmVudHJpZXMubGVuZ3RoID4gMTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ7XCIsIHVzZU5ld0xpbmUpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcihlbnRyeS5rZXksIF90aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MsIGVudHJ5LnF1b3RlZCkgKyBcIjogXCIpO1xuICAgICAgICAgICAgZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpO1xuICAgICAgICB9LCBhc3QuZW50cmllcywgY3R4LCAnLCcsIHVzZU5ld0xpbmUpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/fSBzZXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gez89fSBuZXdMaW5lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0sIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEBwYXJhbSB7P30gc2VwYXJhdG9yXG4gICAgICogQHBhcmFtIHs/PX0gbmV3TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY3R4KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gZXNjYXBlRG9sbGFyXG4gKiBAcGFyYW0gez89fSBhbHdheXNRdW90ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcihpbnB1dCwgZXNjYXBlRG9sbGFyLCBhbHdheXNRdW90ZSkge1xuICAgIGlmIChhbHdheXNRdW90ZSA9PT0gdm9pZCAwKSB7IGFsd2F5c1F1b3RlID0gdHJ1ZTsgfVxuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5ID0gaW5wdXQucmVwbGFjZShfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtYXRjaFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFswXSA9PSAnJCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVEb2xsYXIgPyAnXFxcXCQnIDogJyQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxyJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBtYXRjaFswXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcXVpcmVzUXVvdGVzID0gYWx3YXlzUXVvdGUgfHwgIV9MRUdBTF9JREVOVElGSUVSX1JFLnRlc3QoYm9keSk7XG4gICAgcmV0dXJuIHJlcXVpcmVzUXVvdGVzID8gXCInXCIgKyBib2R5ICsgXCInXCIgOiBib2R5O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvdW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfY3JlYXRlSW5kZW50KGNvdW50KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzICs9IF9JTkRFTlRfV0lUSDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfZGVidWdGaWxlUGF0aCA9ICcvZGVidWcvbGliJztcbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0KGFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcihfZGVidWdGaWxlUGF0aCwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5pbmdGaWxlUGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsZU5hbWVUb01vZHVsZU5hbWU6IGZ1bmN0aW9uIChmaWxlUGF0aCwgY29udGFpbmluZ0ZpbGVQYXRoKSB7IHJldHVybiBmaWxlUGF0aDsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbXBvcnRBczogZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgZ2V0VHlwZUFyaXR5OiBmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBudWxsOyB9XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoW10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdHMgPSBBcnJheS5pc0FycmF5KGFzdCkgPyBhc3QgOiBbYXN0XTtcbiAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBhc3QudmlzaXRTdGF0ZW1lbnQoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGFzdC52aXNpdEV4cHJlc3Npb24oY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIFR5cGUkMSkge1xuICAgICAgICAgICAgYXN0LnZpc2l0VHlwZShjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBrbm93IGhvdyB0byBwcmludCBkZWJ1ZyBpbmZvIGZvciBcIiArIGFzdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3R4LnRvU291cmNlKCk7XG59XG52YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2ltcG9ydFJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHlwZVNjcmlwdEVtaXR0ZXIoX2ltcG9ydFJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuX2ltcG9ydFJlc29sdmVyID0gX2ltcG9ydFJlc29sdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGV4cG9ydGVkVmFyc1xuICAgICAqIEBwYXJhbSB7Pz19IHByZWFtYmxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3JjRmlsZVBhdGgsIGdlbkZpbGVQYXRoLCBzdG10cywgZXhwb3J0ZWRWYXJzLCBwcmVhbWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcihnZW5GaWxlUGF0aCwgdGhpcy5faW1wb3J0UmVzb2x2ZXIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChleHBvcnRlZFZhcnMpO1xuICAgICAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVhbWJsZUxpbmVzID0gcHJlYW1ibGUgPyBwcmVhbWJsZS5zcGxpdCgnXFxuJykgOiBbXTtcbiAgICAgICAgY29udmVydGVyLnJlZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWV4cG9ydHMsIGV4cG9ydGVkRmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZXhwb3J0c0NvZGUgPSByZWV4cG9ydHMubWFwKGZ1bmN0aW9uIChyZWV4cG9ydCkgeyByZXR1cm4gcmVleHBvcnQubmFtZSArIFwiIGFzIFwiICsgcmVleHBvcnQuYXM7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHByZWFtYmxlTGluZXMucHVzaChcImV4cG9ydCB7XCIgKyByZWV4cG9ydHNDb2RlICsgXCJ9IGZyb20gJ1wiICsgX3RoaXMuX2ltcG9ydFJlc29sdmVyLmZpbGVOYW1lVG9Nb2R1bGVOYW1lKGV4cG9ydGVkRmlsZVBhdGgsIGdlbkZpbGVQYXRoKSArIFwiJztcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb252ZXJ0ZXIuaW1wb3J0c1dpdGhQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgsIGltcG9ydGVkRmlsZVBhdGgpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGNhbid0IHdyaXRlIHRoZSByZWFsIHdvcmQgZm9yIGltcG9ydCBhcyBpdCBzY3Jld3MgdXAgc3lzdGVtLmpzIGF1dG8gZGV0ZWN0aW9uLi4uXG4gICAgICAgICAgICBwcmVhbWJsZUxpbmVzLnB1c2goXCJpbXBcIiArXG4gICAgICAgICAgICAgICAgKFwib3J0ICogYXMgXCIgKyBwcmVmaXggKyBcIiBmcm9tICdcIiArIF90aGlzLl9pbXBvcnRSZXNvbHZlci5maWxlTmFtZVRvTW9kdWxlTmFtZShpbXBvcnRlZEZpbGVQYXRoLCBnZW5GaWxlUGF0aCkgKyBcIic7XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNtID0gY3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgcHJlYW1ibGVMaW5lcy5sZW5ndGgpLnRvSnNDb21tZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVzID0gcHJlYW1ibGVMaW5lcy5jb25jYXQoW2N0eC50b1NvdXJjZSgpLCBzbV0pO1xuICAgICAgICBpZiAoc20pIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBhZGQgYSBuZXdsaW5lIGF0IHRoZSBlbmQsIGFzIHNvbWUgdG9vbHMgaGF2ZSBidWdzIHdpdGhvdXQgaXQuXG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHlwZVNjcmlwdEVtaXR0ZXI7XG59KCkpO1xudmFyIF9Uc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX1RzRW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZ2VuRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez99IF9pbXBvcnRSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKF9nZW5GaWxlUGF0aCwgX2ltcG9ydFJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZ2VuRmlsZVBhdGggPSBfZ2VuRmlsZVBhdGg7XG4gICAgICAgIF90aGlzLl9pbXBvcnRSZXNvbHZlciA9IF9pbXBvcnRSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMudHlwZUV4cHJlc3Npb24gPSAwO1xuICAgICAgICBfdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5yZWV4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh0LCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmIChkZWZhdWx0VHlwZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUeXBlID0gJ2FueSc7IH1cbiAgICAgICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbisrO1xuICAgICAgICAgICAgdC52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBkZWZhdWx0VHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBhc3QudHlwZSAhPSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIiArIHZhbHVlICsgXCIgYXMgYW55KVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcgYXMgYW55W10pJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl92aXNpdElkZW50aWZpZXIoYXN0LnZhbHVlLCBhc3QudHlwZVBhcmFtcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpICYmIHN0bXQudmFsdWUgaW5zdGFuY2VvZiBFeHRlcm5hbEV4cHIgJiYgIXN0bXQudHlwZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgcmVleHBvcnRcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuX3Jlc29sdmVTdGF0aWNTeW1ib2woc3RtdC52YWx1ZS52YWx1ZSksIG5hbWUgPSBfYS5uYW1lLCBmaWxlUGF0aCA9IF9hLmZpbGVQYXRoLCBtZW1iZXJzID0gX2EubWVtYmVycztcbiAgICAgICAgICAgIGlmIChtZW1iZXJzLmxlbmd0aCA9PT0gMCAmJiBmaWxlUGF0aCAhPT0gdGhpcy5fZ2VuRmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWV4cG9ydHMgPSB0aGlzLnJlZXhwb3J0cy5nZXQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZXhwb3J0cy5zZXQoZmlsZVBhdGgsIHJlZXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZXhwb3J0cy5wdXNoKHsgbmFtZTogbmFtZSwgYXM6IHN0bXQubmFtZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRmluYWwpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcInZhclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIgKyBzdG10Lm5hbWUpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShzdG10LnR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIiA9IFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKDxcIik7XG4gICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIj5cIik7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgaWYgKHN0bXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcIiBleHRlbmRzIFwiKTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgc3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzRmllbGQoZmllbGQsIGN0eCk7IH0pO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0dldHRlcihnZXR0ZXIsIGN0eCk7IH0pO1xuICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWVsZFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgY3R4KSB7XG4gICAgICAgIGlmIChmaWVsZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgb3V0IGFzIGEgd29ya2Fyb3VuZCBmb3IgIzEwOTY3XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCIvKnByaXZhdGUqLyBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIGZpZWxkLm5hbWUpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShmaWVsZC50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIjtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGdldHRlclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgaWYgKGdldHRlci5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcInByaXZhdGUgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcImdldCBcIiArIGdldHRlci5uYW1lICsgXCIoKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZ2V0dGVyLnR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiID0+IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKHN0bXQudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ0cnkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gY2F0Y2ggKFwiICsgQ0FUQ0hfRVJST1JfVkFSJDEubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhdGNoU3RtdHMgPSBbLyoqIEB0eXBlIHs/fSAqLyAoQ0FUQ0hfU1RBQ0tfVkFSJDEuc2V0KENBVENIX0VSUk9SX1ZBUiQxLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgXSkpXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZVN0cjtcbiAgICAgICAgc3dpdGNoICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdhbnknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJ1aWx0aW4gdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIHR5cGVTdHIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25UeXBlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLm9mLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJbXVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLnZhbHVlVHlwZSwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5fcHJpbnRDb2xvblR5cGUocGFyYW0udHlwZSwgY3R4KTtcbiAgICAgICAgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Jlc29sdmVTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmZXJlbmNlID0gdmFsdWUucmVmZXJlbmNlO1xuICAgICAgICBpZiAoIShyZWZlcmVuY2UgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogdW5rbm93biBpZGVudGlmaWVyIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcml0eSA9IHRoaXMuX2ltcG9ydFJlc29sdmVyLmdldFR5cGVBcml0eShyZWZlcmVuY2UpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0UmVmZXJlbmNlID0gdGhpcy5faW1wb3J0UmVzb2x2ZXIuZ2V0SW1wb3J0QXMocmVmZXJlbmNlKSB8fCByZWZlcmVuY2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBpbXBvcnRSZWZlcmVuY2UubmFtZSxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBpbXBvcnRSZWZlcmVuY2UuZmlsZVBhdGgsXG4gICAgICAgICAgICBtZW1iZXJzOiBpbXBvcnRSZWZlcmVuY2UubWVtYmVycywgYXJpdHk6IGFyaXR5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlUGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlUGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcmVzb2x2ZVN0YXRpY1N5bWJvbCh2YWx1ZSksIG5hbWUgPSBfYS5uYW1lLCBmaWxlUGF0aCA9IF9hLmZpbGVQYXRoLCBtZW1iZXJzID0gX2EubWVtYmVycywgYXJpdHkgPSBfYS5hcml0eTtcbiAgICAgICAgaWYgKGZpbGVQYXRoICE9IHRoaXMuX2dlbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaW1wb3J0XCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2V0KGZpbGVQYXRoLCBwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHByZWZpeCArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBuYW1lKTtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnLicpO1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIG1lbWJlcnMuam9pbignLicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlRXhwcmVzc2lvbiA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbiBhIHR5cGUgZXhwcmVzc2lvbiB0aGF0IHJlZmVycyB0byBhIGdlbmVyaWMgdHlwZSB0aGVuIHN1cHBseVxuICAgICAgICAgICAgLy8gdGhlIHJlcXVpcmVkIHR5cGUgcGFyYW1ldGVycy4gSWYgdGhlcmUgd2VyZSBub3QgZW5vdWdoIHR5cGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgLy8gc3VwcGxpZWQsIHN1cHBseSBhbnkgYXMgdGhlIHR5cGUuIE91dHNpZGUgYSB0eXBlIGV4cHJlc3Npb24gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBzdXBwbHkgdHlwZSBwYXJhbWV0ZXJzIGFuZCBiZSB0cmVhdGVkIGFzIGEgc2ltcGxlIHZhbHVlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGl0c2VsZi5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1cHBsaWVkUGFyYW1ldGVycyA9ICh0eXBlUGFyYW1zICYmIHR5cGVQYXJhbXMubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkaXRpb25hbFBhcmFtZXRlcnMgPSAoYXJpdHkgfHwgMCkgLSBzdXBwbGllZFBhcmFtZXRlcnM7XG4gICAgICAgICAgICBpZiAoc3VwcGxpZWRQYXJhbWV0ZXJzID4gMCB8fCBhZGRpdGlvbmFsUGFyYW1ldGVycyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCI8XCIpO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwbGllZFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnZpc2l0VHlwZShfdGhpcywgY3R4KTsgfSwgdHlwZVBhcmFtcywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhZGRpdGlvbmFsUGFyYW1ldGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgfHwgc3VwcGxpZWRQYXJhbWV0ZXJzID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnYW55Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9wcmludENvbG9uVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJzonKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBMSVNUIE9GIFNFQ1VSSVRZIFNFTlNJVElWRSBQUk9QRVJUSUVTIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG52YXIgU0VDVVJJVFlfU0NIRU1BID0ge307XG4vKipcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHNwZWNzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZWdpc3RlckNvbnRleHQoY3R4LCBzcGVjcykge1xuICAgIGZvciAodmFyIF9pID0gMCwgc3BlY3NfMSA9IHNwZWNzOyBfaSA8IHNwZWNzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzcGVjID0gc3BlY3NfMVtfaV07XG4gICAgICAgIFNFQ1VSSVRZX1NDSEVNQVtzcGVjLnRvTG93ZXJDYXNlKCldID0gY3R4O1xuICAgIH1cbn1cbi8vIENhc2UgaXMgaW5zaWduaWZpY2FudCBiZWxvdywgYWxsIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBuYW1lcyBhcmUgbG93ZXItY2FzZWQgZm9yIGxvb2t1cC5cbnJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICdpZnJhbWV8c3JjZG9jJyxcbiAgICAnKnxpbm5lckhUTUwnLFxuICAgICcqfG91dGVySFRNTCcsXG5dKTtcbnJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuU1RZTEUsIFsnKnxzdHlsZSddKTtcbi8vIE5COiBubyBTQ1JJUFQgY29udGV4dHMgaGVyZSwgdGhleSBhcmUgbmV2ZXIgYWxsb3dlZCBkdWUgdG8gdGhlIHBhcnNlciBzdHJpcHBpbmcgdGhlbS5cbnJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuVVJMLCBbXG4gICAgJyp8Zm9ybUFjdGlvbicsICdhcmVhfGhyZWYnLCAnYXJlYXxwaW5nJywgJ2F1ZGlvfHNyYycsICdhfGhyZWYnLFxuICAgICdhfHBpbmcnLCAnYmxvY2txdW90ZXxjaXRlJywgJ2JvZHl8YmFja2dyb3VuZCcsICdkZWx8Y2l0ZScsICdmb3JtfGFjdGlvbicsXG4gICAgJ2ltZ3xzcmMnLCAnaW1nfHNyY3NldCcsICdpbnB1dHxzcmMnLCAnaW5zfGNpdGUnLCAncXxjaXRlJyxcbiAgICAnc291cmNlfHNyYycsICdzb3VyY2V8c3Jjc2V0JywgJ3RyYWNrfHNyYycsICd2aWRlb3xwb3N0ZXInLCAndmlkZW98c3JjJyxcbl0pO1xucmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIFtcbiAgICAnYXBwbGV0fGNvZGUnLFxuICAgICdhcHBsZXR8Y29kZWJhc2UnLFxuICAgICdiYXNlfGhyZWYnLFxuICAgICdlbWJlZHxzcmMnLFxuICAgICdmcmFtZXxzcmMnLFxuICAgICdoZWFkfHByb2ZpbGUnLFxuICAgICdodG1sfG1hbmlmZXN0JyxcbiAgICAnaWZyYW1lfHNyYycsXG4gICAgJ2xpbmt8aHJlZicsXG4gICAgJ21lZGlhfHNyYycsXG4gICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgJ29iamVjdHxkYXRhJyxcbiAgICAnc2NyaXB0fHNyYycsXG5dKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBCT09MRUFOID0gJ2Jvb2xlYW4nO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xudmFyIFNUUklORyA9ICdzdHJpbmcnO1xudmFyIE9CSkVDVCA9ICdvYmplY3QnO1xuLyoqXG4gKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAqIHVzaW5nIGBlbGVtZW50X2luaGVyaXRhbmNlfHByb3BlcnRpZXNgIHN5bnRheC5cbiAqXG4gKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gKlxuICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gKiBoYXMgaWRlbnRpY2FsIHByb3BlcnRpZXMuXG4gKlxuICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gKiBzcGVjaWZpZWQgdGhlbiBgXCJcImAgKGJsYW5rKSBlbGVtZW50IGlzIGFzc3VtZWQuXG4gKlxuICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICogZWxlbWVudHMuXG4gKlxuICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICpcbiAqICMjIFByb3BlcnRpZXNcbiAqXG4gKiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mIHByb3BlcnRpZXMgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRWFjaCBwcm9wZXJ0eSBjYW4gYmUgcHJlZml4ZWRcbiAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gKlxuICogLSAobm8gcHJlZml4KTogcHJvcGVydHkgaXMgYSBzdHJpbmcuXG4gKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gKiAtIGAjYDogcHJvcGVydHkgaXMgYSBudW1iZXIuXG4gKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIFF1ZXJ5XG4gKlxuICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gKiBpZiBhIGdpdmVuIHByb3BlcnR5IGV4aXN0IG9uIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICogTk9URTogVGhpcyBzY2hlbWEgaXMgYXV0byBleHRyYWN0ZWQgZnJvbSBgc2NoZW1hX2V4dHJhY3Rvci50c2AgbG9jYXRlZCBpbiB0aGUgdGVzdCBmb2xkZXIsXG4gKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICBETyBOT1QgRURJVCBUSElTIERPTSBTQ0hFTUEgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vXG4vLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuLy8gZG9tX3NlY3VyaXR5X3NjaGVtYS50cy4gUmVhY2ggb3V0IHRvIG1wcm9ic3QgJiByamFtZXQgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxudmFyIFNDSEVNQSA9IFtcbiAgICAnW0VsZW1lbnRdfHRleHRDb250ZW50LCVjbGFzc0xpc3QsY2xhc3NOYW1lLGlkLGlubmVySFRNTCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqY29weSwqY3V0LCpwYXN0ZSwqc2VhcmNoLCpzZWxlY3RzdGFydCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlckhUTUwsI3Njcm9sbExlZnQsI3Njcm9sbFRvcCcsXG4gICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY29weSwqY3VlY2hhbmdlLCpjdXQsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1lc3NhZ2UsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCpwYXN0ZSwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlYXJjaCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNlbGVjdHN0YXJ0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnYWJicixhZGRyZXNzLGFydGljbGUsYXNpZGUsYixiZGksYmRvLGNpdGUsY29kZSxkZCxkZm4sZHQsZW0sZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixpLGtiZCxtYWluLG1hcmssbmF2LG5vc2NyaXB0LHJiLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzZWN0aW9uLHNtYWxsLHN0cm9uZyxzdWIsc3VwLHUsdmFyLHdicl5bSFRNTEVsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY29weSwqY3VlY2hhbmdlLCpjdXQsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1lc3NhZ2UsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCpwYXN0ZSwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlYXJjaCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNlbGVjdHN0YXJ0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjcm9zc09yaWdpbiwjY3VycmVudFRpbWUsIWRlZmF1bHRNdXRlZCwjZGVmYXVsdFBsYXliYWNrUmF0ZSwhZGlzYWJsZVJlbW90ZVBsYXliYWNrLCFsb29wLCFtdXRlZCwqZW5jcnlwdGVkLCNwbGF5YmFja1JhdGUscHJlbG9hZCxzcmMsJXNyY09iamVjdCwjdm9sdW1lJyxcbiAgICAnOnN2ZzpeW0hUTUxFbGVtZW50XXwqYWJvcnQsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3ksc2VhcmNoLHNoYXBlLHRhcmdldCx1c2VybmFtZScsXG4gICAgJ2F1ZGlvXm1lZGlhfCcsXG4gICAgJ2JyXltIVE1MRWxlbWVudF18Y2xlYXInLFxuICAgICdiYXNlXltIVE1MRWxlbWVudF18aHJlZix0YXJnZXQnLFxuICAgICdib2R5XltIVE1MRWxlbWVudF18YUxpbmssYmFja2dyb3VuZCxiZ0NvbG9yLGxpbmssKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQsdGV4dCx2TGluaycsXG4gICAgJ2J1dHRvbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsIWRpc2FibGVkLGZvcm1BY3Rpb24sZm9ybUVuY3R5cGUsZm9ybU1ldGhvZCwhZm9ybU5vVmFsaWRhdGUsZm9ybVRhcmdldCxuYW1lLHR5cGUsdmFsdWUnLFxuICAgICdjYW52YXNeW0hUTUxFbGVtZW50XXwjaGVpZ2h0LCN3aWR0aCcsXG4gICAgJ2NvbnRlbnReW0hUTUxFbGVtZW50XXxzZWxlY3QnLFxuICAgICdkbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAnZGF0YWxpc3ReW0hUTUxFbGVtZW50XXwnLFxuICAgICdkZXRhaWxzXltIVE1MRWxlbWVudF18IW9wZW4nLFxuICAgICdkaWFsb2deW0hUTUxFbGVtZW50XXwhb3BlbixyZXR1cm5WYWx1ZScsXG4gICAgJ2Rpcl5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAnZGl2XltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdlbWJlZF5bSFRNTEVsZW1lbnRdfGFsaWduLGhlaWdodCxuYW1lLHNyYyx0eXBlLHdpZHRoJyxcbiAgICAnZmllbGRzZXReW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbmFtZScsXG4gICAgJ2ZvbnReW0hUTUxFbGVtZW50XXxjb2xvcixmYWNlLHNpemUnLFxuICAgICdmb3JtXltIVE1MRWxlbWVudF18YWNjZXB0Q2hhcnNldCxhY3Rpb24sYXV0b2NvbXBsZXRlLGVuY29kaW5nLGVuY3R5cGUsbWV0aG9kLG5hbWUsIW5vVmFsaWRhdGUsdGFyZ2V0JyxcbiAgICAnZnJhbWVeW0hUTUxFbGVtZW50XXxmcmFtZUJvcmRlcixsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSwhbm9SZXNpemUsc2Nyb2xsaW5nLHNyYycsXG4gICAgJ2ZyYW1lc2V0XltIVE1MRWxlbWVudF18Y29scywqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCpvZmZsaW5lLCpvbmxpbmUsKnBhZ2VoaWRlLCpwYWdlc2hvdywqcG9wc3RhdGUsKnJlamVjdGlvbmhhbmRsZWQsKnJlc2l6ZSwqc2Nyb2xsLCpzdG9yYWdlLCp1bmhhbmRsZWRyZWplY3Rpb24sKnVubG9hZCxyb3dzJyxcbiAgICAnaHJeW0hUTUxFbGVtZW50XXxhbGlnbixjb2xvciwhbm9TaGFkZSxzaXplLHdpZHRoJyxcbiAgICAnaGVhZF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2XltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdodG1sXltIVE1MRWxlbWVudF18dmVyc2lvbicsXG4gICAgJ2lmcmFtZV5bSFRNTEVsZW1lbnRdfGFsaWduLCFhbGxvd0Z1bGxzY3JlZW4sZnJhbWVCb3JkZXIsaGVpZ2h0LGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLHJlZmVycmVyUG9saWN5LCVzYW5kYm94LHNjcm9sbGluZyxzcmMsc3JjZG9jLHdpZHRoJyxcbiAgICAnaW1nXltIVE1MRWxlbWVudF18YWxpZ24sYWx0LGJvcmRlciwlY3Jvc3NPcmlnaW4sI2hlaWdodCwjaHNwYWNlLCFpc01hcCxsb25nRGVzYyxsb3dzcmMsbmFtZSxyZWZlcnJlclBvbGljeSxzaXplcyxzcmMsc3Jjc2V0LHVzZU1hcCwjdnNwYWNlLCN3aWR0aCcsXG4gICAgJ2lucHV0XltIVE1MRWxlbWVudF18YWNjZXB0LGFsaWduLGFsdCxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhY2hlY2tlZCwhZGVmYXVsdENoZWNrZWQsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCVmaWxlcyxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsI2hlaWdodCwhaW5jcmVtZW50YWwsIWluZGV0ZXJtaW5hdGUsbWF4LCNtYXhMZW5ndGgsbWluLCNtaW5MZW5ndGgsIW11bHRpcGxlLG5hbWUscGF0dGVybixwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCwjc2l6ZSxzcmMsc3RlcCx0eXBlLHVzZU1hcCx2YWx1ZSwldmFsdWVBc0RhdGUsI3ZhbHVlQXNOdW1iZXIsI3dpZHRoJyxcbiAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGtleXR5cGUsbmFtZScsXG4gICAgJ2xpXltIVE1MRWxlbWVudF18dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2xpbmteW0hUTUxFbGVtZW50XXxhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCwjbGVuZ3RoLCFtdWx0aXBsZSxuYW1lLCFyZXF1aXJlZCwjc2VsZWN0ZWRJbmRleCwjc2l6ZSx2YWx1ZScsXG4gICAgJ3NoYWRvd15bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3NvdXJjZV5bSFRNTEVsZW1lbnRdfG1lZGlhLHNpemVzLHNyYyxzcmNzZXQsdHlwZScsXG4gICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAnY2FwdGlvbl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgJ3RhYmxlXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixib3JkZXIsJWNhcHRpb24sY2VsbFBhZGRpbmcsY2VsbFNwYWNpbmcsZnJhbWUscnVsZXMsc3VtbWFyeSwldEZvb3QsJXRIZWFkLHdpZHRoJyxcbiAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGVtcGxhdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jYXBpdGFsaXplLCFhdXRvZm9jdXMsI2NvbHMsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCNtYXhMZW5ndGgsI21pbkxlbmd0aCxuYW1lLHBsYWNlaG9sZGVyLCFyZWFkT25seSwhcmVxdWlyZWQsI3Jvd3Msc2VsZWN0aW9uRGlyZWN0aW9uLCNzZWxlY3Rpb25FbmQsI3NlbGVjdGlvblN0YXJ0LHZhbHVlLHdyYXAnLFxuICAgICd0aXRsZV5bSFRNTEVsZW1lbnRdfHRleHQnLFxuICAgICd0cmFja15bSFRNTEVsZW1lbnRdfCFkZWZhdWx0LGtpbmQsbGFiZWwsc3JjLHNyY2xhbmcnLFxuICAgICd1bF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LHR5cGUnLFxuICAgICd1bmtub3duXltIVE1MRWxlbWVudF18JyxcbiAgICAndmlkZW9ebWVkaWF8I2hlaWdodCxwb3N0ZXIsI3dpZHRoJyxcbiAgICAnOnN2ZzphXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzphbmltYXRlXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6YW5pbWF0ZU1vdGlvbl46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVUcmFuc2Zvcm1eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpjaXJjbGVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmNsaXBQYXRoXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8JyxcbiAgICAnOnN2ZzpkZWZzXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpkZXNjXjpzdmc6fCcsXG4gICAgJzpzdmc6ZGlzY2FyZF46c3ZnOnwnLFxuICAgICc6c3ZnOmVsbGlwc2VeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmZlQmxlbmReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbG9yTWF0cml4Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb21wb25lbnRUcmFuc2Zlcl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9zaXRlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb252b2x2ZU1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlmZnVzZUxpZ2h0aW5nXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXNwbGFjZW1lbnRNYXBeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpc3RhbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRHJvcFNoYWRvd146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRmxvb2ReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZ1bmNBXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jR146c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNSXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlR2F1c3NpYW5CbHVyXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVJbWFnZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlTWVyZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlTm9kZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlTW9ycGhvbG9neV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlT2Zmc2V0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVQb2ludExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVTcGVjdWxhckxpZ2h0aW5nXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVTcG90TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVRpbGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVR1cmJ1bGVuY2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmaWx0ZXJeOnN2Zzp8JyxcbiAgICAnOnN2Zzpmb3JlaWduT2JqZWN0Xjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpnXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzppbWFnZV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6bGluZWFyR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOm1wYXRoXjpzdmc6fCcsXG4gICAgJzpzdmc6bWFya2VyXjpzdmc6fCcsXG4gICAgJzpzdmc6bWFza146c3ZnOnwnLFxuICAgICc6c3ZnOm1ldGFkYXRhXjpzdmc6fCcsXG4gICAgJzpzdmc6cGF0aF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cGF0dGVybl46c3ZnOnwnLFxuICAgICc6c3ZnOnBvbHlnb25eOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBvbHlsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpyYWRpYWxHcmFkaWVudF46c3ZnOmdyYWRpZW50fCcsXG4gICAgJzpzdmc6cmVjdF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6c3ZnXjpzdmc6Z3JhcGhpY3N8I2N1cnJlbnRTY2FsZSwjem9vbUFuZFBhbicsXG4gICAgJzpzdmc6c2NyaXB0Xjpzdmc6fHR5cGUnLFxuICAgICc6c3ZnOnNldF46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOnN0b3BeOnN2Zzp8JyxcbiAgICAnOnN2ZzpzdHlsZV46c3ZnOnwhZGlzYWJsZWQsbWVkaWEsdGl0bGUsdHlwZScsXG4gICAgJzpzdmc6c3dpdGNoXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2ZzpzeW1ib2xeOnN2Zzp8JyxcbiAgICAnOnN2Zzp0c3Bhbl46c3ZnOnRleHRQb3NpdGlvbmluZ3wnLFxuICAgICc6c3ZnOnRleHReOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0UGF0aF46c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJzpzdmc6dGl0bGVeOnN2Zzp8JyxcbiAgICAnOnN2Zzp1c2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnZpZXdeOnN2Zzp8I3pvb21BbmRQYW4nLFxuICAgICdkYXRhXltIVE1MRWxlbWVudF18dmFsdWUnLFxuICAgICdtZW51aXRlbV5bSFRNTEVsZW1lbnRdfHR5cGUsbGFiZWwsaWNvbiwhZGlzYWJsZWQsIWNoZWNrZWQscmFkaW9ncm91cCwhZGVmYXVsdCcsXG4gICAgJ3N1bW1hcnleW0hUTUxFbGVtZW50XXwnLFxuICAgICd0aW1lXltIVE1MRWxlbWVudF18ZGF0ZVRpbWUnLFxuXTtcbnZhciBfQVRUUl9UT19QUk9QID0ge1xuICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAgICdmb3InOiAnaHRtbEZvcicsXG4gICAgJ2Zvcm1hY3Rpb24nOiAnZm9ybUFjdGlvbicsXG4gICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4Jyxcbn07XG52YXIgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICBTQ0hFTUEuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RlZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0ge307XG4gICAgICAgICAgICB2YXIgX2EgPSBlbmNvZGVkVHlwZS5zcGxpdCgnfCcpLCBzdHJUeXBlID0gX2FbMF0sIHN0clByb3BlcnRpZXMgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gc3RyUHJvcGVydGllcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIF9iID0gc3RyVHlwZS5zcGxpdCgnXicpLCB0eXBlTmFtZXMgPSBfYlswXSwgc3VwZXJOYW1lID0gX2JbMV07XG4gICAgICAgICAgICB0eXBlTmFtZXMuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIF90aGlzLl9zY2hlbWFbdGFnLnRvTG93ZXJDYXNlKCldID0gdHlwZTsgfSk7XG4gICAgICAgICAgICB2YXIgc3VwZXJUeXBlID0gc3VwZXJOYW1lICYmIF90aGlzLl9zY2hlbWFbc3VwZXJOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKHN1cGVyVHlwZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN1cGVyVHlwZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyB0eXBlW3Byb3BdID0gc3VwZXJUeXBlW3Byb3BdOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB5ZXQgc3VwcG9ydCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZXZlciBhbGxvd2luZyB0byBiaW5kIHRvIGV2ZW50cywgR08gVEhST1VHSCBBIFNFQ1VSSVRZIFJFVklFVywgYWxsb3dpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbW9zdCBjZXJ0YWlubHkgaW50cm9kdWNlIGJhZCBYU1MgdnVsbmVyYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEVWRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gQk9PTEVBTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE5VTUJFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE9CSkVDVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eV0gPSBTVFJJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hTWV0YXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBOT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICduZy1jb250YWluZXInIHx8IHRhZ05hbWUgPT09ICduZy1jb250ZW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAvLyBvbmNlIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRQcm9wZXJ0aWVzID0gdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgdGhpcy5fc2NoZW1hWyd1bmtub3duJ107XG4gICAgICAgIHJldHVybiAhIWVsZW1lbnRQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hTWV0YXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbmctY29udGFpbmVyJyB8fCB0YWdOYW1lID09PSAnbmctY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgYW55IGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2VjdXJpdHlDb250ZXh0IHJldHVybnMgdGhlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZy5cbiAgICAgKlxuICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAqIHBvc3NpYmxlIHRvIGJpbmQgYSB2YWx1ZSBpbnRvIGEgY2hhbmdpbmcgYXR0cmlidXRlIG9yIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIGZpbHRlcmluZyBpcyB3aGl0ZSBsaXN0IGJhc2VkLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlXG4gICAgICogJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0IHN0cmluZyB2YWx1ZXMuIE9ubHkgc3BlY2lmaWMgd2VsbCBrbm93blxuICAgICAqIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gU0VDVVJJVFlfU0NIRU1BW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BWycqfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIHJldHVybiBjdHggPyBjdHggOiBTZWN1cml0eUNvbnRleHQuTk9ORTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIF9BVFRSX1RPX1BST1BbcHJvcE5hbWVdIHx8IHByb3BOYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnbmctY29tcG9uZW50JzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gXCJCaW5kaW5nIHRvIGV2ZW50IHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIgK1xuICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcbklmICdcIiArIG5hbWUgKyBcIicgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZVwiKSArXG4gICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIiArXG4gICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxLbm93bkVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVtYSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyVmFsID0gdmFsLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9IG51bGw7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGNhbWVsQ2FzZVByb3ApICYmIHZhbCAhPT0gMCAmJiB2YWwgIT09ICcwJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWxBbmRTdWZmaXhNYXRjaCA9IHZhbC5tYXRjaCgvXlsrLV0/W1xcZFxcLl0rKFthLXpdKikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbEFuZFN1ZmZpeE1hdGNoICYmIHZhbEFuZFN1ZmZpeE1hdGNoWzFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gXCJQbGVhc2UgcHJvdmlkZSBhIENTUyB1bml0IHZhbHVlIGZvciBcIiArIHVzZXJQcm92aWRlZFByb3AgKyBcIjpcIiArIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnLCB2YWx1ZTogc3RyVmFsICsgdW5pdCB9O1xuICAgIH07XG4gICAgcmV0dXJuIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbn0oRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KSk7XG5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShwcm9wKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICBjYXNlICdtYXhXaWR0aCc6XG4gICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZU9mZnNldCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdUb3AnOlxuICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdCb3R0b20nOlxuICAgICAgICBjYXNlICdwYWRkaW5nUmlnaHQnOlxuICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICBjYXNlICdtYXJnaW5MZWZ0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICBjYXNlICdib3JkZXJSYWRpdXMnOlxuICAgICAgICBjYXNlICdib3JkZXJXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyTGVmdFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmlnaHRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgY2FzZSAndGV4dEluZGVudCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG52YXIgU2hhZG93Q3NzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dDc3MoKSB7XG4gICAgICAgIHRoaXMuc3RyaWN0U3R5bGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez89fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuc2hpbUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBpZiAoaG9zdFNlbGVjdG9yID09PSB2b2lkIDApIHsgaG9zdFNlbGVjdG9yID0gJyc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTWFwcGluZ1VybCA9IGV4dHJhY3RTb3VyY2VNYXBwaW5nVXJsKGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3RvcikgKyBzb3VyY2VNYXBwaW5nVXJsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsRGlyZWN0aXZlc0luQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsRGlyZWN0aXZlc0luQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbVsyXSArICd7JztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnRSdWxlUmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsxXSwgJycpLnJlcGxhY2UobVsyXSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gc2NvcGVTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAvLyByZXBsYWNlIDpob3N0IGFuZCA6aG9zdC1jb250ZXh0IC1zaGFkb3djc3Nob3N0IGFuZCAtc2hhZG93Y3NzaG9zdCByZXNwZWN0aXZlbHlcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCk7XG4gICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5fc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgcmV0dXJuIGNzc1RleHQudHJpbSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG07XG4gICAgICAgIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDb2xvblJ1bGUoY3NzVGV4dCwgX2Nzc0NvbG9uSG9zdFJlLCB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIHRoaXMuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHBhcmFtIHs/fSByZWdFeHBcbiAgICAgKiBAcGFyYW0gez99IHBhcnRSZXBsYWNlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uUnVsZSA9IGZ1bmN0aW9uIChjc3NUZXh0LCByZWdFeHAsIHBhcnRSZXBsYWNlcikge1xuICAgICAgICAvLyBtWzFdID0gOmhvc3QoLWNvbnRleHQpLCBtWzJdID0gY29udGVudHMgb2YgKCksIG1bM10gcmVzdCBvZiBydWxlXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gbVsyXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcCA9IHBhcnRzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChwYXJ0UmVwbGFjZXIoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciwgcCwgbVszXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBwYXJ0XG4gICAgICogQHBhcmFtIHs/fSBzdWZmaXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIgPSBmdW5jdGlvbiAoaG9zdCwgcGFydCwgc3VmZml4KSB7XG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdCkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9uSG9zdFBhcnRSZXBsYWNlcihob3N0LCBwYXJ0LCBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0ICsgc3VmZml4ICsgJywgJyArIHBhcnQgKyAnICcgKyBob3N0ICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHBhcnRcbiAgICAgKiBAcGFyYW0gez99IHN1ZmZpeFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXR0ZXJuKSB7IHJldHVybiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpOyB9LCBjc3NUZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gc2NvcGVTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9ICdAJykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF90aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc3RyaWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydC50cmltKCkuc3BsaXQoX3NoYWRvd0RlZXBTZWxlY3RvcnMpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVlcFBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgc2hhbGxvd1BhcnQgPSBkZWVwUGFydHNbMF0sIG90aGVyUGFydHMgPSBkZWVwUGFydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBseVNjb3BlID0gZnVuY3Rpb24gKHNoYWxsb3dQYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zZWxlY3Rvck5lZWRzU2NvcGluZyhzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBseVNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1BhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbYXBwbHlTY29wZShzaGFsbG93UGFydCldLmNvbmNhdChvdGhlclBhcnRzKS5qb2luKCcgJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3NlbGVjdG9yTmVlZHNTY29waW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlID0gdGhpcy5fbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuICFyZS50ZXN0KHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2NvcGVTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fbWFrZVNjb3BlTWF0Y2hlciA9IGZ1bmN0aW9uIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxyZSA9IC9cXFsvZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcnJlID0gL1xcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc2NvcGVTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIGZyb20gd2ViY29tcG9uZW50cy5qczogc2NvcGVTZWxlY3RvciBjb3VsZCBub3QgYmUgYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gSW4gQW5kcm9pZCBicm93c2VyLCB0aGUgbGFzdEluZGV4IGlzIG5vdCByZXNldCB3aGVuIHRoZSByZWdleCBpcyB1c2VkIGluIFN0cmluZy5yZXBsYWNlKClcbiAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcGxhY2VCeV8xID0gdGhpcy5zdHJpY3RTdHlsaW5nID8gXCJbXCIgKyBob3N0U2VsZWN0b3IgKyBcIl1cIiA6IHNjb3BlU2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsIGZ1bmN0aW9uIChobmMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoLyhbXjpdKikoOiopKC4qKS8sIGZ1bmN0aW9uIChfLCBiZWZvcmUsIGNvbG9uLCBhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlICsgcmVwbGFjZUJ5XzEgKyBjb2xvbiArIGFmdGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc2NvcGVTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGlzUmUsIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9zY29wZVNlbGVjdG9yUGFydCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRQID0gcC50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzY29wZWRQID0gX3RoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIDpob3N0IHNpbmNlIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2FmZUNvbnRlbnQgPSBuZXcgU2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzYWZlQ29udGVudC5jb250ZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjb3BlZFNlbGVjdG9yID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZUFmdGVyID0gc2VsZWN0b3IuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKTtcbiAgICAgICAgd2hpbGUgKChyZXMgPSBzZXAuZXhlYyhzZWxlY3RvcikpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXBhcmF0b3IgPSByZXNbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0ID0gc2VsZWN0b3Iuc2xpY2Uoc3RhcnRJbmRleCwgcmVzLmluZGV4KS50cmltKCk7XG4gICAgICAgICAgICAvLyBpZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0LWNvbnRleHQgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjb3BlZFBhcnQgPSBzdGFydEluZGV4ID49IHNjb3BlQWZ0ZXIgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICAgICAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gc2NvcGVkUGFydCArIFwiIFwiICsgc2VwYXJhdG9yICsgXCIgXCI7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gc2VwLmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBzY29wZWRTZWxlY3RvciArPSBfc2NvcGVTZWxlY3RvclBhcnQoc2VsZWN0b3Iuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIHJldHVybiBzYWZlQ29udGVudC5yZXN0b3JlKHNjb3BlZFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhZG93Q3NzO1xufSgpKTtcbnZhciBTYWZlU2VsZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYWZlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFJlcGxhY2VzIGF0dHJpYnV0ZSBzZWxlY3RvcnMgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICAgIC8vIFRoZSBXUyBpbiBbYXR0cj1cInZhIGx1ZVwiXSB3b3VsZCBvdGhlcndpc2UgYmUgaW50ZXJwcmV0ZWQgYXMgYSBzZWxlY3RvciBzZXBhcmF0b3IuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvKFxcW1teXFxdXSpcXF0pL2csIGZ1bmN0aW9uIChfLCBrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZUJ5ID0gXCJfX3BoLVwiICsgX3RoaXMuaW5kZXggKyBcIl9fXCI7XG4gICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMucHVzaChrZWVwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW4gYDpudGgtY2hpbGQoMm4gKyAxKWAgd2l0aCBhIHBsYWNlaG9sZGVyLlxuICAgICAgICAvLyBXUyBhbmQgXCIrXCIgd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIHNlbGVjdG9yIHNlcGFyYXRvcnMuXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBzZWxlY3Rvci5yZXBsYWNlKC8oOm50aC1bLVxcd10rKShcXChbXildK1xcKSkvZywgZnVuY3Rpb24gKF8sIHBzZXVkbywgZXhwKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZUJ5ID0gXCJfX3BoLVwiICsgX3RoaXMuaW5kZXggKyBcIl9fXCI7XG4gICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMucHVzaChleHApO1xuICAgICAgICAgICAgX3RoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBwc2V1ZG8gKyByZXBsYWNlQnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTYWZlU2VsZWN0b3IucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9fX3BoLShcXGQrKV9fL2csIGZ1bmN0aW9uIChwaCwgaW5kZXgpIHsgcmV0dXJuIF90aGlzLnBsYWNlaG9sZGVyc1sraW5kZXhdOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGVudDsgfTtcbiAgICByZXR1cm4gU2FmZVNlbGVjdG9yO1xufSgpKTtcbnZhciBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlID0gL3BvbHlmaWxsLW5leHQtc2VsZWN0b3JbXn1dKmNvbnRlbnQ6W1xcc10qPyhbJ1wiXSkoLio/KVxcMVs7XFxzXSp9KFtee10qPyl7L2dpbTtcbnZhciBfY3NzQ29udGVudFJ1bGVSZSA9IC8ocG9seWZpbGwtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbnZhciBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlID0gLyhwb2x5ZmlsbC11bnNjb3BlZC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xudmFyIF9wb2x5ZmlsbEhvc3QgPSAnLXNoYWRvd2Nzc2hvc3QnO1xuLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbnZhciBfcG9seWZpbGxIb3N0Q29udGV4dCA9ICctc2hhZG93Y3NzY29udGV4dCc7XG52YXIgX3BhcmVuU3VmZml4ID0gJykoPzpcXFxcKCgnICtcbiAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAnKVxcXFwpKT8oW14se10qKSc7XG52YXIgX2Nzc0NvbG9uSG9zdFJlID0gbmV3IFJlZ0V4cCgnKCcgKyBfcG9seWZpbGxIb3N0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG52YXIgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlID0gLy1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3IoW15cXHNdKikvO1xudmFyIF9zaGFkb3dET01TZWxlY3RvcnNSZSA9IFtcbiAgICAvOjpzaGFkb3cvZyxcbiAgICAvOjpjb250ZW50L2csXG4gICAgLy8gRGVwcmVjYXRlZCBzZWxlY3RvcnNcbiAgICAvXFwvc2hhZG93LWRlZXBcXC8vZyxcbiAgICAvXFwvc2hhZG93XFwvL2csXG5dO1xudmFyIF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLykvZztcbnZhciBfc2VsZWN0b3JSZVN1ZmZpeCA9ICcoWz5cXFxcc34rXFxbLix7Ol1bXFxcXHNcXFxcU10qKT8kJztcbnZhciBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG52YXIgX2NvbG9uSG9zdENvbnRleHRSZSA9IC86aG9zdC1jb250ZXh0L2dpbTtcbnZhciBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShfY29tbWVudFJlLCAnJyk7XG59XG4vLyBhbGwgY29tbWVudHMgZXhjZXB0IGlubGluZSBzb3VyY2UgbWFwcGluZ1xudmFyIF9zb3VyY2VNYXBwaW5nVXJsUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlTWFwcGluZ1VSTD1bXFxzXFxTXSs/XFwqXFwvLztcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFNvdXJjZU1hcHBpbmdVcmwoaW5wdXQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gaW5wdXQubWF0Y2goX3NvdXJjZU1hcHBpbmdVcmxSZSk7XG4gICAgcmV0dXJuIG1hdGNoZXIgPyBtYXRjaGVyWzBdIDogJyc7XG59XG52YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG52YXIgX2N1cmx5UmUgPSAvKFt7fV0pL2c7XG52YXIgT1BFTl9DVVJMWSA9ICd7JztcbnZhciBDTE9TRV9DVVJMWSA9ICd9JztcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9ICclQkxPQ0slJztcbnZhciBDc3NSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBDc3NSdWxlO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBydWxlQ2FsbGJhY2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NSdWxlcyhpbnB1dCwgcnVsZUNhbGxiYWNrKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRXaXRoRXNjYXBlZEJsb2NrcyA9IGVzY2FwZUJsb2NrcyhpbnB1dCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dEJsb2NrSW5kZXggPSAwO1xuICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBtWzJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1ZmZpeCA9IG1bNF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRQcmVmaXggPSAnJztcbiAgICAgICAgaWYgKHN1ZmZpeCAmJiBzdWZmaXguc3RhcnRzV2l0aCgneycgKyBCTE9DS19QTEFDRUhPTERFUikpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmJsb2Nrc1tuZXh0QmxvY2tJbmRleCsrXTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoQkxPQ0tfUExBQ0VIT0xERVIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBydWxlQ2FsbGJhY2sobmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpKTtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBtWzFdICsgcnVsZS5zZWxlY3RvciArIG1bM10gKyBjb250ZW50UHJlZml4ICsgcnVsZS5jb250ZW50ICsgc3VmZml4O1xuICAgIH0pO1xufVxudmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVzY2FwZWRTdHJpbmdcbiAgICAgKiBAcGFyYW0gez99IGJsb2Nrc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKGVzY2FwZWRTdHJpbmcsIGJsb2Nrcykge1xuICAgICAgICB0aGlzLmVzY2FwZWRTdHJpbmcgPSBlc2NhcGVkU3RyaW5nO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlQmxvY2tzKGlucHV0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRQYXJ0cyA9IGlucHV0LnNwbGl0KF9jdXJseVJlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRQYXJ0cyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVzY2FwZWRCbG9ja3MgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBicmFja2V0Q291bnQgPSAwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBpbnB1dFBhcnRzLmxlbmd0aDsgcGFydEluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IGlucHV0UGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgaWYgKHBhcnQgPT0gQ0xPU0VfQ1VSTFkpIHtcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0ID09IE9QRU5fQ1VSTFkpIHtcbiAgICAgICAgICAgIGJyYWNrZXRDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKHJlc3VsdFBhcnRzLmpvaW4oJycpLCBlc2NhcGVkQmxvY2tzKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbnZhciBIT1NUX0FUVFIgPSBcIl9uZ2hvc3QtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XG52YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gaXNTaGltbWVkXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kobmFtZSwgbW9kdWxlVXJsLCBpc1NoaW1tZWQsIHZhbHVlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuaXNTaGltbWVkID0gaXNTaGltbWVkO1xuICAgICAgICB0aGlzLnZhbHVlUGxhY2Vob2xkZXIgPSB2YWx1ZVBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZXR1cm4gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3k7XG59KCkpO1xudmFyIFN0eWxlc0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50U3R5bGVzaGVldFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVSZXN1bHQoY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0cykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudFN0eWxlc2hlZXQgPSBjb21wb25lbnRTdHlsZXNoZWV0O1xuICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBleHRlcm5hbFN0eWxlc2hlZXRzO1xuICAgIH1cbiAgICByZXR1cm4gU3R5bGVzQ29tcGlsZVJlc3VsdDtcbn0oKSk7XG52YXIgQ29tcGlsZWRTdHlsZXNoZWV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlc1ZhclxuICAgICAqIEBwYXJhbSB7P30gZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIHs/fSBpc1NoaW1tZWRcbiAgICAgKiBAcGFyYW0gez99IG1ldGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlZFN0eWxlc2hlZXQoc3RhdGVtZW50cywgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIGlzU2hpbW1lZCwgbWV0YSkge1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICB0aGlzLnN0eWxlc1ZhciA9IHN0eWxlc1ZhcjtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuaXNTaGltbWVkID0gaXNTaGltbWVkO1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZWRTdHlsZXNoZWV0O1xufSgpKTtcbnZhciBTdHlsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF91cmxSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlQ29tcGlsZXIoX3VybFJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICB0aGlzLl9zaGFkb3dDc3MgPSBuZXcgU2hhZG93Q3NzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dGVybmFsU3R5bGVzaGVldHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50U3R5bGVzaGVldCA9IHRoaXMuX2NvbXBpbGVTdHlsZXMoY29tcCwgbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgc3R5bGVzOiBjb21wLnRlbXBsYXRlLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogY29tcC50ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICBtb2R1bGVVcmw6IGlkZW50aWZpZXJNb2R1bGVVcmwoY29tcC50eXBlKVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIGNvbXAudGVtcGxhdGUuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXNoZWV0TWV0YSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRTdHlsZXNoZWV0ID0gX3RoaXMuX2NvbXBpbGVTdHlsZXMoY29tcCwgc3R5bGVzaGVldE1ldGEsIGZhbHNlKTtcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHMucHVzaChjb21waWxlZFN0eWxlc2hlZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNoZWV0XG4gICAgICogQHBhcmFtIHs/fSBpc0NvbXBvbmVudFN0eWxlc2hlZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlU3R5bGVzID0gZnVuY3Rpb24gKGNvbXAsIHN0eWxlc2hlZXQsIGlzQ29tcG9uZW50U3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaGltID0gY29tcC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVFeHByZXNzaW9ucyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gbGl0ZXJhbChfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3R5bGVzaGVldC5zdHlsZVVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkZW50aWZpZXIgPSB7IHJlZmVyZW5jZTogbnVsbCB9O1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobmV3IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KGdldFN0eWxlc1Zhck5hbWUobnVsbCksIHN0eWxlc2hlZXQuc3R5bGVVcmxzW2ldLCBzaGltLCBpZGVudGlmaWVyKSk7XG4gICAgICAgICAgICBzdHlsZUV4cHJlc3Npb25zLnB1c2gobmV3IEV4dGVybmFsRXhwcihpZGVudGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3R5bGVzIHZhcmlhYmxlIGNvbnRhaW5zIHBsYWluIHN0cmluZ3MgYW5kIGFycmF5cyBvZiBvdGhlciBzdHlsZXMgYXJyYXlzIChyZWN1cnNpdmUpLFxuICAgICAgICAvLyBzbyB3ZSBzZXQgaXRzIHR5cGUgdG8gZHluYW1pYy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzVmFyID0gZ2V0U3R5bGVzVmFyTmFtZShpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBjb21wIDogbnVsbCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXQgPSB2YXJpYWJsZShzdHlsZXNWYXIpXG4gICAgICAgICAgICAuc2V0KGxpdGVyYWxBcnIoc3R5bGVFeHByZXNzaW9ucywgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRTdHlsZXNoZWV0KFtzdG10XSwgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIHNoaW0sIHN0eWxlc2hlZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gc2hpbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX3NoaW1JZk5lZWRlZCA9IGZ1bmN0aW9uIChzdHlsZSQkMSwgc2hpbSkge1xuICAgICAgICByZXR1cm4gc2hpbSA/IHRoaXMuX3NoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSQkMSwgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDogc3R5bGUkJDE7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVDb21waWxlcjtcbn0oKSk7XG5TdHlsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblN0eWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbl07IH07XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZXNWYXJOYW1lKGNvbXBvbmVudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFwic3R5bGVzXCI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICByZXN1bHQgKz0gXCJfXCIgKyBpZGVudGlmaWVyTmFtZShjb21wb25lbnQudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRXZlbnRIYW5kbGVyVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyVmFycygpIHtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnM7XG59KCkpO1xuRXZlbnRIYW5kbGVyVmFycy5ldmVudCA9IHZhcmlhYmxlKCckZXZlbnQnKTtcbnZhciBDb252ZXJ0QWN0aW9uQmluZGluZ1Jlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10c1xuICAgICAqIEBwYXJhbSB7P30gYWxsb3dEZWZhdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoc3RtdHMsIGFsbG93RGVmYXVsdCkge1xuICAgICAgICB0aGlzLnN0bXRzID0gc3RtdHM7XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gYWxsb3dEZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gKiB1c2VkIGluIGFuIGFjdGlvbiBiaW5kaW5nIChlLmcuIGFuIGV2ZW50IGhhbmRsZXIpLlxuICogQHBhcmFtIHs/fSBsb2NhbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGltcGxpY2l0UmVjZWl2ZXJcbiAqIEBwYXJhbSB7P30gYWN0aW9uXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydEFjdGlvbkJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYWN0aW9uLCBiaW5kaW5nSWQpIHtcbiAgICBpZiAoIWxvY2FsUmVzb2x2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlciA9IG5ldyBEZWZhdWx0TG9jYWxSZXNvbHZlcigpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3Rpb25XaXRob3V0QnVpbHRpbnMgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IGZ1bmN0aW9uIChhcmdDb3VudCkge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBhcnJheXMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gbGl0ZXJhbEFycihhcmdzKTsgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgbWFwcyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBsaXRlcmFsTWFwKC8qKiBAdHlwZSB7P30gKi8gKGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGkpIHsgcmV0dXJuIFtrZXksIGFyZ3NbaV1dOyB9KSkpOyB9O1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVQaXBlQ29udmVydGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogQWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgdG8gY29udGFpbiBwaXBlcy4gUGlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0sIGFjdGlvbik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3Rpb25TdG10cyA9IFtdO1xuICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKGFjdGlvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5TdGF0ZW1lbnQpLCBhY3Rpb25TdG10cyk7XG4gICAgcHJlcGVuZFRlbXBvcmFyeURlY2xzKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgYWN0aW9uU3RtdHMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RJbmRleCA9IGFjdGlvblN0bXRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmVudERlZmF1bHRWYXIgPSBudWxsO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmV0dXJuRXhwciA9IGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24obGFzdFN0YXRlbWVudCk7XG4gICAgICAgIGlmIChyZXR1cm5FeHByKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNhc3QgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgdG8gZHluYW1pYyxcbiAgICAgICAgICAgIC8vIGFzIGl0IG1pZ2h0IGJlIGEgdm9pZCBtZXRob2QhXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhciA9IGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCk7XG4gICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhci5zZXQocmV0dXJuRXhwci5jYXN0KERZTkFNSUNfVFlQRSkubm90SWRlbnRpY2FsKGxpdGVyYWwoZmFsc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoYWN0aW9uU3RtdHMsIHByZXZlbnREZWZhdWx0VmFyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJGYWN0b3J5XG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbnZhciBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjdXJyVmFsRXhwclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByKSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdDtcbn0oKSk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb25cbiAqIGlzIHVzZWQgaW4gcHJvcGVydHkgYmluZGluZy4gVGhlIGV4cHJlc3Npb24gaGFzIHRvIGJlIHByZXByb2Nlc3NlZCB2aWFcbiAqIGBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnNgLlxuICogQHBhcmFtIHs/fSBsb2NhbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGltcGxpY2l0UmVjZWl2ZXJcbiAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGluc1xuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucywgYmluZGluZ0lkKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJZCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdHMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dEV4cHIgPSBleHByZXNzaW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIGlmICh2aXNpdG9yLnRlbXBvcmFyeUNvdW50KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0bXRzLnB1c2godGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RtdHMucHVzaChjdXJyVmFsRXhwci5zZXQob3V0cHV0RXhwcikudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIHJldHVybiBuZXcgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChzdG10cywgY3VyclZhbEV4cHIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbnZlcnRlckZhY3RvcnlcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfQnVpbHRpbkFzdENvbnZlcnRlcihjb252ZXJ0ZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHBhcmFtIHs/fSB0ZW1wb3JhcnlOdW1iZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gXCJ0bXBfXCIgKyBiaW5kaW5nSWQgKyBcIl9cIiArIHRlbXBvcmFyeU51bWJlcjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5TnVtYmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlciksIE5VTExfRVhQUik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5Q291bnRcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQodGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgfVxufVxudmFyIF9Nb2RlID0ge307XG5fTW9kZS5TdGF0ZW1lbnQgPSAwO1xuX01vZGUuRXhwcmVzc2lvbiA9IDE7XG5fTW9kZVtfTW9kZS5TdGF0ZW1lbnRdID0gXCJTdGF0ZW1lbnRcIjtcbl9Nb2RlW19Nb2RlLkV4cHJlc3Npb25dID0gXCJFeHByZXNzaW9uXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KSB7XG4gICAgaWYgKG1vZGUgIT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZGVcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbnZhciBfQnVpbHRpbkFzdENvbnZlcnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9CdWlsdGluQXN0Q29udmVydGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbnZlcnRlckZhY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQnVpbHRpbkFzdENvbnZlcnRlcihfY29udmVydGVyRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29udmVydGVyRmFjdG9yeSA9IF9jb252ZXJ0ZXJGYWN0b3J5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gW2FzdC5leHBdLmNvbmNhdChhc3QuYXJncykubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlUGlwZUNvbnZlcnRlcihhc3QubmFtZSwgYXJncy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBhc3QuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gYXN0LnZhbHVlcy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGFzdC5rZXlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0J1aWx0aW5Bc3RDb252ZXJ0ZXI7XG59KEFzdFRyYW5zZm9ybWVyKSk7XG52YXIgX0FzdFRvSXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9sb2NhbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRSZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0FzdFRvSXJWaXNpdG9yKF9sb2NhbFJlc29sdmVyLCBfaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5fbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1pbnVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRGl2aWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Nb2R1bG87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5BbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5PcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG9wZXJhdGlvbiBcIiArIGFzdC5vcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKG9wLCB0aGlzLnZpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy52aXNpdChhc3QucmlnaHQsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB2YWx1ZS5jb25kaXRpb25hbCh0aGlzLnZpc2l0KGFzdC50cnVlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy52aXNpdChhc3QuZmFsc2VFeHAsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IFBpcGVzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zLiBQaXBlOiBcIiArIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuUmVzdWx0O1xuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQnVpbHRpbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgZm5SZXN1bHQgPSBhc3QuY29udmVydGVyKGNvbnZlcnRlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm5SZXN1bHQgPSB0aGlzLnZpc2l0KGFzdC50YXJnZXQsIF9Nb2RlLkV4cHJlc3Npb24pLmNhbGxGbihjb252ZXJ0ZWRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZm5SZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFtsaXRlcmFsKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGFzdC5zdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbaV0pKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIHJldHVybiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoIDw9IDkgP1xuICAgICAgICAgICAgaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlKSkuY2FsbEZuKGFyZ3MpIDpcbiAgICAgICAgICAgIGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSkpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgYXJnc1swXSwgbGl0ZXJhbEFycihhcmdzLnNsaWNlKDEpKVxuICAgICAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLnZpc2l0KGFzdC5vYmosIF9Nb2RlLkV4cHJlc3Npb24pLmtleSh0aGlzLnZpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBhcnJheXMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IGxpdGVyYWwgbWFwcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9uc1wiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuX2dldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyRXhwcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YXJFeHByLmNhbGxGbihhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jYWxsTWV0aG9kKGFzdC5uYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhckV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyRXhwcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiB0byBhIHJlZmVyZW5jZSBvciB2YXJpYWJsZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVjZWl2ZXIucHJvcChhc3QubmFtZSkuc2V0KHRoaXMudmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIG1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLnZpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVvdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBldmFsdWF0aW9uIVxcbiAgICAgICAgU3RhdGVtZW50OiBcIiArIGFzdC51bmludGVycHJldGVkRXhwcmVzc2lvbiArIFwiIGxvY2F0ZWQgYXQgXCIgKyBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGxlZnRNb3N0U2FmZVxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U2FmZUFjY2VzcyA9IGZ1bmN0aW9uIChhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgIC8vIGV4cHJlc3Npb24gdXAgdG8gdGVzdCBpdCBmb3IgYmxhbmsgYmVmb3JlIGdlbmVyYXRpbmcgdGhlIHVuZ3VhcmRlZCB2ZXJzaW9uLlxuICAgICAgICAvLyBDb25zaWRlciwgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOiBhPy5iLmM/LmQuZVxuICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgLy8gICAgICAgICAuXG4gICAgICAgIC8vICAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAvLyAgICAgIC8gIFxcXG4gICAgICAgIC8vICAgICAuICAgIGRcbiAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAvLyAgID8uICBjXG4gICAgICAgIC8vICAvICBcXFxuICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0cmVlIHNob3VsZCBiZSBnZW5lcmF0ZWQ6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAvLyAgICAgICAvICAgICAgfCAgICAgIFxcXG4gICAgICAgIC8vICAgICBhICAgLy0tLSA/IC0tLVxcICBudWxsXG4gICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAvLyAgICAgICAuICAgICAgLiAgICAgbnVsbFxuICAgICAgICAvLyAgICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgIC8vICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgIGEgICBiICAsICAgZFxuICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgIC4gICBjXG4gICAgICAgIC8vICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgZmlyc3QgZ3VhcmQgY29uZGl0aW9uIGlzIHRoZSBsZWZ0IGhhbmQgb2YgdGhlIGxlZnQgbW9zdCBzYWZlIGFjY2VzcyBub2RlXG4gICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wb3Jhcnk7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzVGVtcG9yYXJ5KGxlZnRNb3N0U2FmZS5yZWNlaXZlcikpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGhhcyBtZXRob2QgY2FsbHMgb3IgcGlwZXMgdGhlbiB3ZSBuZWVkIHRvIHNhdmUgdGhlIHJlc3VsdCBpbnRvIGFcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgdGVtcG9yYXJ5ID0gdGhpcy5hbGxvY2F0ZVRlbXBvcmFyeSgpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIHJlc3VsdCBpbiB0aGUgdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBmdXJ0aGVyIHJlZmVyZW5jZXMgdG8gdGhlIGd1YXJkZWQgZXhwcmVzc2lvbiByZWZlciB0byB0aGUgdGVtcG9yYXJ5IGluc3RlYWQuXG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRNYXAuc2V0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgdGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGFzdCB0byBhbiB1bmd1YXJkZWQgYWNjZXNzIHRvIHRoZSByZWNlaXZlcidzIG1lbWJlci4gVGhlIG1hcCB3aWxsIHN1YnN0aXR1dGVcbiAgICAgICAgLy8gbGVmdE1vc3ROb2RlIHdpdGggaXRzIHVuZ3VhcmRlZCB2ZXJzaW9uIGluIHRoZSBjYWxsIHRvIGB0aGlzLnZpc2l0KClgLlxuICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IE1ldGhvZENhbGwobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUsIGxlZnRNb3N0U2FmZS5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBQcm9wZXJ0eVJlYWQobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjY2VzcyA9IHRoaXMudmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXBwaW5nLiBUaGlzIGlzIG5vdCBzdHJpY3RseSByZXF1aXJlZCBhcyB0aGUgY29udmVydGVyIG9ubHkgdHJhdmVyc2VzIGVhY2ggbm9kZVxuICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgLy8gSWYgd2UgYWxsb2NhdGVkIGEgdGVtcG9yYXJ5LCByZWxlYXNlIGl0LlxuICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubGVmdE1vc3RTYWZlTm9kZSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0OyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLm5lZWRzVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0U29tZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh2aXNpdG9yLCBhc3QpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmxlZnQpIHx8IHZpc2l0KHRoaXMsIGFzdC5yaWdodCk7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdFNvbWUodGhpcywgYXN0LmV4cHJlc3Npb25zKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRTYWZlTWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuYWxsb2NhdGVUZW1wb3JhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBOdW1iZXIgPSB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5Kys7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSBNYXRoLm1heCh0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LCB0aGlzLnRlbXBvcmFyeUNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcih0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0ZW1wTnVtYmVyKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBvcmFyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFyZ1xuICogQHBhcmFtIHs/fSBvdXRwdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAoKGFyZykpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbnZhciBEZWZhdWx0TG9jYWxSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdExvY2FsUmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdExvY2FsUmVzb2x2ZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdExvY2FsUmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJjdXJyVmFsX1wiICsgYmluZGluZ0lkKTsgLy8gZml4IHN5bnRheCBoaWdobGlnaHRpbmc6IGBcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCkge1xuICAgIHJldHVybiB2YXJpYWJsZShcInBkX1wiICsgYmluZGluZ0lkKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdG10XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKHN0bXQpIHtcbiAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gc3RtdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgQnVpbHRpbkZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1aWx0aW5GdW5jdGlvbkNhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluRnVuY3Rpb25DYWxsKHNwYW4sIGFyZ3MsIGNvbnZlcnRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBudWxsLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMuY29udmVydGVyID0gY29udmVydGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdWlsdGluRnVuY3Rpb25DYWxsO1xufShGdW5jdGlvbkNhbGwpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDTEFTU19BVFRSJDEgPSAnY2xhc3MnO1xudmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xudmFyIElNUExJQ0lUX1RFTVBMQVRFX1ZBUiA9ICdcXCRpbXBsaWNpdCc7XG52YXIgTkdfQ09OVEFJTkVSX1RBRyA9ICduZy1jb250YWluZXInO1xudmFyIFZpZXdDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDbGFzc1ZhclxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJUeXBlVmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlld0NsYXNzVmFyLCByZW5kZXJlclR5cGVWYXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy52aWV3Q2xhc3NWYXIgPSB2aWV3Q2xhc3NWYXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlVmFyID0gcmVuZGVyZXJUeXBlVmFyO1xuICAgIH1cbiAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIFZpZXdDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZ2VuQ29uZmlnTmV4dFxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWdOZXh0LCBfc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fZ2VuQ29uZmlnTmV4dCA9IF9nZW5Db25maWdOZXh0O1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IHVzZWRQaXBlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0NvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIHN0eWxlcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtYmVkZGVkVmlld0NvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUXVlcnlJZHMgPSBmaW5kU3RhdGljUXVlcnlJZHModGVtcGxhdGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhck5hbWU7XG4gICAgICAgIGlmICghY29tcG9uZW50LmlzSG9zdCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZS5hbmltYXRpb25zICYmIGNvbXBvbmVudC50ZW1wbGF0ZS5hbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbVJlbmRlckRhdGEucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KCdhbmltYXRpb24nLCBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjb21wb25lbnQudGVtcGxhdGUuYW5pbWF0aW9ucyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhciA9IHZhcmlhYmxlKHJlbmRlcmVyVHlwZU5hbWUoY29tcG9uZW50LnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnRWYXJOYW1lID0gcmVuZGVyQ29tcG9uZW50VmFyLm5hbWU7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyQ29tcG9uZW50VmFyXG4gICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY3JlYXRlUmVuZGVyZXJUeXBlMikpXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbbmV3IExpdGVyYWxNYXBFeHByKFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnZW5jYXBzdWxhdGlvbicsIGxpdGVyYWwoY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24pKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnc3R5bGVzJywgc3R5bGVzKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnZGF0YScsIG5ldyBMaXRlcmFsTWFwRXhwcihjdXN0b21SZW5kZXJEYXRhKSlcbiAgICAgICAgICAgICAgICBdKV0pKVxuICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyKSksIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0J1aWxkZXJGYWN0b3J5ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3QnVpbGRlcihwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSB2aWV3QnVpbGRlckZhY3RvcnkobnVsbCk7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBbGwoW10sIHRlbXBsYXRlKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoLmFwcGx5KHN0YXRlbWVudHMsIHZpc2l0b3IuYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlzaXRvci52aWV3TmFtZSwgcmVuZGVyQ29tcG9uZW50VmFyTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbXBpbGVyO1xufSgpKTtcblZpZXdDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5WaWV3Q29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbl07IH07XG52YXIgTE9HX1ZBUiA9IHZhcmlhYmxlKCdsJyk7XG52YXIgVklFV19WQVIgPSB2YXJpYWJsZSgndicpO1xudmFyIENIRUNLX1ZBUiA9IHZhcmlhYmxlKCdjaycpO1xudmFyIENPTVBfVkFSID0gdmFyaWFibGUoJ2NvJyk7XG52YXIgRVZFTlRfTkFNRV9WQVIgPSB2YXJpYWJsZSgnZW4nKTtcbnZhciBBTExPV19ERUZBVUxUX1ZBUiA9IHZhcmlhYmxlKFwiYWRcIik7XG52YXIgVmlld0J1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IGVtYmVkZGVkVmlld0luZGV4XG4gICAgICogQHBhcmFtIHs/fSB1c2VkUGlwZXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1F1ZXJ5SWRzXG4gICAgICogQHBhcmFtIHs/fSB2aWV3QnVpbGRlckZhY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3QnVpbGRlcihwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdJbmRleDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuc3RhdGljUXVlcnlJZHMgPSBzdGF0aWNRdWVyeUlkcztcbiAgICAgICAgdGhpcy52aWV3QnVpbGRlckZhY3RvcnkgPSB2aWV3QnVpbGRlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wdXJlUGlwZU5vZGVJbmRpY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yZWZOb2RlSW5kaWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gW107XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAvLyBmb3IgdGhlIGNvbnRleHQgaW4gYW55IGVtYmVkZGVkIHZpZXcuIFdlIGtlZXAgdGhpcyBiZWhhaXZvciBmb3Igbm93XG4gICAgICAgIC8vIHRvIGJlIGFibGUgdG8gaW50cm9kdWNlIHRoZSBuZXcgdmlldyBjb21waWxlciB3aXRob3V0IHRvbyBtYW55IGVycm9ycy5cbiAgICAgICAgdGhpcy5jb21wVHlwZSA9IHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPiAwID8gRFlOQU1JQ19UWVBFIDogaW1wb3J0VHlwZSh0aGlzLmNvbXBvbmVudC50eXBlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdCdWlsZGVyLnByb3RvdHlwZSwgXCJ2aWV3TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NsYXNzTmFtZSh0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyaWFibGVzXG4gICAgICogQHBhcmFtIHs/fSBhc3ROb2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgYXN0Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcGlwZXMgZm9yIHRoZSBwdXJlIHBpcGVzIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHdlIGtub3cgdGhlaXIgaW5kaWNlcy5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy51c2VkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVyZVBpcGVOb2RlSW5kaWNlc1twaXBlLm5hbWVdID0gX3RoaXMuX2NyZWF0ZVBpcGUobnVsbCwgcGlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlJZHNfMSA9IHN0YXRpY1ZpZXdRdWVyeUlkcyh0aGlzLnN0YXRpY1F1ZXJ5SWRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5SWQgPSBxdWVyeUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSA2NzEwODg2NCAvKiBUeXBlVmlld1F1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzXzEsIHF1ZXJ5SWQsIHF1ZXJ5LmZpcnN0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5xdWVyeURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRXhwcihbbmV3IExpdGVyYWxNYXBFbnRyeShxdWVyeS5wcm9wZXJ0eU5hbWUsIGxpdGVyYWwoYmluZGluZ1R5cGUpKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAoYXN0Tm9kZXMubGVuZ3RoID09PSAwIHx8IG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGlzIGFuIGVtYmVkZGVkIHZpZXcsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCByb290IG5vZGUgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOb25lICovKSwgTlVMTF9FWFBSLCBOVUxMX0VYUFIsIGxpdGVyYWwoMClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0YXJnZXRTdGF0ZW1lbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZCh0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2NyZWF0ZU5vZGVFeHByZXNzaW9ucygpLCB1cGRhdGVSZW5kZXJlclN0bXRzID0gX2EudXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzID0gX2EudXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnMgPSBfYS5ub2RlRGVmRXhwcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVSZW5kZXJlclN0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlRGlyZWN0aXZlc0ZuID0gdGhpcy5fY3JlYXRlVXBkYXRlRm4odXBkYXRlRGlyZWN0aXZlc1N0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0ZsYWdzID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLmNvbXBvbmVudC5jaGFuZ2VEZXRlY3Rpb24gPT09IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCkge1xuICAgICAgICAgICAgdmlld0ZsYWdzIHw9IDIgLyogT25QdXNoICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodGhpcy52aWV3TmFtZSwgW25ldyBGblBhcmFtKExPR19WQVIubmFtZSldLCBbbmV3IFJldHVyblN0YXRlbWVudChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMudmlld0RlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCh2aWV3RmxhZ3MpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIobm9kZURlZkV4cHJzKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzRm4sXG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJGbixcbiAgICAgICAgICAgIF0pKV0sIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbikpKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVN0bXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVVwZGF0ZUZuID0gZnVuY3Rpb24gKHVwZGF0ZVN0bXRzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUZuO1xuICAgICAgICBpZiAodXBkYXRlU3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaXNIb3N0ICYmIGZpbmRSZWFkVmFyTmFtZXModXBkYXRlU3RtdHMpLmhhcyhDT01QX1ZBUi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUZuID0gZm4oW1xuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKENIRUNLX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KHVwZGF0ZVN0bXRzKSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVGbiA9IE5VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlRm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyBuZ0NvbnRlbnREZWYobmdDb250ZW50SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDQgLyogVHlwZU5nQ29udGVudCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5uZ0NvbnRlbnREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbChhc3QuaW5kZXgpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy50ZXh0RGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksIGxpdGVyYWxBcnIoW2xpdGVyYWwoYXN0LnZhbHVlKV0pXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0V2l0aFNvdXJjZSA9IChhc3QudmFsdWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlciA9IChhc3RXaXRoU291cmNlLmFzdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBpbnRlci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHsgbm9kZUluZGV4OiBub2RlSW5kZXgsIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LCBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbiwgY29udGV4dDogQ09NUF9WQVIsIHZhbHVlOiBleHByIH0pOyB9KTtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnRleHREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbEFycihpbnRlci5zdHJpbmdzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gbGl0ZXJhbChzKTsgfSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyOiB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl92aXNpdEVsZW1lbnRPclRlbXBsYXRlKG5vZGVJbmRleCwgYXN0KSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZFZpc2l0b3IgPSB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkVmlzaXRvcik7XG4gICAgICAgIGNoaWxkVmlzaXRvci52aXNpdEFsbChhc3QudmFyaWFibGVzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZENvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSBub2RlSW5kZXggLSAxO1xuICAgICAgICAvLyBhbmNob3JEZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgbWF0Y2hlZFF1ZXJpZXM6IFtzdHJpbmcsIFF1ZXJ5VmFsdWVUeXBlXVtdLCBuZ0NvbnRlbnRJbmRleDogbnVtYmVyLFxuICAgICAgICAvLyAgIGNoaWxkQ291bnQ6IG51bWJlciwgaGFuZGxlRXZlbnRGbj86IEVsZW1lbnRIYW5kbGVFdmVudEZuLCB0ZW1wbGF0ZUZhY3Rvcnk/OlxuICAgICAgICAvLyAgIFZpZXdEZWZpbml0aW9uRmFjdG9yeSk6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcixcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSxcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZShjaGlsZFZpc2l0b3Iudmlld05hbWUpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgIGlmIChhc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRykge1xuICAgICAgICAgICAgLy8gVXNpbmcgYSBudWxsIGVsZW1lbnQgbmFtZSBjcmVhdGVzIGFuIGFuY2hvci5cbiAgICAgICAgICAgIGVsTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZShub2RlSW5kZXgsIGFzdCksIGZsYWdzID0gX2EuZmxhZ3MsIHVzZWRFdmVudHMgPSBfYS51c2VkRXZlbnRzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICBpZiAoZWxOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBhc3QuaW5wdXRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogLyoqIEB0eXBlIHs/fSAqLyAoQ09NUF9WQVIpLFxuICAgICAgICAgICAgICAgIGlucHV0QXN0OiBpbnB1dEFzdCxcbiAgICAgICAgICAgICAgICBkaXJBc3Q6IG51bGwsXG4gICAgICAgICAgICB9KTsgfSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGRpckhvc3RCaW5kaW5ncyk7XG4gICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPVxuICAgICAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZywgYmluZGluZ0luZGV4KSB7IHJldHVybiBfdGhpcy5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogaG9zdEJpbmRpbmcuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ0luZGV4OiBiaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBob3N0QmluZGluZy5pbnB1dEFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhvc3RCaW5kaW5nLmlucHV0QXN0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMgPSBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZykgeyByZXR1cm4gZWxlbWVudEJpbmRpbmdEZWYoaG9zdEJpbmRpbmcuaW5wdXRBc3QsIGhvc3RCaW5kaW5nLmRpckFzdCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0RGVmcyA9IHVzZWRFdmVudHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwodGFyZ2V0KSwgbGl0ZXJhbChldmVudE5hbWUpXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBBc3QgPSBhc3QuZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJBc3QpIHsgcmV0dXJuIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wUmVuZGVyZXJUeXBlID0gTlVMTF9FWFBSO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wVmlldyA9IE5VTExfRVhQUjtcbiAgICAgICAgaWYgKGNvbXBBc3QpIHtcbiAgICAgICAgICAgIGNvbXBWaWV3ID0gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogY29tcEFzdC5kaXJlY3RpdmUuY29tcG9uZW50Vmlld1R5cGUgfSk7XG4gICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlID0gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogY29tcEFzdC5kaXJlY3RpdmUucmVuZGVyZXJUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsZW1lbnREZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgbWF0Y2hlZFF1ZXJpZXNEc2w6IFtzdHJpbmcgfCBudW1iZXIsIFF1ZXJ5VmFsdWVUeXBlXVtdLFxuICAgICAgICAvLyAgIG5nQ29udGVudEluZGV4OiBudW1iZXIsIGNoaWxkQ291bnQ6IG51bWJlciwgbmFtZXNwYWNlQW5kTmFtZTogc3RyaW5nLFxuICAgICAgICAvLyAgIGZpeGVkQXR0cnM6IFtzdHJpbmcsIHN0cmluZ11bXSA9IFtdLFxuICAgICAgICAvLyAgIGJpbmRpbmdzPzogW0JpbmRpbmdGbGFncywgc3RyaW5nLCBzdHJpbmcgfCBTZWN1cml0eUNvbnRleHRdW10sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IChbT3V0cHV0VHlwZS5FbGVtZW50T3V0cHV0IHwgT3V0cHV0VHlwZS5EaXJlY3RpdmVIb3N0T3V0cHV0LCBzdHJpbmcsIHN0cmluZ10pW10sXG4gICAgICAgIC8vICAgaGFuZGxlRXZlbnQ/OiBFbGVtZW50SGFuZGxlRXZlbnRGbixcbiAgICAgICAgLy8gICBjb21wb25lbnRWaWV3PzogKCkgPT4gVmlld0RlZmluaXRpb24sIGNvbXBvbmVudFJlbmRlcmVyVHlwZT86IFJlbmRlcmVyVHlwZTIpOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5lbGVtZW50RGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSxcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoZXNFeHByLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoaWxkQ291bnQpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoZWxOYW1lKSxcbiAgICAgICAgICAgICAgICBlbE5hbWUgPyBmaXhlZEF0dHJzRGVmKGFzdCkgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgaW5wdXREZWZzLmxlbmd0aCA/IGxpdGVyYWxBcnIoaW5wdXREZWZzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBvdXRwdXREZWZzLmxlbmd0aCA/IGxpdGVyYWxBcnIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUVsZW1lbnRIYW5kbGVFdmVudEZuKG5vZGVJbmRleCwgaG9zdEV2ZW50cyksXG4gICAgICAgICAgICAgICAgY29tcFZpZXcsXG4gICAgICAgICAgICAgICAgY29tcFJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXI6IHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnNcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUgPSBmdW5jdGlvbiAobm9kZUluZGV4LCBhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgICAgICBpZiAoYXN0Lmhhc1ZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDgzODg2MDggLyogRW1iZWRkZWRWaWV3cyAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VkRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudCwgbnVsbCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICB1c2VkRXZlbnRzLnNldCjJtWVsZW1lbnRFdmVudEZ1bGxOYW1lKHRhcmdldCwgbmFtZSksIFt0YXJnZXQsIG5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICAgICAgZGlyQXN0Lmhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50LCBkaXJBc3QpLCBuYW1lID0gX2EubmFtZSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHVzZWRFdmVudHMuc2V0KMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlciA9IGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihhc3QuZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRQcm92aWRlcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlciwgYXN0LnF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyQXN0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlySW5kZXg7XG4gICAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbERpckFzdCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbERpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyQXN0LnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJBc3QgPSBsb2NhbERpckFzdDtcbiAgICAgICAgICAgICAgICAgICAgZGlySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRpckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLl92aXNpdERpcmVjdGl2ZShwcm92aWRlckFzdCwgZGlyQXN0LCBkaXJJbmRleCwgbm9kZUluZGV4LCBhc3QucmVmZXJlbmNlcywgYXN0LnF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgX3RoaXMuc3RhdGljUXVlcnlJZHMuZ2V0KC8qKiBAdHlwZSB7P30gKi8gKGFzdCkpKSwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBkaXJIb3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MucHVzaC5hcHBseShob3N0QmluZGluZ3MsIGRpckhvc3RCaW5kaW5ncyk7XG4gICAgICAgICAgICAgICAgaG9zdEV2ZW50cy5wdXNoLmFwcGx5KGhvc3RFdmVudHMsIGRpckhvc3RFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Zpc2l0UHJvdmlkZXIocHJvdmlkZXJBc3QsIGFzdC5xdWVyeU1hdGNoZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlNYXRjaEV4cHJzID0gW107XG4gICAgICAgIGFzdC5xdWVyeU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlVHlwZTtcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBFbGVtZW50UmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDMgLyogVmlld0NvbnRhaW5lclJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMiAvKiBUZW1wbGF0ZVJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwobWF0Y2gucXVlcnlJZCksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVUeXBlO1xuICAgICAgICAgICAgaWYgKCFyZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAxIC8qIFJlbmRlckVsZW1lbnQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShyZWYudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAyIC8qIFRlbXBsYXRlUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKHZhbHVlVHlwZSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHtcbiAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaCh7IGNvbnRleHQ6IENPTVBfVkFSLCBldmVudEFzdDogb3V0cHV0QXN0LCBkaXJBc3Q6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgdXNlZEV2ZW50czogQXJyYXkuZnJvbSh1c2VkRXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHI6IHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncyxcbiAgICAgICAgICAgIGhvc3RFdmVudHM6IGhvc3RFdmVudHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJBc3RcbiAgICAgKiBAcGFyYW0gez99IGRpckFzdFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROb2RlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHJlZnNcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5TWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7P30gdXNlZEV2ZW50c1xuICAgICAqIEBwYXJhbSB7P30gcXVlcnlJZHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJBc3QsIGRpckFzdCwgZGlyZWN0aXZlSW5kZXgsIGVsZW1lbnROb2RlSW5kZXgsIHJlZnMsIHF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgcXVlcnlJZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgZGlyQXN0LmRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeUlkID0gZGlyQXN0LmNvbnRlbnRRdWVyeVN0YXJ0SWQgKyBxdWVyeUluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAzMzU1NDQzMiAvKiBUeXBlQ29udGVudFF1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzLCBxdWVyeUlkLCBxdWVyeS5maXJzdCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgbm9kZUZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucXVlcnlEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKFtuZXcgTGl0ZXJhbE1hcEVudHJ5KHF1ZXJ5LnByb3BlcnR5TmFtZSwgbGl0ZXJhbChiaW5kaW5nVHlwZSkpXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBvcGVyYXRpb24gYmVsb3cgbWlnaHQgYWxzbyBjcmVhdGUgbmV3IG5vZGVEZWZzLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGJlIGEgY2hpbGQgb2YgYSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIGFzIHRoZXkgbWlnaHQgYmUgYSBwcm92aWRlci9waXBlIG9uIHRoZWlyIG93bi5cbiAgICAgICAgLy8gSS5lLiB3ZSBvbmx5IGFsbG93IHF1ZXJpZXMgYXMgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcyBub2Rlcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoRXhwcnMgPSBfYS5xdWVyeU1hdGNoRXhwcnMsIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgdG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2Mzg0IC8qIENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dERlZnMgPSBkaXJBc3QuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QsIGlucHV0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFZhbHVlID0gbGl0ZXJhbEFycihbbGl0ZXJhbChpbnB1dEluZGV4KSwgbGl0ZXJhbChpbnB1dEFzdC5kaXJlY3RpdmVOYW1lKV0pO1xuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8gbm90IHF1b3RlIHRoZSBrZXkgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSByZW5hbWVzIGJ5IG1pbmlmaWVycyFcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUsIG1hcFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBkaXJBc3QuZGlyZWN0aXZlO1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHVzZWRFdmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKGV2ZW50TmFtZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyQXN0LmlucHV0cy5sZW5ndGggfHwgKGZsYWdzICYgKDEzMTA3MiAvKiBEb0NoZWNrICovIHwgMzI3NjggLyogT25Jbml0ICovKSkgPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogQ09NUF9WQVIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJDb250ZXh0RXhwciA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5ub2RlVmFsdWUpKS5jYWxsRm4oW1xuICAgICAgICAgICAgVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gZGlyQXN0Lmhvc3RQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGRpckFzdDogZGlyQXN0LFxuICAgICAgICAgICAgaW5wdXRBc3Q6IGlucHV0QXN0LFxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSBkaXJBc3QuaG9zdEV2ZW50cy5tYXAoZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZXZlbnRBc3Q6IGhvc3RFdmVudEFzdCwgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gZGlyZWN0aXZlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgY2hpbGRDb3VudDogbnVtYmVyLCBjdG9yOlxuICAgICAgICAvLyAgIGFueSxcbiAgICAgICAgLy8gICBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdLCBwcm9wcz86IHtbbmFtZTogc3RyaW5nXTogW251bWJlciwgc3RyaW5nXX0sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSwgY29tcG9uZW50PzogKCkgPT4gVmlld0RlZmluaXRpb24pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDgxOTIgLyogVHlwZURpcmVjdGl2ZSAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmRpcmVjdGl2ZURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSwgcHJvdmlkZXJFeHByLCBkZXBzRXhwcixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKGlucHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5sZW5ndGggPyBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFJcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlRGlyZWN0aXZlczogdXBkYXRlRGlyZWN0aXZlRXhwcmVzc2lvbnMsXG4gICAgICAgICAgICBkaXJlY3RpdmU6IGRpckFzdC5kaXJlY3RpdmUudHlwZSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiB7IGhvc3RCaW5kaW5nczogaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzOiBob3N0RXZlbnRzIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXkgc28gd2UgY2FuIGFkZCBjaGlsZHJlblxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZShwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaEV4cHJzID0gX2EucXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgICAgIC8vIHByb3ZpZGVyRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgdG9rZW46YW55LFxuICAgICAgICAvLyAgIHZhbHVlOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogcHJvdmlkZXJBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHJvdmlkZXJEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBxdWVyeU1hdGNoRXhwcnMubGVuZ3RoID8gbGl0ZXJhbEFycihxdWVyeU1hdGNoRXhwcnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIHRva2VuRXhwcihwcm92aWRlckFzdC50b2tlbiksIHByb3ZpZGVyRXhwciwgZGVwc0V4cHJcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZSA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAgICAgaWYgKCFwcm92aWRlckFzdC5lYWdlcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMjA0OCAvKiBMYXp5UHJvdmlkZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSA0MDk2IC8qIFByaXZhdGVQcm92aWRlciAqLztcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlckFzdC5saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgICAgICAvLyBmb3IgcmVndWxhciBwcm92aWRlcnMsIHdlIG9ubHkgc3VwcG9ydCBuZ09uRGVzdHJveVxuICAgICAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2sgPT09IMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95IHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgcXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKG1hdGNoLnF1ZXJ5SWQpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gcHJvdmlkZXJEZWYocHJvdmlkZXJBc3QpLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHIsIHByb3ZpZGVyVHlwZSA9IF9hLmZsYWdzO1xuICAgICAgICByZXR1cm4geyBmbGFnczogZmxhZ3MgfCBwcm92aWRlclR5cGUsIHF1ZXJ5TWF0Y2hFeHByczogcXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwciwgZGVwc0V4cHI6IGRlcHNFeHByIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckJ1aWxkZXIgPSB0aGlzOyBjdXJyQnVpbGRlcjsgY3VyckJ1aWxkZXIgPSBjdXJyQnVpbGRlci5wYXJlbnQsXG4gICAgICAgICAgICBjdXJyVmlld0V4cHIgPSBjdXJyVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayByZWZlcmVuY2VzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWZOb2RlSW5kZXggPSBjdXJyQnVpbGRlci5yZWZOb2RlSW5kaWNlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMubm9kZVZhbHVlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgY3VyclZpZXdFeHByLCBsaXRlcmFsKHJlZk5vZGVJbmRleClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHZhcmlhYmxlc1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyQXN0ID0gY3VyckJ1aWxkZXIudmFyaWFibGVzLmZpbmQoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICAgICAgaWYgKHZhckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhclZhbHVlID0gdmFyQXN0LnZhbHVlIHx8IElNUExJQ0lUX1RFTVBMQVRFX1ZBUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclZpZXdFeHByLnByb3AoJ2NvbnRleHQnKS5wcm9wKHZhclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gYXJnQ291bnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgYXJnQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8xOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBwdXJlQXJyYXlEZWYoYXJnQ291bnQ6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMTYgLyogVHlwZVB1cmVBcnJheSAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5wdXJlQXJyYXlEZWYpKS5jYWxsRm4oW2xpdGVyYWwoYXJnQ291bnQpXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBhcmdzKTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3Bhbiwga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlRXhwcl8yID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX01BUCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8yOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBmdW5jdGlvbiBwdXJlT2JqZWN0RGVmKHByb3BlcnR5TmFtZXM6IHN0cmluZ1tdKTogTm9kZURlZlxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDMyIC8qIFR5cGVQdXJlT2JqZWN0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnB1cmVPYmplY3REZWYpKVxuICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWxBcnIoa2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbGl0ZXJhbChrZXkpOyB9KSldKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGFyZ3MpOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdDb3VudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVBpcGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgbmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZSA9IHRoaXMudXNlZFBpcGVzLmZpbmQoZnVuY3Rpb24gKHBpcGVTdW1tYXJ5KSB7IHJldHVybiBwaXBlU3VtbWFyeS5uYW1lID09PSBuYW1lOyB9KTtcbiAgICAgICAgaWYgKHBpcGUucHVyZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4XzEgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHB1cmVQaXBlRGVmKGFyZ0NvdW50OiBudW1iZXIpOiBOb2RlRGVmO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogZXhwcmVzc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgIG5vZGVGbGFnczogNjQgLyogVHlwZVB1cmVQaXBlICovLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5wdXJlUGlwZURlZikpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWwoYXJnQ291bnQpXSlcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgIC8vIGZpbmQgdW5kZXJseWluZyBwaXBlIGluIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wQnVpbGRlciA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoY29tcEJ1aWxkZXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcEJ1aWxkZXIgPSBjb21wQnVpbGRlci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29tcFZpZXdFeHByID0gY29tcFZpZXdFeHByLnByb3AoJ3BhcmVudCcpLmNhc3QoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVOb2RlSW5kZXggPSBjb21wQnVpbGRlci5wdXJlUGlwZU5vZGVJbmRpY2VzW25hbWVdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZVZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgY29tcFZpZXdFeHByLCBsaXRlcmFsKHBpcGVOb2RlSW5kZXgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgY2FsbENoZWNrU3RtdChub2RlSW5kZXhfMSwgW3BpcGVWYWx1ZUV4cHJfMV0uY29uY2F0KGFyZ3MpKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLl9jcmVhdGVQaXBlKGV4cHJlc3Npb24uc291cmNlU3BhbiwgcGlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlVmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMubm9kZVZhbHVlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgbm9kZVZhbHVlRXhwcl8xLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpKTsgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBwaXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVBpcGUgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgcGlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgICAgICBwaXBlLnR5cGUubGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICAgICAgLy8gZm9yIHBpcGVzLCB3ZSBvbmx5IHN1cHBvcnQgbmdPbkRlc3Ryb3lcbiAgICAgICAgICAgIGlmIChsaWZlY3ljbGVIb29rID09PSDJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBwaXBlLnR5cGUuZGlEZXBzLm1hcChkZXBEZWYpO1xuICAgICAgICAvLyBmdW5jdGlvbiBwaXBlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIGN0b3I6IGFueSwgZGVwczogKFtEZXBGbGFncywgYW55XSB8IGFueSlbXSk6IE5vZGVEZWZcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiA4IC8qIFR5cGVQaXBlICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnBpcGVEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBpbXBvcnRFeHByKHBpcGUudHlwZSksIGxpdGVyYWxBcnIoZGVwRXhwcnMpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlSW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZUluZGV4OiBleHByZXNzaW9uLm5vZGVJbmRleCxcbiAgICAgICAgICAgIGJpbmRpbmdJbmRleDogZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBleHByZXNzaW9uLnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBjb250ZXh0OiBleHByZXNzaW9uLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKHtcbiAgICAgICAgICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IGZ1bmN0aW9uIChhcmdDb3VudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3BhbiwgYXJnQ291bnQpOyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7IHJldHVybiBfdGhpcy5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3Bhbiwga2V5cyk7IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ0NvdW50KSB7IHJldHVybiBfdGhpcy5jcmVhdGVQaXBlQ29udmVydGVyKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KTsgfVxuICAgICAgICAgICAgfSwgZXhwcmVzc2lvbi52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVOb2RlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVCaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVSZW5kZXJlclN0bXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZURpcmVjdGl2ZXNTdG10cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlRGVmRXhwcnMgPSB0aGlzLm5vZGVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBmYWN0b3J5KCksIG5vZGVEZWYgPSBfYS5ub2RlRGVmLCBub2RlRmxhZ3MgPSBfYS5ub2RlRmxhZ3MsIHVwZGF0ZURpcmVjdGl2ZXMgPSBfYS51cGRhdGVEaXJlY3RpdmVzLCB1cGRhdGVSZW5kZXJlciA9IF9hLnVwZGF0ZVJlbmRlcmVyLCBzb3VyY2VTcGFuID0gX2Euc291cmNlU3BhbjtcbiAgICAgICAgICAgIGlmICh1cGRhdGVSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyU3RtdHMucHVzaC5hcHBseSh1cGRhdGVSZW5kZXJlclN0bXRzLCBjcmVhdGVVcGRhdGVTdGF0ZW1lbnRzKG5vZGVJbmRleCwgc291cmNlU3BhbiwgdXBkYXRlUmVuZGVyZXIsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZURpcmVjdGl2ZXNTdG10cywgY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZURpcmVjdGl2ZXMsIChub2RlRmxhZ3MgJiAoMTMxMDcyIC8qIERvQ2hlY2sgKi8gfCAzMjc2OCAvKiBPbkluaXQgKi8pKSA+IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHVzZSBhIGNvbW1hIGV4cHJlc3Npb24gdG8gY2FsbCB0aGUgbG9nIGZ1bmN0aW9uIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIG5vZGVEZWYgZnVuY3Rpb24sIGJ1dCBzdGlsbCB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgbm9kZURlZiBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYXMgdGhlIHZhbHVlLlxuICAgICAgICAgICAgLy8gTm90ZTogV2Ugb25seSBhZGQgdGhlIGxvZ2dlciB0byBlbGVtZW50cyAvIHRleHQgbm9kZXMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBnZW5lcmF0ZSB0b28gbXVjaCBjb2RlLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9nV2l0aE5vZGVEZWYgPSBub2RlRmxhZ3MgJiAzIC8qIENhdFJlbmRlck5vZGUgKi8gP1xuICAgICAgICAgICAgICAgIG5ldyBDb21tYUV4cHIoW0xPR19WQVIuY2FsbEZuKFtdKS5jYWxsRm4oW10pLCBub2RlRGVmXSkgOlxuICAgICAgICAgICAgICAgIG5vZGVEZWY7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQobG9nV2l0aE5vZGVEZWYsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgdXBkYXRlUmVuZGVyZXJTdG10czogdXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzOiB1cGRhdGVEaXJlY3RpdmVzU3RtdHMsIG5vZGVEZWZFeHByczogbm9kZURlZkV4cHJzIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFsbG93RW1wdHlFeHByc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zLCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW4sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdJZCA9IFwiXCIgKyB1cGRhdGVCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IHNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCB2YWx1ZSwgYmluZGluZ0lkKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCBzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoY3VyclZhbEV4cHIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoIHx8IGFsbG93RW1wdHlFeHBycykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChjYWxsQ2hlY2tTdG10KG5vZGVJbmRleCwgZXhwcnMpLnRvU3RtdCgpLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3RtdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICogQHBhcmFtIHs/fSBoYW5kbGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbiA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbmRsZUV2ZW50U3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfYS5jb250ZXh0LCBldmVudEFzdCA9IF9hLmV2ZW50QXN0LCBkaXJBc3QgPSBfYS5kaXJBc3Q7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nSWQgPSBcIlwiICsgaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IENPTVBfVkFSID8gX3RoaXMgOiBudWxsO1xuICAgICAgICAgICAgdmFyIF9iID0gY29udmVydEFjdGlvbkJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCBldmVudEFzdC5oYW5kbGVyLCBiaW5kaW5nSWQpLCBzdG10cyA9IF9iLnN0bXRzLCBhbGxvd0RlZmF1bHQgPSBfYi5hbGxvd0RlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cnVlU3RtdHMgPSBzdG10cztcbiAgICAgICAgICAgIGlmIChhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0cnVlU3RtdHMucHVzaChBTExPV19ERUZBVUxUX1ZBUi5zZXQoYWxsb3dEZWZhdWx0LmFuZChBTExPV19ERUZBVUxUX1ZBUikpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYyA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnRBc3QsIGRpckFzdCksIGV2ZW50VGFyZ2V0ID0gX2MudGFyZ2V0LCBldmVudE5hbWUgPSBfYy5uYW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbEV2ZW50TmFtZSA9IMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChuZXcgSWZTdG10KGxpdGVyYWwoZnVsbEV2ZW50TmFtZSkuaWRlbnRpY2FsKEVWRU5UX05BTUVfVkFSKSwgdHJ1ZVN0bXRzKSwgZXZlbnRBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRGbjtcbiAgICAgICAgaWYgKGhhbmRsZUV2ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbQUxMT1dfREVGQVVMVF9WQVIuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvRGVjbFN0bXQoQk9PTF9UWVBFKV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmlzSG9zdCAmJiBmaW5kUmVhZFZhck5hbWVzKGhhbmRsZUV2ZW50U3RtdHMpLmhhcyhDT01QX1ZBUi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oVklFV19WQVIubmFtZSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oRVZFTlRfTkFNRV9WQVIubmFtZSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KGhhbmRsZUV2ZW50U3RtdHMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KEFMTE9XX0RFRkFVTFRfVkFSKV0pLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBOVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV2ZW50Rm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gVmlld0J1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm92aWRlckRlZihwcm92aWRlckFzdCkge1xuICAgIHJldHVybiBwcm92aWRlckFzdC5tdWx0aVByb3ZpZGVyID9cbiAgICAgICAgbXVsdGlQcm92aWRlckRlZihwcm92aWRlckFzdC5wcm92aWRlcnMpIDpcbiAgICAgICAgc2luZ2xlUHJvdmlkZXJEZWYocHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlLCBwcm92aWRlckFzdC5wcm92aWRlcnNbMF0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbXVsdGlQcm92aWRlckRlZihwcm92aWRlcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxEZXBEZWZzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGFyYW1zID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcnMgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcEV4cHJzID0gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHMpO1xuICAgICAgICAgICAgZXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBFeHBycyA9IGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHMpO1xuICAgICAgICAgICAgZXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBbeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfV0pO1xuICAgICAgICAgICAgZXhwciA9IGRlcEV4cHJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHByb3ZpZGVyLnVzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckV4cHIgPSBmbihhbGxQYXJhbXMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIoZXhwcnMpKV0sIElORkVSUkVEX1RZUEUpO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogNTEyIC8qIFR5cGVGYWN0b3J5UHJvdmlkZXIgKi8sIGRlcHNFeHByOiBsaXRlcmFsQXJyKGFsbERlcERlZnMpIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckluZGV4XG4gICAgICogQHBhcmFtIHs/fSBkZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBkZXBzKSB7XG4gICAgICAgIHJldHVybiBkZXBzLm1hcChmdW5jdGlvbiAoZGVwLCBkZXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1OYW1lID0gXCJwXCIgKyBwcm92aWRlckluZGV4ICsgXCJfXCIgKyBkZXBJbmRleDtcbiAgICAgICAgICAgIGFsbFBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHBhcmFtTmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICBhbGxEZXBEZWZzLnB1c2goZGVwRGVmKGRlcCkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlKHBhcmFtTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJNZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaW5nbGVQcm92aWRlckRlZihwcm92aWRlclR5cGUsIHByb3ZpZGVyTWV0YSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyRXhwcjtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzO1xuICAgIGlmIChwcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgfHwgcHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgIHByb3ZpZGVyRXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUNsYXNzKTtcbiAgICAgICAgZmxhZ3MgPSA4MTkyIC8qIFR5cGVEaXJlY3RpdmUgKi87XG4gICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlQ2xhc3MuZGlEZXBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS51c2VDbGFzcykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gaW1wb3J0RXhwcihwcm92aWRlck1ldGEudXNlQ2xhc3MpO1xuICAgICAgICAgICAgZmxhZ3MgPSAyNTYgLyogVHlwZUNsYXNzUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gaW1wb3J0RXhwcihwcm92aWRlck1ldGEudXNlRmFjdG9yeSk7XG4gICAgICAgICAgICBmbGFncyA9IDUxMiAvKiBUeXBlRmFjdG9yeVByb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IHByb3ZpZGVyTWV0YS5kZXBzIHx8IHByb3ZpZGVyTWV0YS51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyRXhwciA9IE5VTExfRVhQUjtcbiAgICAgICAgICAgIGZsYWdzID0gMTAyNCAvKiBUeXBlVXNlRXhpc3RpbmdQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBbeyB0b2tlbjogcHJvdmlkZXJNZXRhLnVzZUV4aXN0aW5nIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXJNZXRhLnVzZVZhbHVlKTtcbiAgICAgICAgICAgIGZsYWdzID0gMTI4IC8qIFR5cGVWYWx1ZVByb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNFeHByID0gbGl0ZXJhbEFycihkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXBEZWYoZGVwKTsgfSkpO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogZmxhZ3MsIGRlcHNFeHByOiBkZXBzRXhwciB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHRva2VuTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5FeHByKHRva2VuTWV0YSkge1xuICAgIHJldHVybiB0b2tlbk1ldGEuaWRlbnRpZmllciA/IGltcG9ydEV4cHIodG9rZW5NZXRhLmlkZW50aWZpZXIpIDogbGl0ZXJhbCh0b2tlbk1ldGEudmFsdWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRlcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVwRGVmKGRlcCkge1xuICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgZmllbGRzIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgb3V0IGJ5IHByb3ZpZGVyX2FuYWx5emVyOlxuICAgIC8vIC0gaXNBdHRyaWJ1dGUsIGlzU2VsZiwgaXNIb3N0XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IGRlcC5pc1ZhbHVlID8gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoZGVwLnZhbHVlKSA6IHRva2VuRXhwcihkZXAudG9rZW4pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICBpZiAoZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgZmxhZ3MgfD0gMSAvKiBTa2lwU2VsZiAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgIGZsYWdzIHw9IDIgLyogT3B0aW9uYWwgKi87XG4gICAgfVxuICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICBmbGFncyB8PSA4IC8qIFZhbHVlICovO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3MgPT09IDAgLyogTm9uZSAqLyA/IGV4cHIgOiBsaXRlcmFsQXJyKFtsaXRlcmFsKGZsYWdzKSwgZXhwcl0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdE5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShhc3ROb2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RBc3ROb2RlID0gYXN0Tm9kZXNbYXN0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRWxlbWVudEFzdCkge1xuICAgICAgICBpZiAobGFzdEFzdE5vZGUubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRyAmJiBsYXN0QXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShsYXN0QXN0Tm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RBc3ROb2RlLmhhc1ZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBsYXN0QXN0Tm9kZSBpbnN0YW5jZW9mIE5nQ29udGVudEFzdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBsaWZlY3ljbGVIb29rXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUZsYWcgPSAwO1xuICAgIHN3aXRjaCAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMTA0ODU3NiAvKiBBZnRlckNvbnRlbnRDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA1MjQyODggLyogQWZ0ZXJDb250ZW50SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gNDE5NDMwNCAvKiBBZnRlclZpZXdDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSAyMDk3MTUyIC8qIEFmdGVyVmlld0luaXQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDEzMTA3MiAvKiBEb0NoZWNrICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDI2MjE0NCAvKiBPbkNoYW5nZXMgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gNjU1MzYgLyogT25EZXN0cm95ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDMyNzY4IC8qIE9uSW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUZsYWc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRBc3RcbiAqIEBwYXJhbSB7P30gZGlyQXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbGVtZW50QmluZGluZ0RlZihpbnB1dEFzdCwgZGlyQXN0KSB7XG4gICAgc3dpdGNoIChpbnB1dEFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCgxIC8qIFR5cGVFbGVtZW50QXR0cmlidXRlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCg4IC8qIFR5cGVQcm9wZXJ0eSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjpcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdUeXBlID0gOCAvKiBUeXBlUHJvcGVydHkgKi8gfFxuICAgICAgICAgICAgICAgIChkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/IDMyIC8qIFN5bnRoZXRpY0hvc3RQcm9wZXJ0eSAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDE2IC8qIFN5bnRoZXRpY1Byb3BlcnR5ICovKTtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGJpbmRpbmdUeXBlKSwgbGl0ZXJhbCgnQCcgKyBpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwoMiAvKiBUeXBlRWxlbWVudENsYXNzICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgTlVMTF9FWFBSXSk7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDQgLyogVHlwZUVsZW1lbnRTdHlsZSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksIGxpdGVyYWwoaW5wdXRBc3QudW5pdClcbiAgICAgICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50QXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaXhlZEF0dHJzRGVmKGVsZW1lbnRBc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBSZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGVsZW1lbnRBc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyBtYXBSZXN1bHRbYXR0ckFzdC5uYW1lXSA9IGF0dHJBc3QudmFsdWU7IH0pO1xuICAgIGVsZW1lbnRBc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJBc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGlyQXN0LmRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBkaXJBc3QuZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldlZhbHVlID0gbWFwUmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgbWFwUmVzdWx0W25hbWVdID0gcHJldlZhbHVlICE9IG51bGwgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcEVudHJpZXMgPSBbXTtcbiAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIHNvcnQgdG8gZ2V0IGEgZGVmaW5lZCBvdXRwdXQgb3JkZXJcbiAgICAvLyBmb3IgdGVzdHMgYW5kIGZvciBjYWNoaW5nIGdlbmVyYXRlZCBhcnRpZmFjdHMuLi5cbiAgICByZXR1cm4gbGl0ZXJhbEFycihPYmplY3Qua2V5cyhtYXBSZXN1bHQpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGF0dHJOYW1lKSB7IHJldHVybiBsaXRlcmFsQXJyKFtsaXRlcmFsKGF0dHJOYW1lKSwgbGl0ZXJhbChtYXBSZXN1bHRbYXR0ck5hbWVdKV0pOyB9KSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYXR0ck5hbWVcbiAqIEBwYXJhbSB7P30gYXR0clZhbHVlMVxuICogQHBhcmFtIHs/fSBhdHRyVmFsdWUyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZVZhbHVlKGF0dHJOYW1lLCBhdHRyVmFsdWUxLCBhdHRyVmFsdWUyKSB7XG4gICAgaWYgKGF0dHJOYW1lID09IENMQVNTX0FUVFIkMSB8fCBhdHRyTmFtZSA9PSBTVFlMRV9BVFRSKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUxICsgXCIgXCIgKyBhdHRyVmFsdWUyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICogQHBhcmFtIHs/fSBleHByc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGV4cHJzKSB7XG4gICAgaWYgKGV4cHJzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBDSEVDS19WQVIuY2FsbEZuKFtWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKDEgLyogRHluYW1pYyAqLyksIGxpdGVyYWxBcnIoZXhwcnMpXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQ0hFQ0tfVkFSLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KSwgbGl0ZXJhbCgwIC8qIElubGluZSAqLyldLmNvbmNhdChleHBycykpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkeFxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjYWxsVW53cmFwVmFsdWUobm9kZUluZGV4LCBiaW5kaW5nSWR4LCBleHByKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy51bndyYXBWYWx1ZSkpLmNhbGxGbihbXG4gICAgICAgIFZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoYmluZGluZ0lkeCksIGV4cHJcbiAgICBdKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHBhcmFtIHs/PX0gcmVzdWx0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5kU3RhdGljUXVlcnlJZHMobm9kZXMsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBuZXcgTWFwKCk7IH1cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkeW5hbWljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50QXN0KSB7XG4gICAgICAgICAgICBmaW5kU3RhdGljUXVlcnlJZHMobm9kZS5jaGlsZHJlbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZERhdGEgPSByZXN1bHQuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3RhdGljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICAgICAgZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGUuY2hpbGRyZW4sIHJlc3VsdCk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGREYXRhID0gcmVzdWx0LmdldChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGREYXRhLnN0YXRpY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5keW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcyA9IG5vZGUucXVlcnlNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKG1hdGNoLnF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBkeW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuZGVsZXRlKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgcmVzdWx0LnNldChub2RlLCB7IHN0YXRpY1F1ZXJ5SWRzOiBzdGF0aWNRdWVyeUlkcywgZHluYW1pY1F1ZXJ5SWRzOiBkeW5hbWljUXVlcnlJZHMgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlU3RhdGljUXVlcnlJZHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0YXRpY1ZpZXdRdWVyeUlkcyhub2RlU3RhdGljUXVlcnlJZHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkeW5hbWljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgQXJyYXkuZnJvbShub2RlU3RhdGljUXVlcnlJZHMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnN0YXRpY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgIGVudHJ5LmR5bmFtaWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICB9KTtcbiAgICBkeW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuZGVsZXRlKHF1ZXJ5SWQpOyB9KTtcbiAgICByZXR1cm4geyBzdGF0aWNRdWVyeUlkczogc3RhdGljUXVlcnlJZHMsIGR5bmFtaWNRdWVyeUlkczogZHluYW1pY1F1ZXJ5SWRzIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnREaXJNZXRhID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJBc3QpIHsgcmV0dXJuIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgIGlmIChjb21wb25lbnREaXJNZXRhICYmIGNvbXBvbmVudERpck1ldGEuZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnREaXJNZXRhLmRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkgeyByZXR1cm4gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogZW50cnlDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeSB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gY3JlYXRlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YSA9IHtcbiAgICAgICAgICAgIGRpRGVwczogW1xuICAgICAgICAgICAgICAgIHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IGxpdGVyYWxBcnIoZW50cnlDb21wb25lbnRGYWN0b3JpZXMpIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogdG9rZW4sIGlzU2tpcFNlbGY6IHRydWUsIGlzT3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYpIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IFtdLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyQXN0KHRva2VuLCBmYWxzZSwgdHJ1ZSwgW3sgdG9rZW46IHRva2VuLCBtdWx0aTogZmFsc2UsIHVzZUNsYXNzOiBjbGFzc01ldGEgfV0sIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgW10sIGNvbXBvbmVudERpck1ldGEuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50QXN0XG4gKiBAcGFyYW0gez99IGRpckFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudEFzdCwgZGlyQXN0KSB7XG4gICAgaWYgKGV2ZW50QXN0LmlzQW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBcIkBcIiArIGV2ZW50QXN0Lm5hbWUgKyBcIi5cIiArIGV2ZW50QXN0LnBoYXNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/ICdjb21wb25lbnQnIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXN0O1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBxdWVyeUlkc1xuICogQHBhcmFtIHs/fSBxdWVyeUlkXG4gKiBAcGFyYW0gez99IGlzRmlyc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeUlkcywgcXVlcnlJZCwgaXNGaXJzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAvLyBOb3RlOiBXZSBvbmx5IG1ha2UgcXVlcmllcyBzdGF0aWMgdGhhdCBxdWVyeSBmb3IgYSBzaW5nbGUgaXRlbS5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkIHZpZXcgY29tcGlsZXIuLi5cbiAgICBpZiAoaXNGaXJzdCAmJiAocXVlcnlJZHMuc3RhdGljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpIHx8ICFxdWVyeUlkcy5keW5hbWljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpKSkge1xuICAgICAgICBmbGFncyB8PSAxMzQyMTc3MjggLyogU3RhdGljUXVlcnkgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbGFncyB8PSAyNjg0MzU0NTYgLyogRHluYW1pY1F1ZXJ5ICovO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3M7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgR2VuZXJhdGVkRmlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNyY0ZpbGVVcmwgPSBzcmNGaWxlVXJsO1xuICAgICAgICB0aGlzLmdlbkZpbGVVcmwgPSBnZW5GaWxlVXJsO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRlZEZpbGU7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xzXG4gKiBAcGFyYW0gez99IHR5cGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTdW1tYXJpZXMoc3VtbWFyeVJlc29sdmVyLCBzeW1ib2xSZXNvbHZlciwgc3ltYm9scywgdHlwZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIkMShzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICAvLyBmb3Igc3ltYm9scywgd2UgdXNlIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgY2xhc3MgbWV0YWRhdGEgaXRzZWxmXG4gICAgLy8gKHdlIGtlZXAgdGhlIHN0YXRpY3MgdGhvdWdoKSwgYXMgdGhlIGNsYXNzIG1ldGFkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICAvLyBDb21waWxlVHlwZVN1bW1hcnkuXG4gICAgc3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gc2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeSh7IHN5bWJvbDogcmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCBtZXRhZGF0YTogcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgfSk7IH0pO1xuICAgIC8vIEFkZCBzdW1tYXJpZXMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSB0aGUgZ2l2ZW4gc3ltYm9scyAodHJhbnNpdGl2ZWx5KVxuICAgIC8vIE5vdGU6IHRoZSBzZXJpYWxpemVyLnN5bWJvbHMgYXJyYXkgbWlnaHQgYmUgZ3Jvd2luZyB3aGlsZVxuICAgIC8vIHdlIGV4ZWN1dGUgdGhlIGxvb3AhXG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9jZXNzZWRJbmRleCA9IDA7IHByb2Nlc3NlZEluZGV4IDwgc2VyaWFsaXplci5zeW1ib2xzLmxlbmd0aDsgcHJvY2Vzc2VkSW5kZXgrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2wgPSBzZXJpYWxpemVyLnN5bWJvbHNbcHJvY2Vzc2VkSW5kZXhdO1xuICAgICAgICBpZiAoc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzeW1ib2wpO1xuICAgICAgICAgICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSBzeW1ib2xzIG1pZ2h0IG9yaWdpbmF0ZSBmcm9tIGEgcGxhaW4gdHlwZXNjcmlwdCBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBqdXN0IGV4cG9ydGVkIC5kLnRzIGFuZCAubWV0YWRhdGEuanNvbiBmaWxlcywgaS5lLiB3aGVyZSBubyBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgLy8gZmlsZXMgd2VyZSBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5ID0geyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCB0eXBlIHN1bW1hcmllcy5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBhZGQgdGhlIHN1bW1hcmllcyBvZiBhbGwgcmVmZXJlbmNlZCBzeW1ib2xzIGFzIGZvciB0aGUgUmVzb2x2ZWRTeW1ib2xzLFxuICAgIC8vIGFzIHRoZSB0eXBlIHN1bW1hcmllcyBhbHJlYWR5IGNvbnRhaW4gdGhlIHRyYW5zaXRpdmUgZGF0YSB0aGF0IHRoZXkgcmVxdWlyZVxuICAgIC8vIChpbiBhIG1pbmltYWwgd2F5KS5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlU3VtbWFyeSkge1xuICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHsgc3ltYm9sOiB0eXBlU3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgbWV0YWRhdGE6IG51bGwsIHR5cGU6IHR5cGVTdW1tYXJ5IH0pO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVTdW1tYXJ5ID0gKHR5cGVTdW1tYXJ5KTtcbiAgICAgICAgICAgIG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZERpcmVjdGl2ZXMuY29uY2F0KG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZFBpcGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IGlkLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzeW1ib2xDYWNoZVxuICogQHBhcmFtIHs/fSBqc29uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN1bW1hcmllcyhzeW1ib2xDYWNoZSwganNvbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc2VyaWFsaXplciA9IG5ldyBEZXNlcmlhbGl6ZXIoc3ltYm9sQ2FjaGUpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoanNvbik7XG59XG52YXIgU2VyaWFsaXplciQxID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VyaWFsaXplciQxLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIkMShzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bWJvbFJlc29sdmVyID0gc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnN1bW1hcnlSZXNvbHZlciA9IHN1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGNvbnRhaW5zIHN5bWJvbHMgd2l0aG91dCBtZW1iZXJzLlxuICAgICAgICBfdGhpcy5zeW1ib2xzID0gW107XG4gICAgICAgIF90aGlzLmluZGV4QnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NlZFN1bW1hcnlCeVN5bWJvbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkU3VtbWFyaWVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdW1tYXJ5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyJDEucHJvdG90eXBlLmFkZE9yTWVyZ2VTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IHN1bW1hcnkubWV0YWRhdGE7XG4gICAgICAgIGlmIChzeW1ib2xNZXRhICYmIHN5bWJvbE1ldGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgLy8gRm9yIGNsYXNzZXMsIHdlIGtlZXAgZXZlcnl0aGluZyBleGNlcHQgdGhlaXIgY2xhc3MgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBlLmcuIHRoZSBjdG9yIGFyZ3MsIG1ldGhvZCBuYW1lcywgbWV0aG9kIGRlY29yYXRvcnNcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGNsYXNzIGNhbiBiZSBleHRlbmRlZCBpbiBhbm90aGVyIGNvbXBpbGF0aW9uIHVuaXQuXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrZWVwIHRoZSBjbGFzcyBkZWNvcmF0b3JzIGFzXG4gICAgICAgICAgICAvLyAxKSB0aGV5IHJlZmVyIHRvIGRhdGFcbiAgICAgICAgICAgIC8vICAgdGhhdCBzaG91bGQgbm90IGNhdXNlIGEgcmVidWlsZCBvZiBkb3duc3RyZWFtIGNvbXBpbGF0aW9uIHVuaXRzXG4gICAgICAgICAgICAvLyAgIChlLmcuIGlubGluZSB0ZW1wbGF0ZXMgb2YgQENvbXBvbmVudCwgb3IgQE5nTW9kdWxlLmRlY2xhcmF0aW9ucylcbiAgICAgICAgICAgIC8vIDIpIHRoZWlyIGRhdGEgaXMgYWxyZWFkeSBjYXB0dXJlZCBpbiBUeXBlU3VtbWFyaWVzLCBlLmcuIERpcmVjdGl2ZVN1bW1hcnkuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZV8xID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzeW1ib2xNZXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ2RlY29yYXRvcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lXzFbcHJvcE5hbWVdID0gc3ltYm9sTWV0YVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzeW1ib2xNZXRhID0gY2xvbmVfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wuZ2V0KHN1bW1hcnkuc3ltYm9sKTtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRTdW1tYXJ5KSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzVmFsdWUoeyBzeW1ib2w6IHN1bW1hcnkuc3ltYm9sIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMucHVzaChwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLnNldChzdW1tYXJ5LnN5bWJvbCwgcHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICBpZiAocHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9PSBudWxsICYmIHN5bWJvbE1ldGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9IHRoaXMucHJvY2Vzc1ZhbHVlKHN5bWJvbE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6ID09IG9uIHB1cnBvc2UgdG8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCFcbiAgICAgICAgaWYgKHByb2Nlc3NlZFN1bW1hcnkudHlwZSA9PSBudWxsICYmIHN1bW1hcnkudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5LnR5cGUgPSB0aGlzLnByb2Nlc3NWYWx1ZShzdW1tYXJ5LnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIkMS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRBcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBqc29uID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc3VtbWFyaWVzOiB0aGlzLnByb2Nlc3NlZFN1bW1hcmllcyxcbiAgICAgICAgICAgIHN5bWJvbHM6IHRoaXMuc3ltYm9scy5tYXAoZnVuY3Rpb24gKHN5bWJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0QXM7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXMgPSBzeW1ib2wubmFtZSArIFwiX1wiICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgZXhwb3J0QXM6IGltcG9ydEFzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bWJvbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb252ZXJ0IHRoZSBzb3VyY2UgZmlsZW5hbWVzIHRpbnRvIG91dHB1dCBmaWxlbmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBnZW5lcmF0ZWQgc3VtbWFyeSBmaWxlIHdpbGwgYmUgdXNlZCB3aGVuIHRlaCBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGF0aW9uIHVuaXQgaXMgdXNlZCBhcyBhIGxpYnJhcnlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IF90aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRMaWJyYXJ5RmlsZU5hbWUoc3ltYm9sLmZpbGVQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXM6IGltcG9ydEFzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBqc29uOiBqc29uLCBleHBvcnRBczogZXhwb3J0QXMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIkMS5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCB0aGlzLCBudWxsKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyJDEucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2wodmFsdWUuZmlsZVBhdGgsIHZhbHVlLm5hbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSB0aGlzLmluZGV4QnlTeW1ib2wuZ2V0KGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXhCeVN5bWJvbC5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCeVN5bWJvbC5zZXQoYmFzZVN5bWJvbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9scy5wdXNoKGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgX19zeW1ib2w6IGluZGV4LCBtZW1iZXJzOiB2YWx1ZS5tZW1iZXJzIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXJpYWxpemVyJDE7XG59KFZhbHVlVHJhbnNmb3JtZXIpKTtcbnZhciBEZXNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlc2VyaWFsaXplcihzeW1ib2xDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW1ib2xDYWNoZSA9IHN5bWJvbENhY2hlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ganNvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVzZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRBcyA9IFtdO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBbXTtcbiAgICAgICAgZGF0YS5zeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHNlcmlhbGl6ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IF90aGlzLnN5bWJvbENhY2hlLmdldChzZXJpYWxpemVkU3ltYm9sLmZpbGVQYXRoLCBzZXJpYWxpemVkU3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuc3ltYm9scy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFN5bWJvbC5pbXBvcnRBcykge1xuICAgICAgICAgICAgICAgIGltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IHNlcmlhbGl6ZWRTeW1ib2wuaW1wb3J0QXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJpZXMgPSB2aXNpdFZhbHVlKGRhdGEuc3VtbWFyaWVzLCB0aGlzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHsgc3VtbWFyaWVzOiBzdW1tYXJpZXMsIGltcG9ydEFzOiBpbXBvcnRBcyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlc2VyaWFsaXplci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICgnX19zeW1ib2wnIGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuc3ltYm9sc1ttYXBbJ19fc3ltYm9sJ11dO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IG1hcFsnbWVtYmVycyddO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnMubGVuZ3RoID8gdGhpcy5zeW1ib2xDYWNoZS5nZXQoYmFzZVN5bWJvbC5maWxlUGF0aCwgYmFzZVN5bWJvbC5uYW1lLCBtZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgYmFzZVN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlc2VyaWFsaXplcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFvdENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9ob3N0XG4gICAgICogQHBhcmFtIHs/fSBfbWV0YWRhdGFSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc3R5bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlQ29tcGlsZXJcbiAgICAgKiBAcGFyYW0gez99IF9vdXRwdXRFbWl0dGVyXG4gICAgICogQHBhcmFtIHs/fSBfc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxlSWRcbiAgICAgKiBAcGFyYW0gez99IF90cmFuc2xhdGlvbkZvcm1hdFxuICAgICAqIEBwYXJhbSB7P30gX2dlbkZpbGVQcmVhbWJsZVxuICAgICAqIEBwYXJhbSB7P30gX3N5bWJvbFJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW90Q29tcGlsZXIoX2NvbmZpZywgX2hvc3QsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX291dHB1dEVtaXR0ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9sb2NhbGVJZCwgX3RyYW5zbGF0aW9uRm9ybWF0LCBfZ2VuRmlsZVByZWFtYmxlLCBfc3ltYm9sUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5faG9zdCA9IF9ob3N0O1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIgPSBfc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9sb2NhbGVJZCA9IF9sb2NhbGVJZDtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQgPSBfdHJhbnNsYXRpb25Gb3JtYXQ7XG4gICAgICAgIHRoaXMuX2dlbkZpbGVQcmVhbWJsZSA9IF9nZW5GaWxlUHJlYW1ibGU7XG4gICAgICAgIHRoaXMuX3N5bWJvbFJlc29sdmVyID0gX3N5bWJvbFJlc29sdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RGaWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVBbGwgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2dyYW1TeW1ib2xzID0gZXh0cmFjdFByb2dyYW1TeW1ib2xzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCByb290RmlsZXMsIHRoaXMuX2hvc3QpO1xuICAgICAgICB2YXIgX2EgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIHRoaXMuX2hvc3QsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gX2EubmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZmlsZXMgPSBfYS5maWxlcywgbmdNb2R1bGVzID0gX2EubmdNb2R1bGVzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBmYWxzZSk7IH0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTW9kdWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVTcmNGaWxlKGZpbGUuc3JjVXJsLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlLmRpcmVjdGl2ZXMsIGZpbGUucGlwZXMsIGZpbGUubmdNb2R1bGVzLCBmaWxlLmluamVjdGFibGVzKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihzb3VyY2VNb2R1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IGluamVjdGFibGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTcmNGaWxlID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVTdWZmaXggPSBzcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3JjRmlsZVVybClbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdlbmVyYXRlZEZpbGVzID0gW107XG4gICAgICAgIGdlbmVyYXRlZEZpbGVzLnB1c2godGhpcy5fY3JlYXRlU3VtbWFyeShzcmNGaWxlVXJsLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgc3RhdGVtZW50cywgZXhwb3J0ZWRWYXJzKSk7XG4gICAgICAgIC8vIGNvbXBpbGUgYWxsIG5nIG1vZHVsZXNcbiAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YSgvKiogQHR5cGUgez99ICovIChkaXJUeXBlKSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY29tcG9uZW50IFwiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIiFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgc3R5bGVzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNDb21waWxlUmVzdWx0cyA9IF90aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgc3R5bGVzQ29tcGlsZVJlc3VsdHMuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21waWxlZFN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy5wdXNoKF90aGlzLl9jb2RnZW5TdHlsZXMoc3JjRmlsZVVybCwgY29tcGlsZWRTdHlsZVNoZWV0LCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFZpZXdWYXJzID0gX3RoaXMuX2NvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIHN0eWxlc0NvbXBpbGVSZXN1bHRzLmNvbXBvbmVudFN0eWxlc2hlZXQsIGZpbGVTdWZmaXgsIHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2goX3RoaXMuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5KGNvbXBNZXRhLCBuZ01vZHVsZSwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cyksIGNvbXBWaWV3VmFycy52aWV3Q2xhc3NWYXIsIGNvbXBWaWV3VmFycy5jb21wUmVuZGVyVHlwZVZhcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmNNb2R1bGUgPSB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIG5nZmFjdG9yeUZpbGVQYXRoKHNyY0ZpbGVVcmwpLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpO1xuICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMudW5zaGlmdChzcmNNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZWRGaWxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0YWJsZXNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV4cG9ydGVkVmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCB0YXJnZXRTdGF0ZW1lbnRzLCB0YXJnZXRFeHBvcnRlZFZhcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sU3VtbWFyaWVzID0gdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZ2V0U3ltYm9sc09mKHNyY0ZpbGVVcmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIF90aGlzLl9zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlU3VtbWFyaWVzID0gbmdNb2R1bGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZVN1bW1hcnkocmVmKTsgfSkuY29uY2F0KGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkocmVmKTsgfSksIHBpcGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShyZWYpOyB9KSwgaW5qZWN0YWJsZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVTdW1tYXJ5KHJlZik7IH0pKTtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplU3VtbWFyaWVzKHRoaXMuX3N1bW1hcnlSZXNvbHZlciwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHN5bWJvbFN1bW1hcmllcywgdHlwZVN1bW1hcmllcyksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgICAgICBleHBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGVudHJ5LmV4cG9ydEFzKS5zZXQoaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogZW50cnkuc3ltYm9sIH0pKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgdGFyZ2V0RXhwb3J0ZWRWYXJzLnB1c2goZW50cnkuZXhwb3J0QXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIHN1bW1hcnlGaWxlTmFtZShzcmNGaWxlVXJsKSwganNvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZ01vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsZUlkKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5MT0NBTEVfSUQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9sb2NhbGVJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBDb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG5nTW9kdWxlLCBwcm92aWRlcnMpO1xuICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgYXBwQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwcENvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlLCBmaWxlU3VmZml4LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RUeXBlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50VHlwZShjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoaG9zdFR5cGUsIGNvbXBNZXRhLCB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MoaG9zdFR5cGUpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFZpZXdGYWN0b3J5VmFyID0gdGhpcy5fY29tcGlsZUNvbXBvbmVudChob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSwgbnVsbCwgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cylcbiAgICAgICAgICAgIC52aWV3Q2xhc3NWYXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBGYWN0b3J5VmFyID0gY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHNFeHBycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3BOYW1lIGluIGNvbXBNZXRhLmlucHV0cykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVOYW1lID0gY29tcE1ldGEuaW5wdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBpbnB1dHNFeHBycy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkocHJvcE5hbWUsIGxpdGVyYWwodGVtcGxhdGVOYW1lKSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTmFtZSBpbiBjb21wTWV0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU5hbWUgPSBjb21wTWV0YS5vdXRwdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBvdXRwdXRzRXhwcnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKHRlbXBsYXRlTmFtZSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGNvbXBGYWN0b3J5VmFyKVxuICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSkpLmNhbGxGbihbXG4gICAgICAgICAgICBsaXRlcmFsKGNvbXBNZXRhLnNlbGVjdG9yKSwgaW1wb3J0RXhwcihjb21wTWV0YS50eXBlKSxcbiAgICAgICAgICAgIHZhcmlhYmxlKGhvc3RWaWV3RmFjdG9yeVZhciksIG5ldyBMaXRlcmFsTWFwRXhwcihpbnB1dHNFeHBycyksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0c0V4cHJzKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIoY29tcE1ldGEudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIGxpdGVyYWwoc2VsZWN0b3IpOyB9KSlcbiAgICAgICAgXSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChpbXBvcnRUeXBlKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSksIFtpbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgICByZXR1cm4gY29tcEZhY3RvcnlWYXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSWRlbnRpZmllcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmlsZVN1ZmZpeFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzID0gZGlyZWN0aXZlSWRlbnRpZmllcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZS50eXBlLCBjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUpKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0V4cHIgPSBjb21wb25lbnRTdHlsZXMgPyB2YXJpYWJsZShjb21wb25lbnRTdHlsZXMuc3R5bGVzVmFyKSA6IGxpdGVyYWxBcnIoW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXNFeHByLCB1c2VkUGlwZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50U3R5bGVzKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCkpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCB2aWV3UmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICByZXR1cm4geyB2aWV3Q2xhc3NWYXI6IHZpZXdSZXN1bHQudmlld0NsYXNzVmFyLCBjb21wUmVuZGVyVHlwZVZhcjogdmlld1Jlc3VsdC5yZW5kZXJlclR5cGVWYXIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzQ29tcGlsZVJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZmlsZVN1ZmZpeFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb2RnZW5TdHlsZXMgPSBmdW5jdGlvbiAoZmlsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCkge1xuICAgICAgICBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyh0aGlzLl9zeW1ib2xSZXNvbHZlciwgc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKGZpbGVVcmwsIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzQ29tcGlsZVJlc3VsdC5tZXRhLm1vZHVsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdC5pc1NoaW1tZWQsIGZpbGVTdWZmaXgpLCBzdHlsZXNDb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtzdHlsZXNDb21waWxlUmVzdWx0LnN0eWxlc1Zhcl0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRlZFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBnZW5GaWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHRoaXMuX291dHB1dEVtaXR0ZXIuZW1pdFN0YXRlbWVudHMoc291cmNlVXJsKHNyY0ZpbGVVcmwpLCBnZW5GaWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMsIHRoaXMuX2dlbkZpbGVQcmVhbWJsZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFvdENvbXBpbGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSByZWZsZWN0b3JcbiAqIEBwYXJhbSB7P30gY29tcGlsZVJlc3VsdFxuICogQHBhcmFtIHs/fSBmaWxlU3VmZml4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyhyZWZsZWN0b3IsIGNvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpIHtcbiAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucmVmZXJlbmNlID0gcmVmbGVjdG9yLmdldFN0YXRpY1N5bWJvbChfc3R5bGVzTW9kdWxlVXJsKGRlcC5tb2R1bGVVcmwsIGRlcC5pc1NoaW1tZWQsIGZpbGVTdWZmaXgpLCBkZXAubmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNoZWV0VXJsXG4gKiBAcGFyYW0gez99IHNoaW1cbiAqIEBwYXJhbSB7P30gc3VmZml4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfc3R5bGVzTW9kdWxlVXJsKHN0eWxlc2hlZXRVcmwsIHNoaW0sIHN1ZmZpeCkge1xuICAgIHJldHVybiBcIlwiICsgc3R5bGVzaGVldFVybCArIChzaGltID8gJy5zaGltJyA6ICcnKSArIFwiLm5nc3R5bGVcIiArIHN1ZmZpeDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgaWRlbnRpZmllck5hbWUobWV0YS50eXBlKSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciBfYSA9IF9jcmVhdGVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIGhvc3QsIG1ldGFkYXRhUmVzb2x2ZXIpLCBuZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlID0gX2Euc3ltYm9sc01pc3NpbmdNb2R1bGU7XG4gICAgcmV0dXJuIF9hbmFseXplTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBuZ01vZHVsZXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlLCBtZXRhZGF0YVJlc29sdmVyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm9ncmFtU3RhdGljU3ltYm9sc1xuICogQHBhcmFtIHs/fSBob3N0XG4gKiBAcGFyYW0gez99IG1ldGFkYXRhUmVzb2x2ZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGFuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIGhvc3QsIG1ldGFkYXRhUmVzb2x2ZXIpO1xuICAgIGlmIChyZXN1bHQuc3ltYm9sc01pc3NpbmdNb2R1bGUgJiYgcmVzdWx0LnN5bWJvbHNNaXNzaW5nTW9kdWxlLmxlbmd0aCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlcyA9IHJlc3VsdC5zeW1ib2xzTWlzc2luZ01vZHVsZS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiQ2Fubm90IGRldGVybWluZSB0aGUgbW9kdWxlIGZvciBjbGFzcyBcIiArIHMubmFtZSArIFwiIGluIFwiICsgcy5maWxlUGF0aCArIFwiISBBZGQgXCIgKyBzLm5hbWUgKyBcIiB0byB0aGUgTmdNb2R1bGUgdG8gZml4IGl0LlwiOyB9KTtcbiAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IobWVzc2FnZXMuam9pbignXFxuJykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TeW1ib2xzXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlTWV0YXNcbiAqIEBwYXJhbSB7P30gc3ltYm9sc01pc3NpbmdNb2R1bGVcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2FuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIG5nTW9kdWxlTWV0YXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YXNCeVJlZiA9IG5ldyBNYXAoKTtcbiAgICBuZ01vZHVsZU1ldGFzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBtb2R1bGVNZXRhc0J5UmVmLnNldChuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGUpOyB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0RpcmVjdGl2ZXNCeUZpbGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdQaXBlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0luamVjdGFibGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRocyA9IG5ldyBTZXQoKTtcbiAgICAvLyBNYWtlIHN1cmUgd2UgcHJvZHVjZSBhbiBhbmFseXplZCBmaWxlIGZvciBlYWNoIGlucHV0IGZpbGVcbiAgICBwcm9ncmFtU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGggPSBzeW1ib2wuZmlsZVBhdGg7XG4gICAgICAgIGZpbGVQYXRocy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICBpZiAobWV0YWRhdGFSZXNvbHZlci5pc0luamVjdGFibGUoc3ltYm9sKSkge1xuICAgICAgICAgICAgbmdJbmplY3RhYmxlc0J5RmlsZS5zZXQoZmlsZVBhdGgsIChuZ0luamVjdGFibGVzQnlGaWxlLmdldChmaWxlUGF0aCkgfHwgW10pLmNvbmNhdChzeW1ib2wpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIExvb3Bpbmcgb3ZlciBhbGwgbW9kdWxlcyB0byBjb25zdHJ1Y3Q6XG4gICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gbW9kdWxlcyBgbmdNb2R1bGVzQnlGaWxlYCxcbiAgICAvLyAtIGEgbWFwIGZyb20gZmlsZSB0byBkaXJlY3RpdmVzIGBuZ0RpcmVjdGl2ZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIHBpcGVzIGBuZ1BpcGVzQnlGaWxlYCxcbiAgICAvLyAtIGEgbWFwIGZyb20gZGlyZWN0aXZlL3BpcGUgdG8gbW9kdWxlIGBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlYC5cbiAgICBuZ01vZHVsZU1ldGFzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlTWV0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmNGaWxlVXJsID0gbmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICBmaWxlUGF0aHMuYWRkKHNyY0ZpbGVVcmwpO1xuICAgICAgICBuZ01vZHVsZXNCeUZpbGUuc2V0KHNyY0ZpbGVVcmwsIChuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY0ZpbGVVcmwpIHx8IFtdKS5jb25jYXQobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgIG5nTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlySWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVVybCA9IGRpcklkZW50aWZpZXIucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgIG5nRGlyZWN0aXZlc0J5RmlsZS5zZXQoZmlsZVVybCwgKG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoZmlsZVVybCkgfHwgW10pLmNvbmNhdChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQoZGlySWRlbnRpZmllci5yZWZlcmVuY2UsIG5nTW9kdWxlTWV0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZ01vZHVsZU1ldGEuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVVybCA9IHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZS5maWxlUGF0aDtcbiAgICAgICAgICAgIGZpbGVQYXRocy5hZGQoZmlsZVVybCk7XG4gICAgICAgICAgICBuZ1BpcGVzQnlGaWxlLnNldChmaWxlVXJsLCAobmdQaXBlc0J5RmlsZS5nZXQoZmlsZVVybCkgfHwgW10pLmNvbmNhdChwaXBlSWRlbnRpZmllci5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuc2V0KHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZXMgPSBbXTtcbiAgICBmaWxlUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoc3JjVXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSBuZ0RpcmVjdGl2ZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVzID0gbmdQaXBlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzID0gbmdNb2R1bGVzQnlGaWxlLmdldChzcmNVcmwpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmplY3RhYmxlcyA9IG5nSW5qZWN0YWJsZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIGZpbGVzLnB1c2goeyBzcmNVcmw6IHNyY1VybCwgZGlyZWN0aXZlczogZGlyZWN0aXZlcywgcGlwZXM6IHBpcGVzLCBuZ01vZHVsZXM6IG5nTW9kdWxlcywgaW5qZWN0YWJsZXM6IGluamVjdGFibGVzIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIG1hcCBkaXJlY3RpdmUvcGlwZSB0byBtb2R1bGVcbiAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZTogbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSxcbiAgICAgICAgLy8gbGlzdCBtb2R1bGVzIGFuZCBkaXJlY3RpdmVzIGZvciBldmVyeSBzb3VyY2UgZmlsZVxuICAgICAgICBmaWxlczogZmlsZXMsXG4gICAgICAgIG5nTW9kdWxlczogbmdNb2R1bGVNZXRhcywgc3ltYm9sc01pc3NpbmdNb2R1bGU6IHN5bWJvbHNNaXNzaW5nTW9kdWxlXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xSZXNvbHZlclxuICogQHBhcmFtIHs/fSBmaWxlc1xuICogQHBhcmFtIHs/fSBob3N0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvZ3JhbVN5bWJvbHMoc3RhdGljU3ltYm9sUmVzb2x2ZXIsIGZpbGVzLCBob3N0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9scyA9IFtdO1xuICAgIGZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIGhvc3QuaXNTb3VyY2VGaWxlKGZpbGVOYW1lKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICBzdGF0aWNTeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2Yoc291cmNlRmlsZSkuZm9yRWFjaChmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHN0YXRpY1N5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbE1ldGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChzeW1ib2xNZXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbE1ldGEuX19zeW1ib2xpYyAhPSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzeW1ib2xzIHRoYXQgYXJlIG9ubHkgaW5jbHVkZWQgdG8gcmVjb3JkIGVycm9yIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNTeW1ib2xzLnB1c2gocmVzb2x2ZWRTeW1ib2wuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0aWNTeW1ib2xzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmFtUGlwZXNBbmREaXJlY3RpdmVzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhZGROZ01vZHVsZSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgaWYgKG5nTW9kdWxlcy5oYXMoc3RhdGljU3ltYm9sKSB8fCAhaG9zdC5pc1NvdXJjZUZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKHN0YXRpY1N5bWJvbCwgZmFsc2UpO1xuICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgIG5nTW9kdWxlcy5zZXQobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlKTtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIG5nTW9kdWxlUGlwZXNBbmREaXJlY3RpdmUuYWRkKGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5hZGQocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgIC8vIEZvciBldmVyeSBpbnB1dCBtb2R1bGUgYWRkIHRoZSBsaXN0IG9mIHRyYW5zaXRpdmVseSBpbmNsdWRlZCBtb2R1bGVzXG4gICAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kTWV0YSkgeyByZXR1cm4gYWRkTmdNb2R1bGUobW9kTWV0YS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFuZ01vZHVsZTtcbiAgICB9O1xuICAgIHByb2dyYW1TdGF0aWNTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoIWFkZE5nTW9kdWxlKHN0YXRpY1N5bWJvbCkgJiZcbiAgICAgICAgICAgIChtZXRhZGF0YVJlc29sdmVyLmlzRGlyZWN0aXZlKHN0YXRpY1N5bWJvbCkgfHwgbWV0YWRhdGFSZXNvbHZlci5pc1BpcGUoc3RhdGljU3ltYm9sKSkpIHtcbiAgICAgICAgICAgIHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMucHVzaChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBwcm9ncmFtIHBpcGUgb3IgZGlyZWN0aXZlcyBpcyBub3QgZGVjbGFyZWQgYnkgYSBtb2R1bGVcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xzTWlzc2luZ01vZHVsZSA9IHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5oYXMocyk7IH0pO1xuICAgIHJldHVybiB7IG5nTW9kdWxlczogQXJyYXkuZnJvbShuZ01vZHVsZXMudmFsdWVzKCkpLCBzeW1ib2xzTWlzc2luZ01vZHVsZTogc3ltYm9sc01pc3NpbmdNb2R1bGUgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNEZWxlZ2F0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHN0YXRpY0RlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGljRGVsZWdhdGUgPSBzdGF0aWNEZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVsZWdhdGUgPSBuZXcgybVSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljRGVsZWdhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmluc3RhbGwgPSBmdW5jdGlvbiAoc3RhdGljRGVsZWdhdGUpIHtcbiAgICAgICAgybVyZWZsZWN0b3IudXBkYXRlQ2FwYWJpbGl0aWVzKG5ldyBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcyhzdGF0aWNEZWxlZ2F0ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5mYWN0b3J5KHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbGNQcm9wZXJ0eVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHR5cGUpID8gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5oYXNMaWZlY3ljbGVIb29rKHR5cGUsIGxjUHJvcGVydHkpIDpcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlbGVnYXRlLmhhc0xpZmVjeWNsZUhvb2sodHlwZSwgbGNQcm9wZXJ0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhdGljVHlwZSh0eXBlKSA/IHRoaXMuc3RhdGljRGVsZWdhdGUucGFyYW1ldGVycyh0eXBlKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5wYXJhbWV0ZXJzKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHR5cGUpID8gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5hbm5vdGF0aW9ucyh0eXBlKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5hbm5vdGF0aW9ucyh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1R5cGUodHlwZU9yRnVuYykgPyB0aGlzLnN0YXRpY0RlbGVnYXRlLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5keW5hbWljRGVsZWdhdGUuZ2V0dGVyKG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5zZXR0ZXIobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuZHluYW1pY0RlbGVnYXRlLm1ldGhvZChuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5pbXBvcnRVcmkodHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb3VyY2VVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvdXJjZVVyaSh0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbWVtYmVyc1xuICAgICAqIEBwYXJhbSB7P30gcnVudGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgbWVtYmVycywgcnVudGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBtb2R1bGVVcmwsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGVudW1JZGVudGlmaWVyLCBuYW1lKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY1R5cGUoZW51bUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlRW51bShlbnVtSWRlbnRpZmllciwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N0YXRpY1R5cGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS5uYW1lICYmIHR5cGUuZmlsZVBhdGg7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQU5HVUxBUl9DT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIEhJRERFTl9LRVkgPSAvXlxcJC4qXFwkJC87XG52YXIgSUdOT1JFID0ge1xuICAgIF9fc3ltYm9saWM6ICdpZ25vcmUnXG59O1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaG91bGRJZ25vcmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19zeW1ib2xpYyA9PSAnaWdub3JlJztcbn1cbi8qKlxuICogQSBzdGF0aWMgcmVmbGVjdG9yIGltcGxlbWVudHMgZW5vdWdoIG9mIHRoZSBSZWZsZWN0b3IgQVBJIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIGNvbXBpbGVcbiAqIHRlbXBsYXRlcyBzdGF0aWNhbGx5LlxuICovXG52YXIgU3RhdGljUmVmbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBrbm93bk1ldGFkYXRhQ2xhc3Nlc1xuICAgICAqIEBwYXJhbSB7Pz19IGtub3duTWV0YWRhdGFGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvclJlY29yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIGtub3duTWV0YWRhdGFDbGFzc2VzLCBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhQ2xhc3NlcyA9PT0gdm9pZCAwKSB7IGtub3duTWV0YWRhdGFDbGFzc2VzID0gW107IH1cbiAgICAgICAgaWYgKGtub3duTWV0YWRhdGFGdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhRnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAoKTtcbiAgICAgICAga25vd25NZXRhZGF0YUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2MpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IoX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGtjLmZpbGVQYXRoLCBrYy5uYW1lKSwga2MuY3Rvcik7IH0pO1xuICAgICAgICBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtmKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbihfdGhpcy5nZXRTdGF0aWNTeW1ib2woa2YuZmlsZVBhdGgsIGtmLm5hbWUpLCBrZi5mbik7IH0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSwgW0RpcmVjdGl2ZSwgQ29tcG9uZW50XSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuUGlwZSwgW1BpcGVdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSwgW05nTW9kdWxlXSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgW0luamVjdGFibGUsIFBpcGUsIERpcmVjdGl2ZSwgQ29tcG9uZW50LCBOZ01vZHVsZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25OYW1lcy5zZXQoRGlyZWN0aXZlLCAnRGlyZWN0aXZlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChDb21wb25lbnQsICdDb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMuc2V0KFBpcGUsICdQaXBlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChOZ01vZHVsZSwgJ05nTW9kdWxlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChJbmplY3RhYmxlLCAnSW5qZWN0YWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2wgPyBzdGF0aWNTeW1ib2wuZmlsZVBhdGggOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlc291cmNlVXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFJlc291cmNlUGF0aChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG1lbWJlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBtZW1iZXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydFN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKG1vZHVsZVVybCwgbmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RTeW1ib2wgPSB0aGlzLmZpbmREZWNsYXJhdGlvbihtb2R1bGVVcmwsIG5hbWUpO1xuICAgICAgICBpZiAoaW1wb3J0U3ltYm9sICE9IHJvb3RTeW1ib2wpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVjb3JkSW1wb3J0QXMocm9vdFN5bWJvbCwgaW1wb3J0U3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljU3ltYm9sKHJvb3RTeW1ib2wuZmlsZVBhdGgsIHJvb3RTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RTeW1ib2w7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRhaW5pbmdGaWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbih0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRTeW1ib2xEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24ocmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChlbnVtSWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2wgPSBlbnVtSWRlbnRpZmllcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IChzdGF0aWNTeW1ib2wubWVtYmVycyB8fCBbXSkuY29uY2F0KG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbkNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRBbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbnMocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgcGFyZW50QW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3duQW5ub3RhdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSkge1xuICAgICAgICAgICAgICAgIG93bkFubm90YXRpb25zXzEgPSB0aGlzLnNpbXBsaWZ5KHR5cGUsIGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgb3duQW5ub3RhdGlvbnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSAmJiAhdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZSh0eXBlLmZpbGVQYXRoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUocGFyZW50VHlwZS5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzID0gdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuZ2V0KHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVIYXNSZXF1aXJlZEFubm90YXRpb24gPSByZXF1aXJlZEFubm90YXRpb25UeXBlcy5zb21lKGZ1bmN0aW9uIChyZXF1aXJlZFR5cGUpIHsgcmV0dXJuIG93bkFubm90YXRpb25zXzEuc29tZShmdW5jdGlvbiAoYW5uKSB7IHJldHVybiBhbm4gaW5zdGFuY2VvZiByZXF1aXJlZFR5cGU7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlSGFzUmVxdWlyZWRBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2xhc3MgXCIgKyB0eXBlLm5hbWUgKyBcIiBpbiBcIiArIHR5cGUuZmlsZVBhdGggKyBcIiBleHRlbmRzIGZyb20gYSBcIiArIENvbXBpbGVTdW1tYXJ5S2luZFtzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmRdICsgXCIgaW4gYW5vdGhlciBjb21waWxhdGlvbiB1bml0IHdpdGhvdXQgZHVwbGljYXRpbmcgdGhlIGRlY29yYXRvci4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlBsZWFzZSBhZGQgYSBcIiArIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuYW5ub3RhdGlvbk5hbWVzLmdldCh0eXBlKTsgfSkuam9pbignIG9yICcpICsgXCIgZGVjb3JhdG9yIHRvIHRoZSBjbGFzcy5cIikpLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhY2hlLnNldCh0eXBlLCBhbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gISFhbm47IH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE1ldGFkYXRhID0gdGhpcy5wcm9wZXJ0eUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFByb3BNZXRhZGF0YV8xID0gdGhpcy5wcm9wTWV0YWRhdGEocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50UHJvcE1ldGFkYXRhXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3BhcmVudFByb3BdID0gcGFyZW50UHJvcE1ldGFkYXRhXzFbcGFyZW50UHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXJzXzEgPSBjbGFzc01ldGFkYXRhWydtZW1iZXJzJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZW1iZXJzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcERhdGEgPSBtZW1iZXJzXzFbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3AgPSAoKHByb3BEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAncHJvcGVydHknIHx8IGFbJ19fc3ltYm9saWMnXSA9PSAnbWV0aG9kJzsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3Byb3BOYW1lXSA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgcHJvcFsnZGVjb3JhdG9ycyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBfdGhpcy5zaW1wbGlmeSh0eXBlLCBwcm9wWydkZWNvcmF0b3JzJ10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlDYWNoZS5zZXQodHlwZSwgcHJvcE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJwYXJhbWV0ZXJzIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzXzEgPSB0aGlzLnBhcmFtZXRlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjbGFzc01ldGFkYXRhID8gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yRGF0YSA9IG1lbWJlcnMgPyBtZW1iZXJzWydfX2N0b3JfXyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY3RvckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9ICgoY3RvckRhdGEpKS5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydfX3N5bWJvbGljJ10gPT0gJ2NvbnN0cnVjdG9yJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlclR5cGVzID0gKHRoaXMuc2ltcGxpZnkodHlwZSwgY3RvclsncGFyYW1ldGVycyddIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlckRlY29yYXRvcnNfMSA9ICh0aGlzLnNpbXBsaWZ5KHR5cGUsIGN0b3JbJ3BhcmFtZXRlckRlY29yYXRvcnMnXSB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1UeXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkUmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkUmVzdWx0LnB1c2gocGFyYW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY29yYXRvcnMgPSBwYXJhbWV0ZXJEZWNvcmF0b3JzXzEgPyBwYXJhbWV0ZXJEZWNvcmF0b3JzXzFbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkUmVzdWx0LnB1c2guYXBwbHkobmVzdGVkUmVzdWx0LCBkZWNvcmF0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMS5wdXNoKG5lc3RlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMSA9IHRoaXMucGFyYW1ldGVycyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyQ2FjaGUuc2V0KHR5cGUsIHBhcmFtZXRlcnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyc18xO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIG9uIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdpdGggZXJyb3IgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fbWV0aG9kTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2ROYW1lcyA9IHRoaXMubWV0aG9kQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHt9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudE1ldGhvZE5hbWVzXzEgPSB0aGlzLl9tZXRob2ROYW1lcyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRNZXRob2ROYW1lc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzW3BhcmVudFByb3BdID0gcGFyZW50TWV0aG9kTmFtZXNfMVtwYXJlbnRQcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnNfMiA9IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lbWJlcnNfMikuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wRGF0YSA9IG1lbWJlcnNfMltwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNNZXRob2QgPSAoKHByb3BEYXRhKSkuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTtcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lc1twcm9wTmFtZV0gPSBtZXRob2ROYW1lc1twcm9wTmFtZV0gfHwgaXNNZXRob2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kQ2FjaGUuc2V0KHR5cGUsIG1ldGhvZE5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kTmFtZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzTWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZmluZFBhcmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY2xhc3NNZXRhZGF0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy50cnlTaW1wbGlmeSh0eXBlLCBjbGFzc01ldGFkYXRhWydleHRlbmRzJ10pO1xuICAgICAgICBpZiAocGFyZW50VHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbGNQcm9wZXJ0eVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiaGFzTGlmZWN5Y2xlSG9vayByZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2hpY2ggaXMgbm90IGEgU3RhdGljU3ltYm9sXCIpLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbWV0aG9kTmFtZXModHlwZSlbbGNQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAodHlwZSwgY3Rvcikge1xuICAgICAgICB0aGlzLmNvbnZlcnNpb25NYXAuc2V0KHR5cGUsIGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7IHJldHVybiBuZXcgKGN0b3IuYmluZC5hcHBseShjdG9yLCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuX3JlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwLnNldCh0eXBlLCBmdW5jdGlvbiAoY29udGV4dCwgYXJncykgeyByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5qZWN0aW9uVG9rZW4gPSB0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3Rpb25Ub2tlbicpO1xuICAgICAgICB0aGlzLm9wYXF1ZVRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3BhcXVlVG9rZW4nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3RhYmxlJyksIEluamVjdGFibGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2VsZicpLCBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NraXBTZWxmJyksIFNraXBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0luamVjdCcpLCBJbmplY3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQXR0cmlidXRlJyksIEF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb250ZW50Q2hpbGQnKSwgQ29udGVudENoaWxkKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0NvbnRlbnRDaGlsZHJlbicpLCBDb250ZW50Q2hpbGRyZW4pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnVmlld0NoaWxkJyksIFZpZXdDaGlsZCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdWaWV3Q2hpbGRyZW4nKSwgVmlld0NoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0lucHV0JyksIElucHV0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ091dHB1dCcpLCBPdXRwdXQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnUGlwZScpLCBQaXBlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RCaW5kaW5nJyksIEhvc3RCaW5kaW5nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RMaXN0ZW5lcicpLCBIb3N0TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnRGlyZWN0aXZlJyksIERpcmVjdGl2ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb21wb25lbnQnKSwgQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ05nTW9kdWxlJyksIE5nTW9kdWxlKTtcbiAgICAgICAgLy8gTm90ZTogU29tZSBtZXRhZGF0YSBjbGFzc2VzIGNhbiBiZSB1c2VkIGRpcmVjdGx5IHdpdGggUHJvdmlkZXIuZGVwcy5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTZWxmJyksIFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2tpcFNlbGYnKSwgU2tpcFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyaWdnZXInKSwgdHJpZ2dlcik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3RhdGUnKSwgc3RhdGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyYW5zaXRpb24nKSwgdHJhbnNpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3R5bGUnKSwgc3R5bGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2FuaW1hdGUnKSwgYW5pbWF0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAna2V5ZnJhbWVzJyksIGtleWZyYW1lcyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc2VxdWVuY2UnKSwgc2VxdWVuY2UpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2dyb3VwJyksIGdyb3VwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHR5cGUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGNvbnRleHQsIHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JSZWNvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyKGVycm9yLCAoY29udGV4dCAmJiBjb250ZXh0LmZpbGVQYXRoKSB8fCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGlmeSBidXQgZGlzY2FyZCBhbnkgZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS50cnlTaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbFJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoZXJyb3IsIGZpbGVOYW1lKSB7IH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuc2ltcGxpZnkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBvcmlnaW5hbFJlY29yZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZSA9IEJpbmRpbmdTY29wZS5lbXB0eTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FsbGluZyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGVwdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc2VsZi5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGZ1bmN0aW9uU3ltYm9sXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHRhcmdldEZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5Q2FsbChmdW5jdGlvblN5bWJvbCwgdGFyZ2V0RnVuY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RnVuY3Rpb24gJiYgdGFyZ2V0RnVuY3Rpb25bJ19fc3ltYm9saWMnXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsaW5nLmdldChmdW5jdGlvblN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLnNldChmdW5jdGlvblN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZV8xID0gdGFyZ2V0RnVuY3Rpb25bJ3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSAmJiAoZGVwdGggIT0gMCB8fCB2YWx1ZV8xLl9fc3ltYm9saWMgIT0gJ2Vycm9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzID0gdGFyZ2V0RnVuY3Rpb25bJ3BhcmFtZXRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWZhdWx0cyA9IHRhcmdldEZ1bmN0aW9uLmRlZmF1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBhcmcsIGRlcHRoICsgMSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2hvdWxkSWdub3JlKGFyZykgPyB1bmRlZmluZWQgOiBhcmc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5sZW5ndGggPiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgZGVmYXVsdHMuc2xpY2UoYXJncy5sZW5ndGgpLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdW5jdGlvblNjb3BlID0gQmluZGluZ1Njb3BlLmJ1aWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25TY29wZS5kZWZpbmUocGFyYW1ldGVyc1tpXSwgYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBmdW5jdGlvblNjb3BlLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEgPSBzaW1wbGlmeUluQ29udGV4dChmdW5jdGlvblN5bWJvbCwgdmFsdWVfMSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gb2xkU2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmcuZGVsZXRlKGZ1bmN0aW9uU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVwdGggaXMgMCB3ZSBhcmUgZXZhbHVhdGluZyB0aGUgdG9wIGxldmVsIGV4cHJlc3Npb24gdGhhdCBpcyBkZXNjcmliaW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjb3JhdG9yLiBJbiB0aGlzIGNhc2UsIGl0IGlzIGEgZGVjb3JhdG9yIHdlIGRvbid0IHVuZGVyc3RhbmQsIHN1Y2ggYXMgYSBjdXN0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWFuZ3VsYXIgZGVjb3JhdG9yLCBhbmQgd2Ugc2hvdWxkIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkoeyBfX3N5bWJvbGljOiAnZXJyb3InLCBtZXNzYWdlOiAnRnVuY3Rpb24gY2FsbCBub3Qgc3VwcG9ydGVkJywgY29udGV4dDogZnVuY3Rpb25TeW1ib2wgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gc2ltcGxpZnkoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gKChleHByZXNzaW9uKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNwcmVhZCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLl9fc3ltYm9saWMgPT09ICdzcHJlYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ByZWFkQXJyYXkgPSBzaW1wbGlmeShpdGVtLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwcmVhZEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIHNwcmVhZEFycmF5XzEgPSBzcHJlYWRBcnJheTsgX2IgPCBzcHJlYWRBcnJheV8xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcmVhZEl0ZW0gPSBzcHJlYWRBcnJheV8xW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2goc3ByZWFkSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVfMiA9IHNpbXBsaWZ5KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZSh2YWx1ZV8yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzIucHVzaCh2YWx1ZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3Agc2ltcGxpZmljYXRpb24gYXQgYnVpbHRpbiBzeW1ib2xzXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSBzZWxmLmluamVjdGlvblRva2VuIHx8IGV4cHJlc3Npb24gPT09IHNlbGYub3BhcXVlVG9rZW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udmVyc2lvbk1hcC5oYXMoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2xhcmF0aW9uVmFsdWUgPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KHN0YXRpY1N5bWJvbCwgZGVjbGFyYXRpb25WYWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25bJ19fc3ltYm9saWMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydfX3N5bWJvbGljJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiaW5vcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnQgPSBzaW1wbGlmeShleHByZXNzaW9uWydsZWZ0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKGxlZnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsncmlnaHQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUocmlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb25bJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAmJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCBeIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA9PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZGl0aW9uID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnY29uZGl0aW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gc2ltcGxpZnkoZXhwcmVzc2lvblsndGhlbkV4cHJlc3Npb24nXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxpZnkoZXhwcmVzc2lvblsnZWxzZUV4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmFuZCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ29wZXJhbmQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUob3BlcmFuZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB+b3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4VGFyZ2V0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBzaW1wbGlmeShleHByZXNzaW9uWydpbmRleCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VGFyZ2V0ICYmIGlzUHJpbWl0aXZlKGluZGV4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlciA9IGV4cHJlc3Npb25bJ21lbWJlciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0VGFyZ2V0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFRhcmdldCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IHNlbGVjdFRhcmdldC5tZW1iZXJzLmNvbmNhdChtZW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29udGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRTdGF0aWNTeW1ib2woc2VsZWN0VGFyZ2V0LmZpbGVQYXRoLCBzZWxlY3RUYXJnZXQubmFtZSwgbWVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHNlbGVjdENvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoc2VsZWN0Q29udGV4dCwgZGVjbGFyYXRpb25WYWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgJiYgaXNQcmltaXRpdmUobWVtYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChzZWxlY3RDb250ZXh0LCBzZWxlY3RUYXJnZXRbbWVtYmVyXSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGhhcyB0byBkZWFsIHdpdGggdmFyaWFibGUgcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgc3ltYm9sIHJlZmVyZW5jZXMgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIFN0YXRpY1N5bWJvbHMgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgU3RhdGljU3ltYm9sUmVzb2x2ZXIhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBleHByZXNzaW9uWyduYW1lJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsVmFsdWUgPSBzY29wZS5yZXNvbHZlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxWYWx1ZSAhPSBCaW5kaW5nU2NvcGUubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2FsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZnVuY3Rpb24gaXMgYSBidWlsdC1pbiBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N5bWJvbCA9IHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBzdGF0aWNTeW1ib2wgPT09IHNlbGYub3BhcXVlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzb21lYm9keSBjYWxscyBuZXcgSW5qZWN0aW9uVG9rZW4sIGRvbid0IGNyZWF0ZSBhbiBJbmplY3Rpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgcmF0aGVyIHJldHVybiB0aGUgc3ltYm9sIHRvIHdoaWNoIHRoZSBJbmplY3Rpb25Ub2tlbiBpcyBhc3NpZ25lZCB0by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ0V4cHJlc3Npb25zID0gZXhwcmVzc2lvblsnYXJndW1lbnRzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBzZWxmLmNvbnZlcnNpb25NYXAuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGFyZ0V4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBhcmcsIGRlcHRoICsgMSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2hvdWxkSWdub3JlKGFyZykgPyB1bmRlZmluZWQgOiBhcmc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZ1bmN0aW9uIGlzIG9uZSB3ZSBjYW4gc2ltcGxpZnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0RnVuY3Rpb24gPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlDYWxsKHN0YXRpY1N5bWJvbCwgdGFyZ2V0RnVuY3Rpb24sIGFyZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IHByb2R1Y2VFcnJvck1lc3NhZ2UoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWydsaW5lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKyBcIiAocG9zaXRpb24gXCIgKyAoZXhwcmVzc2lvblsnbGluZSddICsgMSkgKyBcIjpcIiArIChleHByZXNzaW9uWydjaGFyYWN0ZXInXSArIDEpICsgXCIgaW4gdGhlIG9yaWdpbmFsIC50cyBmaWxlKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXBvcnRFcnJvcihwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgY29udGV4dC5maWxlUGF0aCwgZXhwcmVzc2lvblsnbGluZSddLCBleHByZXNzaW9uWydjaGFyYWN0ZXInXSksIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXBvcnRFcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwU3RyaW5nTWFwKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkgeyByZXR1cm4gc2ltcGxpZnkodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IGNvbnRleHQubWVtYmVycy5sZW5ndGggPyBcIi5cIiArIGNvbnRleHQubWVtYmVycy5qb2luKCcuJykgOiAnJztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gZS5tZXNzYWdlICsgXCIsIHJlc29sdmluZyBzeW1ib2wgXCIgKyBjb250ZXh0Lm5hbWUgKyBtZW1iZXJzICsgXCIgaW4gXCIgKyBjb250ZXh0LmZpbGVQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChlLmZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHBvc2l0aW9uYWxFcnJvcihtZXNzYWdlLCBlLmZpbGVOYW1lLCBlLmxpbmUsIGUuY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkZWRTaW1wbGlmeUluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydEVycm9yKGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLmVycm9yUmVjb3JkZXIgPyByZWNvcmRlZFNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCAwKSA6XG4gICAgICAgICAgICBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgMCk7XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmUocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmdldFR5cGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHR5cGUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTeW1ib2wgJiYgcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgPyByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSA6XG4gICAgICAgICAgICB7IF9fc3ltYm9saWM6ICdjbGFzcycgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNSZWZsZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGVycm9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHBhbmRlZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICBzd2l0Y2ggKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgY2FzZSAnUmVmZXJlbmNlIHRvIG5vbi1leHBvcnRlZCBjbGFzcyc6XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0LmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlJlZmVyZW5jZSB0byBhIG5vbi1leHBvcnRlZCBjbGFzcyBcIiArIGVycm9yLmNvbnRleHQuY2xhc3NOYW1lICsgXCIuIENvbnNpZGVyIGV4cG9ydGluZyB0aGUgY2xhc3NcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWYXJpYWJsZSBub3QgaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgcmV0dXJuICdPbmx5IGluaXRpYWxpemVkIHZhcmlhYmxlcyBhbmQgY29uc3RhbnRzIGNhbiBiZSByZWZlcmVuY2VkIGJlY2F1c2UgdGhlIHZhbHVlIG9mIHRoaXMgdmFyaWFibGUgaXMgbmVlZGVkIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlcic7XG4gICAgICAgIGNhc2UgJ0Rlc3RydWN0dXJpbmcgbm90IHN1cHBvcnRlZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1JlZmVyZW5jaW5nIGFuIGV4cG9ydGVkIGRlc3RydWN0dXJlZCB2YXJpYWJsZSBvciBjb25zdGFudCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSB0ZW1wbGF0ZSBjb21waWxlci4gQ29uc2lkZXIgc2ltcGxpZnlpbmcgdGhpcyB0byBhdm9pZCBkZXN0cnVjdHVyaW5nJztcbiAgICAgICAgY2FzZSAnQ291bGQgbm90IHJlc29sdmUgdHlwZSc6XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0LnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHJlc29sdmUgdHlwZSBcIiArIGVycm9yLmNvbnRleHQudHlwZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRnVuY3Rpb24gY2FsbCBub3Qgc3VwcG9ydGVkJzpcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5uYW1lID8gXCJDYWxsaW5nIGZ1bmN0aW9uICdcIiArIGVycm9yLmNvbnRleHQubmFtZSArIFwiJywgZlwiIDogJ0YnO1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArXG4gICAgICAgICAgICAgICAgJ3VuY3Rpb24gY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQuIENvbnNpZGVyIHJlcGxhY2luZyB0aGUgZnVuY3Rpb24gb3IgbGFtYmRhIHdpdGggYSByZWZlcmVuY2UgdG8gYW4gZXhwb3J0ZWQgZnVuY3Rpb24nO1xuICAgICAgICBjYXNlICdSZWZlcmVuY2UgdG8gYSBsb2NhbCBzeW1ib2wnOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVmZXJlbmNlIHRvIGEgbG9jYWwgKG5vbi1leHBvcnRlZCkgc3ltYm9sICdcIiArIGVycm9yLmNvbnRleHQubmFtZSArIFwiJy4gQ29uc2lkZXIgZXhwb3J0aW5nIHRoZSBzeW1ib2xcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlcnJvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcHJvZHVjZUVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiBcIkVycm9yIGVuY291bnRlcmVkIHJlc29sdmluZyBzeW1ib2wgdmFsdWVzIHN0YXRpY2FsbHkuIFwiICsgZXhwYW5kZWRNZXNzYWdlKGVycm9yKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSB0cmFuc2Zvcm1cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1hcFN0cmluZ01hcChpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0cmFuc2Zvcm0oaW5wdXRba2V5XSwga2V5KTtcbiAgICAgICAgaWYgKCFzaG91bGRJZ25vcmUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoSElEREVOX0tFWS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gb1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUobykge1xuICAgIHJldHVybiBvID09PSBudWxsIHx8ICh0eXBlb2YgbyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbyAhPT0gJ29iamVjdCcpO1xufVxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEJpbmRpbmdTY29wZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ1Njb3BlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nU2NvcGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZpbmU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuc2l6ZSA+IDAgPyBuZXcgUG9wdWxhdGVkU2NvcGUoY3VycmVudCkgOiBCaW5kaW5nU2NvcGUuZW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1Njb3BlO1xufSgpKTtcbkJpbmRpbmdTY29wZS5taXNzaW5nID0ge307XG5CaW5kaW5nU2NvcGUuZW1wdHkgPSB7IHJlc29sdmU6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBCaW5kaW5nU2NvcGUubWlzc2luZzsgfSB9O1xudmFyIFBvcHVsYXRlZFNjb3BlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9wdWxhdGVkU2NvcGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiaW5kaW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvcHVsYXRlZFNjb3BlKGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQb3B1bGF0ZWRTY29wZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzLmhhcyhuYW1lKSA/IHRoaXMuYmluZGluZ3MuZ2V0KG5hbWUpIDogQmluZGluZ1Njb3BlLm1pc3Npbmc7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdWxhdGVkU2NvcGU7XG59KEJpbmRpbmdTY29wZSkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAqIEBwYXJhbSB7P30gbGluZVxuICogQHBhcmFtIHs/fSBjb2x1bW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uYWxFcnJvcihtZXNzYWdlLCBmaWxlTmFtZSwgbGluZSwgY29sdW1uKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICgocmVzdWx0KSkuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAoKHJlc3VsdCkpLmxpbmUgPSBsaW5lO1xuICAgICgocmVzdWx0KSkuY29sdW1uID0gY29sdW1uO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUmVzb2x2ZWRTdGF0aWNTeW1ib2wgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVkU3RhdGljU3ltYm9sKHN5bWJvbCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc29sdmVkU3RhdGljU3ltYm9sO1xufSgpKTtcbnZhciBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT04gPSAzO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIG1ldGFkYXRhIHBlciBzeW1ib2wsXG4gKiBhbmQgbm9ybWFsaXppbmcgcmVmZXJlbmNlcyBiZXR3ZWVuIHN5bWJvbHMuXG4gKlxuICogSW50ZXJuYWxseSwgaXQgb25seSB1c2VzIHN5bWJvbHMgd2l0aG91dCBtZW1iZXJzLFxuICogYW5kIGRlZHVjZXMgdGhlIHZhbHVlcyBmb3Igc3ltYm9scyB3aXRoIG1lbWJlcnMgYmFzZWRcbiAqIG9uIHRoZXNlIHN5bWJvbHMuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2xSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xDYWNoZVxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/PX0gZXJyb3JSZWNvcmRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRpY1N5bWJvbFJlc29sdmVyKGhvc3QsIHN0YXRpY1N5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIsIGVycm9yUmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xDYWNoZSA9IHN0YXRpY1N5bWJvbENhY2hlO1xuICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlciA9IHN1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlc29sdmVkU3ltYm9scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbXBvcnRBcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xSZXNvdXJjZVBhdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN5bWJvbEZyb21GaWxlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTeW1ib2wgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIGlmIChzdGF0aWNTeW1ib2wubWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVN5bWJvbE1lbWJlcnMoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnJlc29sdmVkU3ltYm9scy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9yZXNvbHZlU3ltYm9sRnJvbVN1bW1hcnkoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLiBTbyB3ZSBhbHdheXMgbmVlZCB0byBjaGVjayBib3RoLCB0aGUgc3VtbWFyeVxuICAgICAgICAvLyBhbmQgbWV0YWRhdGEuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbHNPZihzdGF0aWNTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc29sdmVkU3ltYm9scy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldEltcG9ydEFzIHByb2R1Y2VzIGEgc3ltYm9sIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBnaXZlbiBzeW1ib2wuXG4gICAgICogVGhlIGltcG9ydCBtaWdodCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgc3ltYm9sIGlmIHRoZSBzeW1ib2wgaXMgZXhwb3J0ZWQgZnJvbVxuICAgICAqIGEgbGlicmFyeSB3aXRoIGEgc3VtbWFyeTsgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGltcG9ydCB0aGUgc3ltYm9sIGZyb20gdGhlXG4gICAgICogbmdmYWN0b3J5IHJlLWV4cG9ydCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRvIGF2b2lkIGludHJvZHVjaW5nIGEgZGlyZWN0IGRlcGVuZGVuY3lcbiAgICAgKiBvbiBhbiBvdGhlcndpc2UgaW5kaXJlY3QgZGVwZW5kZW5jeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sIHRoZSBzeW1ib2wgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIGEgaW1wb3J0IHN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoc3RhdGljU3ltYm9sLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlU3ltYm9sID0gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlSW1wb3J0QXMgPSB0aGlzLmdldEltcG9ydEFzKGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbXBvcnRBcyA/XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF0aWNTeW1ib2woYmFzZUltcG9ydEFzLmZpbGVQYXRoLCBiYXNlSW1wb3J0QXMubmFtZSwgc3RhdGljU3ltYm9sLm1lbWJlcnMpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuc3VtbWFyeVJlc29sdmVyLmdldEltcG9ydEFzKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRSZXNvdXJjZVBhdGggcHJvZHVjZXMgdGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wgYW5kIHNob3VsZFxuICAgICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWxhdGl2ZSBsb2NhdGlvbiBvZiByZXNvdXJjZSByZWZlcmVuY2VzIHJlY29yZGVkIGluXG4gICAgICogc3ltYm9sIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0UmVzb3VyY2VQYXRoID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xSZXNvdXJjZVBhdGhzLmdldChzdGF0aWNTeW1ib2wpIHx8IHN0YXRpY1N5bWJvbC5maWxlUGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFR5cGVBcml0eSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZ2VuZXJpYyB0eXBlIHBhcmFtZXRlcnMgdGhlIGdpdmVuIHN5bWJvbFxuICAgICAqIGhhcy4gSWYgdGhlIHN5bWJvbCBpcyBub3QgYSB0eXBlIHRoZSByZXN1bHQgaXMgbnVsbC5cbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFR5cGVBcml0eSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgaXMgYSBmYWN0b3J5IGZpbGUsIGRvbid0IHJlc29sdmUgdGhlIHN5bWJvbCBhcyBkb2luZyBzbyB3b3VsZFxuICAgICAgICAvLyBjYXVzZSB0aGUgbWV0YWRhdGEgZm9yIGFuIGZhY3RvcnkgZmlsZSB0byBiZSBsb2FkZWQgd2hpY2ggZG9lc24ndCBleGlzdC5cbiAgICAgICAgLy8gQWxsIHJlZmVyZW5jZXMgdG8gZ2VuZXJhdGVkIGNsYXNzZXMgbXVzdCBpbmNsdWRlIHRoZSBjb3JyZWN0IGFyaXR5IHdoZW5ldmVyXG4gICAgICAgIC8vIGdlbmVyYXRpbmcgY29kZS5cbiAgICAgICAgaWYgKGlzTmdGYWN0b3J5RmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHRoaXMucmVzb2x2ZVN5bWJvbChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB3aGlsZSAocmVzb2x2ZWRTeW1ib2wgJiYgcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJlc29sdmVkU3ltYm9sID0gdGhpcy5yZXNvbHZlU3ltYm9sKHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhLmFyaXR5KSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTeW1ib2xcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlY29yZEltcG9ydEFzID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0aGlzLmltcG9ydEFzLnNldChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIGFsbCBpbmZvcm1hdGlvbiBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lIHRoZSBmaWxlIHRvIGludmFsaWRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5pbnZhbGlkYXRlRmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocy5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xzID0gdGhpcy5zeW1ib2xGcm9tRmlsZS5nZXQoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoc3ltYm9scykge1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZS5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzeW1ib2xzXzEgPSBzeW1ib2xzOyBfaSA8IHN5bWJvbHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkU3ltYm9scy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydEFzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5fcmVzb2x2ZVN5bWJvbE1lbWJlcnMgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBzdGF0aWNTeW1ib2wubWVtYmVycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVJlc29sdmVkU3ltYm9sID0gdGhpcy5yZXNvbHZlU3ltYm9sKHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbC5maWxlUGF0aCwgc3RhdGljU3ltYm9sLm5hbWUpKTtcbiAgICAgICAgaWYgKCFiYXNlUmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VNZXRhZGF0YSA9IGJhc2VSZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgaWYgKGJhc2VNZXRhZGF0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIHRoaXMuZ2V0U3RhdGljU3ltYm9sKGJhc2VNZXRhZGF0YS5maWxlUGF0aCwgYmFzZU1ldGFkYXRhLm5hbWUsIG1lbWJlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiYXNlTWV0YWRhdGEgJiYgYmFzZU1ldGFkYXRhLl9fc3ltYm9saWMgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGlmIChiYXNlTWV0YWRhdGEuc3RhdGljcyAmJiBtZW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCBiYXNlTWV0YWRhdGEuc3RhdGljc1ttZW1iZXJzWzBdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGJhc2VNZXRhZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aCAmJiB2YWx1ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVttZW1iZXJzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9yZXNvbHZlU3ltYm9sRnJvbVN1bW1hcnkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzdGF0aWNTeW1ib2wpO1xuICAgICAgICByZXR1cm4gc3VtbWFyeSA/IG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIHN1bW1hcnkubWV0YWRhdGEpIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHR5cGUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVycyBhIHN5bWJvbCBmb3IgYSBzdGF0aWMgbWVtYmVyIG9mIHRoZSBuYW1lZCB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNTeW1ib2xDYWNoZS5nZXQoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogU29tZSB1c2VycyB1c2UgbGlicmFyaWVzIHRoYXQgd2VyZSBub3QgY29tcGlsZWQgd2l0aCBuZ2MsIGkuZS4gdGhleSBkb24ndFxuICAgICAgICAvLyBoYXZlIHN1bW1hcmllcywgb25seSAuZC50cyBmaWxlcy4gU28gd2UgYWx3YXlzIG5lZWQgdG8gY2hlY2sgYm90aCwgdGhlIHN1bW1hcnlcbiAgICAgICAgLy8gYW5kIG1ldGFkYXRhLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xzID0gbmV3IFNldCh0aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRTeW1ib2xzT2YoZmlsZVBhdGgpKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlU3ltYm9sc09mKGZpbGVQYXRoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbC5zeW1ib2wuZmlsZVBhdGggPT09IGZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9scy5hZGQocmVzb2x2ZWRTeW1ib2wuc3ltYm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN5bWJvbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9jcmVhdGVTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2xzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFkYXRhID0gdGhpcy5nZXRNb2R1bGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVsnbWV0YWRhdGEnXSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGRpcmVjdCBkZWNsYXJhdGlvbnMgb2YgdGhlIHN5bWJvbFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9wTGV2ZWxTeW1ib2xOYW1lc18xID0gbmV3IFNldChPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkubWFwKHVuZXNjYXBlSWRlbnRpZmllcikpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luc18xID0gbWV0YWRhdGFbJ29yaWdpbnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhWydtZXRhZGF0YSddKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRhZGF0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbE1ldGEgPSBtZXRhZGF0YVsnbWV0YWRhdGEnXVttZXRhZGF0YUtleV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihtZXRhZGF0YUtleSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRTeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhWydpbXBvcnRBcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGJ1bmRsZSBpbmRleGVzIHNob3VsZCB1c2UgdGhlIGltcG9ydEFzIG1vZHVsZSBuYW1lIGluc3RlYWQgb2YgYSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIC5kLnRzIGZpbGUgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChtZXRhZGF0YVsnaW1wb3J0QXMnXSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlY29yZEltcG9ydEFzKHN5bWJvbCwgaW1wb3J0U3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luID0gb3JpZ2luc18xLmhhc093blByb3BlcnR5KG1ldGFkYXRhS2V5KSAmJiBvcmlnaW5zXzFbbWV0YWRhdGFLZXldO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN5bWJvbCBpcyBmcm9tIGEgYnVuZGxlZCBpbmRleCwgdXNlIHRoZSBkZWNsYXJhdGlvbiBsb2NhdGlvbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sIHNvIHJlbGF0aXZlIHJlZmVyZW5jZXMgKHN1Y2ggYXMgJy4vbXkuaHRtbCcpIHdpbGwgYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbkZpbGVQYXRoID0gX3RoaXMucmVzb2x2ZU1vZHVsZShvcmlnaW4sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5GaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiQ291bGRuJ3QgcmVzb2x2ZSBvcmlnaW5hbCBzeW1ib2wgZm9yIFwiICsgb3JpZ2luICsgXCIgZnJvbSBcIiArIGZpbGVQYXRoKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW1ib2xSZXNvdXJjZVBhdGhzLnNldChzeW1ib2wsIG9yaWdpbkZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVSZXNvbHZlZFN5bWJvbChzeW1ib2wsIGZpbGVQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzXzEsIHN5bWJvbE1ldGEpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgc3ltYm9scyBpbiBvbmUgb2YgdGhlIHJlLWV4cG9ydCBsb2NhdGlvblxuICAgICAgICBpZiAobWV0YWRhdGFbJ2V4cG9ydHMnXSkge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIGluIHRoZSBsaXN0IG9mIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgc3ltYm9scy5cbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlRXhwb3J0LmV4cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnQuZXhwb3J0LmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSBleHBvcnRTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gZXhwb3J0U3ltYm9sLmFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bU5hbWUgPSBzeW1ib2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRTeW1ib2wgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihleHBvcnRTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZE1vZHVsZSA9IF90aGlzLnJlc29sdmVNb2R1bGUobW9kdWxlRXhwb3J0LmZyb20sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldFN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChyZXNvbHZlZE1vZHVsZSwgc3ltTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgdmlhIGV4cG9ydCAqIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkTW9kdWxlID0gdGhpc18xLnJlc29sdmVNb2R1bGUobW9kdWxlRXhwb3J0LmZyb20sIGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRFeHBvcnRzID0gdGhpc18xLmdldFN5bWJvbHNPZihyZXNvbHZlZE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgdGFyZ2V0U3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3ltYm9scy5wdXNoKF90aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbWV0YWRhdGFbJ2V4cG9ydHMnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlRXhwb3J0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIF9sb29wXzEoLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVFeHBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gX3RoaXMucmVzb2x2ZWRTeW1ib2xzLnNldChyZXNvbHZlZFN5bWJvbC5zeW1ib2wsIHJlc29sdmVkU3ltYm9sKTsgfSk7XG4gICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUuc2V0KGZpbGVQYXRoLCByZXNvbHZlZFN5bWJvbHMubWFwKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gcmVzb2x2ZWRTeW1ib2wuc3ltYm9sOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdG9wTGV2ZWxQYXRoXG4gICAgICogQHBhcmFtIHs/fSB0b3BMZXZlbFN5bWJvbE5hbWVzXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkU3ltYm9sID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdG9wTGV2ZWxQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzLCBtZXRhZGF0YSkge1xuICAgICAgICAvLyBGb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgQW5ndWxhciBzdW1tYXJpZXMgLyBtZXRhZGF0YSxcbiAgICAgICAgLy8gd2Ugb25seSBrZWVwIHRoZWlyIGFyaXR5LCBidXQgbm90aGluZyBlbHNlXG4gICAgICAgIC8vIChlLmcuIHRoZWlyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMpLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIHByZXZlbnQgaW50cm9kdWNpbmcgZGVlcCBpbXBvcnRzXG4gICAgICAgIC8vIGFzIHdlIGRpZG4ndCBnZW5lcmF0ZSAubmdmYWN0b3J5LnRzIGZpbGVzIHdpdGggcHJvcGVyIHJlZXhwb3J0cy5cbiAgICAgICAgaWYgKHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc291cmNlU3ltYm9sLmZpbGVQYXRoKSAmJiBtZXRhZGF0YSAmJlxuICAgICAgICAgICAgbWV0YWRhdGFbJ19fc3ltYm9saWMnXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRNZXRhXzEgPSB7IF9fc3ltYm9saWM6ICdjbGFzcycsIGFyaXR5OiBtZXRhZGF0YS5hcml0eSB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YV8xKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIFJlZmVyZW5jZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWZlcmVuY2VUcmFuc2Zvcm1lciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlZmVyZW5jZVRyYW5zZm9ybWVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZnVuY3Rpb25QYXJhbXNcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJlZmVyZW5jZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGZ1bmN0aW9uUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9saWMgPSBtYXBbJ19fc3ltYm9saWMnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9saWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkTGVuID0gZnVuY3Rpb25QYXJhbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblBhcmFtcy5wdXNoLmFwcGx5KGZ1bmN0aW9uUGFyYW1zLCAobWFwWydwYXJhbWV0ZXJzJ10gfHwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblBhcmFtcy5sZW5ndGggPSBvbGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbGljID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVfMSA9IG1hcFsnbW9kdWxlJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBtYXBbJ25hbWUnXSA/IHVuZXNjYXBlSWRlbnRpZmllcihtYXBbJ25hbWUnXSkgOiBtYXBbJ25hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlUGF0aCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aCA9IHNlbGYucmVzb2x2ZU1vZHVsZShtb2R1bGVfMSwgc291cmNlU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbGljOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCByZXNvbHZlIFwiICsgbW9kdWxlXzEgKyBcIiByZWxhdGl2ZSB0byBcIiArIHNvdXJjZVN5bWJvbC5maWxlUGF0aCArIFwiLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25QYXJhbXMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9fc3ltYm9saWM6ICdyZWZlcmVuY2UnLCBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wTGV2ZWxTeW1ib2xOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2wodG9wTGV2ZWxQYXRoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFtYmllbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBmdW5jdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWZlcmVuY2VUcmFuc2Zvcm1lcjtcbiAgICAgICAgfShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkTWV0YSA9IHZpc2l0VmFsdWUobWV0YWRhdGEsIG5ldyBSZWZlcmVuY2VUcmFuc2Zvcm1lcigpLCBbXSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZE1ldGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlRXhwb3J0ID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhc2UgaXMgZm9yIGFuIG5nIGxpYnJhcnkgaW1wb3J0aW5nIHN5bWJvbHMgZnJvbSBhIHBsYWluIHRzIGxpYnJhcnlcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpdmVseS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIHJlbHkgb24gdGhlIGZhY3QgdGhhdCB3ZSBkaXNjb3ZlciBzeW1ib2xzIGluIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIC8vIGZyb20gc291cmNlIGZpbGVzIHRvIGxpYnJhcnkgZmlsZXNcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0QXMuc2V0KHRhcmdldFN5bWJvbCwgdGhpcy5nZXRJbXBvcnRBcyhzb3VyY2VTeW1ib2wpIHx8IHNvdXJjZVN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBjb250ZXh0LCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlcihlcnJvciwgKGNvbnRleHQgJiYgY29udGV4dC5maWxlUGF0aCkgfHwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGUgYW4gYWJzb2x1dGUgcGF0aCB0byBhIG1vZHVsZSBmaWxlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldE1vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXQobW9kdWxlKTtcbiAgICAgICAgaWYgKCFtb2R1bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YWRhdGFzID0gdGhpcy5ob3N0LmdldE1ldGFkYXRhRm9yKG1vZHVsZSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlTWV0YWRhdGFzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF4VmVyc2lvbl8xID0gLTE7XG4gICAgICAgICAgICAgICAgbW9kdWxlTWV0YWRhdGFzLmZvckVhY2goZnVuY3Rpb24gKG1kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZFsndmVyc2lvbiddID4gbWF4VmVyc2lvbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhWZXJzaW9uXzEgPSBtZFsndmVyc2lvbiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlTWV0YWRhdGEgPSBtZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb2R1bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICAgICAgeyBfX3N5bWJvbGljOiAnbW9kdWxlJywgdmVyc2lvbjogU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OLCBtb2R1bGU6IG1vZHVsZSwgbWV0YWRhdGE6IHt9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSAhPSBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1lc3NhZ2UgPSBtb2R1bGVNZXRhZGF0YVsndmVyc2lvbiddID09IDIgP1xuICAgICAgICAgICAgICAgICAgICBcIlVuc3VwcG9ydGVkIG1ldGFkYXRhIHZlcnNpb24gXCIgKyBtb2R1bGVNZXRhZGF0YVsndmVyc2lvbiddICsgXCIgZm9yIG1vZHVsZSBcIiArIG1vZHVsZSArIFwiLiBUaGlzIG1vZHVsZSBzaG91bGQgYmUgY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgbmdjXCIgOlxuICAgICAgICAgICAgICAgICAgICBcIk1ldGFkYXRhIHZlcnNpb24gbWlzbWF0Y2ggZm9yIG1vZHVsZSBcIiArIG1vZHVsZSArIFwiLCBmb3VuZCB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiLCBleHBlY3RlZCBcIiArIFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5zZXQobW9kdWxlLCBtb2R1bGVNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZU1ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbE5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBjb250YWluaW5nRmlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbEJ5TW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgc3ltYm9sTmFtZSwgY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGggPSB0aGlzLnJlc29sdmVNb2R1bGUobW9kdWxlLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgbW9kdWxlIFwiICsgbW9kdWxlICsgKGNvbnRhaW5pbmdGaWxlID8gXCIgcmVsYXRpdmUgdG8gJCB7XFxuICAgICAgICAgICAgY29udGFpbmluZ0ZpbGVcXG4gICAgICAgICAgfSBcIiA6ICcnKSksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljU3ltYm9sKFwiRVJST1I6XCIgKyBtb2R1bGUsIHN5bWJvbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgc3ltYm9sTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmluZ0ZpbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvc3QubW9kdWxlTmFtZVRvRmlsZU5hbWUobW9kdWxlLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBtb2R1bGUgJ1wiICsgbW9kdWxlICsgXCInIHJlbGF0aXZlIHRvIGZpbGUgXCIgKyBjb250YWluaW5nRmlsZSk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGUsIG51bGwsIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbFJlc29sdmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB1bmVzY2FwZUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoJ19fXycpID8gaWRlbnRpZmllci5zdWJzdHIoMSkgOiBpZGVudGlmaWVyO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFvdFN1bW1hcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFvdFN1bW1hcnlSZXNvbHZlcihob3N0LCBzdGF0aWNTeW1ib2xDYWNoZSkge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnN0YXRpY1N5bWJvbENhY2hlID0gc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuc3VtbWFyeUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvYWRlZEZpbGVQYXRocyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbXBvcnRBcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5pc0xpYnJhcnlGaWxlID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gc3RyaXAgdGhlIC5uZ2ZhY3RvcnkuIGZpbGUgcGF0aCxcbiAgICAgICAgLy8gc28gdGhpcyBtZXRob2QgYWxzbyB3b3JrcyBmb3IgZ2VuZXJhdGVkIGZpbGVzXG4gICAgICAgIC8vIChmb3Igd2hpY2ggaG9zdC5pc1NvdXJjZUZpbGUgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlKS5cbiAgICAgICAgcmV0dXJuICF0aGlzLmhvc3QuaXNTb3VyY2VGaWxlKHN0cmlwTmdGYWN0b3J5KGZpbGVQYXRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldExpYnJhcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkgeyByZXR1cm4gdGhpcy5ob3N0LmdldE91dHB1dEZpbGVOYW1lKGZpbGVQYXRoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgc3RhdGljU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5Q2FjaGUuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmICghc3VtbWFyeSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFN1bW1hcnlGaWxlKHN0YXRpY1N5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgICAgICBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5Q2FjaGUuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB0aGlzLl9sb2FkU3VtbWFyeUZpbGUoZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1bW1hcnlDYWNoZS5rZXlzKCkpLmZpbHRlcihmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBzeW1ib2wuZmlsZVBhdGggPT09IGZpbGVQYXRoOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBzdGF0aWNTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFN1bW1hcnlGaWxlID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZEZpbGVQYXRocy5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWRGaWxlUGF0aHMuYWRkKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNMaWJyYXJ5RmlsZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlGaWxlUGF0aCA9IHN1bW1hcnlGaWxlTmFtZShmaWxlUGF0aCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBqc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gdGhpcy5ob3N0LmxvYWRTdW1tYXJ5KHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN1bW1hcnkgZmlsZSBcIiArIHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZGVzZXJpYWxpemVTdW1tYXJpZXModGhpcy5zdGF0aWNTeW1ib2xDYWNoZSwganNvbiksIHN1bW1hcmllcyA9IF9hLnN1bW1hcmllcywgaW1wb3J0QXMgPSBfYS5pbXBvcnRBcztcbiAgICAgICAgICAgICAgICBzdW1tYXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VtbWFyeSkgeyByZXR1cm4gX3RoaXMuc3VtbWFyeUNhY2hlLnNldChzdW1tYXJ5LnN5bWJvbCwgc3VtbWFyeSk7IH0pO1xuICAgICAgICAgICAgICAgIGltcG9ydEFzLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydEFzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmltcG9ydEFzLnNldChpbXBvcnRBcy5zeW1ib2wsIF90aGlzLnN0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChmaWxlUGF0aCksIGltcG9ydEFzLmltcG9ydEFzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBb3RTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFvdENvbXBpbGVyIGJhc2VkIG9uIG9wdGlvbnMgYW5kIGEgaG9zdC5cbiAqIEBwYXJhbSB7P30gY29tcGlsZXJIb3N0XG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFvdENvbXBpbGVyKGNvbXBpbGVySG9zdCwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0aW9ucyA9IG9wdGlvbnMudHJhbnNsYXRpb25zIHx8ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybFJlc29sdmVyID0gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbENhY2hlID0gbmV3IFN0YXRpY1N5bWJvbENhY2hlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xSZXNvbHZlciA9IG5ldyBTdGF0aWNTeW1ib2xSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1JlZmxlY3RvciA9IG5ldyBTdGF0aWNSZWZsZWN0b3Ioc3VtbWFyeVJlc29sdmVyLCBzeW1ib2xSZXNvbHZlcik7XG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW5zdGFsbChzdGF0aWNSZWZsZWN0b3IpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnNvbGUgPSBuZXcgybVDb25zb2xlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbFBhcnNlciA9IG5ldyBJMThOSHRtbFBhcnNlcihuZXcgSHRtbFBhcnNlcigpLCB0cmFuc2xhdGlvbnMsIG9wdGlvbnMuaTE4bkZvcm1hdCwgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZywgY29uc29sZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICB1c2VKaXQ6IGZhbHNlLFxuICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogb3B0aW9ucy5lbmFibGVMZWdhY3lUZW1wbGF0ZSAhPT0gZmFsc2UsXG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBjb21waWxlckhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvblBhcnNlciA9IG5ldyBQYXJzZXIobmV3IExleGVyKCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0bXBsUGFyc2VyID0gbmV3IFRlbXBsYXRlUGFyc2VyKGNvbmZpZywgZXhwcmVzc2lvblBhcnNlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBodG1sUGFyc2VyLCBjb25zb2xlLCBbXSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZXIgPSBuZXcgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoY29uZmlnLCBuZXcgTmdNb2R1bGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgRGlyZWN0aXZlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IFBpcGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBzdW1tYXJ5UmVzb2x2ZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgbm9ybWFsaXplciwgY29uc29sZSwgc3ltYm9sQ2FjaGUsIHN0YXRpY1JlZmxlY3Rvcik7XG4gICAgLy8gVE9ETyh2aWNiKTogZG8gbm90IHBhc3Mgb3B0aW9ucy5pMThuRm9ybWF0IGhlcmVcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRSZXNvbHZlciA9IHtcbiAgICAgICAgZ2V0SW1wb3J0QXM6IGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIHN5bWJvbFJlc29sdmVyLmdldEltcG9ydEFzKHN5bWJvbCk7IH0sXG4gICAgICAgIGZpbGVOYW1lVG9Nb2R1bGVOYW1lOiBmdW5jdGlvbiAoZmlsZU5hbWUsIGNvbnRhaW5pbmdGaWxlUGF0aCkgeyByZXR1cm4gY29tcGlsZXJIb3N0LmZpbGVOYW1lVG9Nb2R1bGVOYW1lKGZpbGVOYW1lLCBjb250YWluaW5nRmlsZVBhdGgpOyB9LFxuICAgICAgICBnZXRUeXBlQXJpdHk6IGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIHN5bWJvbFJlc29sdmVyLmdldFR5cGVBcml0eShzeW1ib2wpOyB9XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q29tcGlsZXIgPSBuZXcgVmlld0NvbXBpbGVyKGNvbmZpZywgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlciA9IG5ldyBBb3RDb21waWxlcihjb25maWcsIGNvbXBpbGVySG9zdCwgcmVzb2x2ZXIsIHRtcGxQYXJzZXIsIG5ldyBTdHlsZUNvbXBpbGVyKHVybFJlc29sdmVyKSwgdmlld0NvbXBpbGVyLCBuZXcgTmdNb2R1bGVDb21waWxlcigpLCBuZXcgVHlwZVNjcmlwdEVtaXR0ZXIoaW1wb3J0UmVzb2x2ZXIpLCBzdW1tYXJ5UmVzb2x2ZXIsIG9wdGlvbnMubG9jYWxlLCBvcHRpb25zLmkxOG5Gb3JtYXQsIG9wdGlvbnMuZ2VuRmlsZVByZWFtYmxlLCBzeW1ib2xSZXNvbHZlcik7XG4gICAgcmV0dXJuIHsgY29tcGlsZXI6IGNvbXBpbGVyLCByZWZsZWN0b3I6IHN0YXRpY1JlZmxlY3RvciB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEBwYXJhbSB7P30gcmVzdWx0VmFyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCByZXN1bHRWYXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdHNXaXRoUmV0dXJuID0gc3RhdGVtZW50cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihyZXN1bHRWYXJzLm1hcChmdW5jdGlvbiAocmVzdWx0VmFyKSB7IHJldHVybiB2YXJpYWJsZShyZXN1bHRWYXIpOyB9KSkpXSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KG51bGwsIG51bGwsIG51bGwsIG5ldyBNYXAoKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBTdGF0ZW1lbnRJbnRlcnByZXRlcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzV2l0aFJldHVybiwgY3R4KTtcbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgPyByZXN1bHQudmFsdWUgOiBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhck5hbWVzXG4gKiBAcGFyYW0gez99IHZhclZhbHVlc1xuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgdmFyVmFsdWVzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRDdHgudmFycy5zZXQodmFyTmFtZXNbaV0sIHZhclZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGNoaWxkQ3R4KTtcbiAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbn1cbnZhciBfRXhlY3V0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfRXhlY3V0aW9uQ29udGV4dChwYXJlbnQsIGluc3RhbmNlLCBjbGFzc05hbWUsIHZhcnMpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfRXhlY3V0aW9uQ29udGV4dCh0aGlzLCB0aGlzLmluc3RhbmNlLCB0aGlzLmNsYXNzTmFtZSwgbmV3IE1hcCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBfRXhlY3V0aW9uQ29udGV4dDtcbn0oKSk7XG52YXIgUmV0dXJuVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSZXR1cm5WYWx1ZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gX2NsYXNzU3RtdFxuICogQHBhcmFtIHs/fSBfY3R4XG4gKiBAcGFyYW0gez99IF92aXNpdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljQ2xhc3MoX2NsYXNzU3RtdCwgX2N0eCwgX3Zpc2l0b3IpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0eURlc2NyaXB0b3JzID0ge307XG4gICAgX2NsYXNzU3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikge1xuICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbZ2V0dGVyLm5hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoW10sIFtdLCBnZXR0ZXIuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBfY2xhc3NTdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZXMgPSBtZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbbWV0aG9kLm5hbWVdID0ge1xuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMocGFyYW1OYW1lcywgYXJncywgbWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvclBhcmFtTmFtZXMgPSBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgIF9jbGFzc1N0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IF90aGlzW2ZpZWxkLm5hbWVdID0gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoY3RvclBhcmFtTmFtZXMsIGFyZ3MsIF9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1cGVyQ2xhc3MgPSBfY2xhc3NTdG10LnBhcmVudCA/IF9jbGFzc1N0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbihfdmlzaXRvciwgX2N0eCkgOiBPYmplY3Q7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlLCBwcm9wZXJ0eURlc2NyaXB0b3JzKTtcbiAgICByZXR1cm4gY3Rvcjtcbn1cbnZhciBTdGF0ZW1lbnRJbnRlcnByZXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUuZGVidWdBc3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICB3aGlsZSAoY3VyckN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY3VyckN0eC52YXJzLnNldChleHByLm5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyQ3R4ID0gY3VyckN0eC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgZXhwci5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICB3aGlsZSAoY3VyckN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyh2YXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9IGN1cnJDdHgucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBkZWNsYXJlZCB2YXJpYWJsZSBcIiArIHZhck5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmVjZWl2ZXJbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmVjZWl2ZXJbZXhwci5uYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICBpZiAoZXhwci5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jb25jYXQuYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuc3Vic2NyaWJlKHsgbmV4dDogYXJnc1swXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQuYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kIFwiICsgZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyW2V4cHIubmFtZV0uYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKHN0bXQuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5FeHByID0gc3RtdC5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICBjdHguaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KGN0eC5pbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuJCQxID0gc3RtdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBmbiQkMS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmV0dXJuVmFsdWUoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhenogPSBjcmVhdGVEeW5hbWljQ2xhc3Moc3RtdCwgY3R4LCB0aGlzKTtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgY2xhenopO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQyLCBlKTtcbiAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX1NUQUNLX1ZBUiQyLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXp6ID0gYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG5ldyAoY2xhenouYmluZC5hcHBseShjbGF6eiwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBhc3QudmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5mYWxzZUNhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAhYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1OYW1lcyA9IGFzdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIHJldHVybiBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIGFzdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZXMgPSBzdG10LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBzdG10LnN0YXRlbWVudHMsIGN0eCwgdGhpcykpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0LnJocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAmJiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIHx8IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSArIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAvIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAlIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPCByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDw9IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID4gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPj0gcmhzKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbYXN0Lm5hbWVdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3AgPSBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcltwcm9wXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHt9O1xuICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gKChyZXN1bHQpKVtlbnRyeS5rZXldID0gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRzLCBjdHgpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZW1lbnRJbnRlcnByZXRlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFyTmFtZXNcbiAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIGFyZ3MsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7XG4gICAgfTtcbn1cbnZhciBDQVRDSF9FUlJPUl9WQVIkMiA9ICdlcnJvcic7XG52YXIgQ0FUQ0hfU1RBQ0tfVkFSJDIgPSAnc3RhY2snO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgaWYgKHN0bXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFwiKTtcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIucHJvdG90eXBlKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2Qoc3RtdCwgbWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGdldHRlclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKHN0bXQsIGdldHRlciwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiICsgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLCAnXCIgKyBnZXR0ZXIubmFtZSArIFwiJywgeyBnZXQ6IGZ1bmN0aW9uKCkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAoZ2V0dGVyLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn19KTtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKHN0bXQsIG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAobWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn07XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnc2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwidmFyIFwiICsgc3RtdC5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkV4cHIgPSBleHByLmZuO1xuICAgICAgICBpZiAoZm5FeHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIGN0eC5jdXJyZW50Q2xhc3MucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLmNhbGwodGhpc1wiKTtcbiAgICAgICAgICAgIGlmIChleHByLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIiwgXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByLmNhbGwodGhpcywgZXhwciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJmdW5jdGlvbihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKGFzdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcInRyeSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifSBjYXRjaCAoXCIgKyBDQVRDSF9FUlJPUl9WQVIkMS5uYW1lICsgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2F0Y2hTdG10cyA9IFsvKiogQHR5cGUgez99ICovIChDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKSldLmNvbmNhdChzdG10LmNhdGNoU3RtdHMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGN0eCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGN0eC5wcmludChudWxsLCBwYXJhbS5uYW1lKTsgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gc291cmNlVXJsXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSB2YXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwkJDEsIGN0eCwgdmFycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuQm9keSA9IGN0eC50b1NvdXJjZSgpICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsJCQxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuQXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkFyZ1ZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICB9XG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgIC8vIHVzaW5nIGBuZXcgRnVuY3Rpb24oLi4uKWAgZ2VuZXJhdGVzIGEgaGVhZGVyLCAxIGxpbmUgb2Ygbm8gYXJndW1lbnRzLCAyIGxpbmVzIG90aGVyd2lzZVxuICAgICAgICAvLyBFLmcuIGBgYFxuICAgICAgICAvLyBmdW5jdGlvbiBhbm9ueW1vdXMoYSxiLGNcbiAgICAgICAgLy8gLyoqLykgeyAuLi4gfWBgYFxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhcmQgY29kZSB0aGlzIGZhY3QsIHNvIHdlIGF1dG8gZGV0ZWN0IGl0IHZpYSBhbiBlbXB0eSBmdW5jdGlvbiBmaXJzdC5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW1wdHlGbiA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KCdyZXR1cm4gbnVsbDsnKSkpKSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhlYWRlckxpbmVzID0gZW1wdHlGbi5zbGljZSgwLCBlbXB0eUZuLmluZGV4T2YoJ3JldHVybiBudWxsOycpKS5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMTtcbiAgICAgICAgZm5Cb2R5ICs9IFwiXFxuXCIgKyBjdHgudG9Tb3VyY2VNYXBHZW5lcmF0b3Ioc291cmNlVXJsJCQxLCBzb3VyY2VVcmwkJDEsIGhlYWRlckxpbmVzKS50b0pzQ29tbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSkpKSgpLmFwcGx5KHZvaWQgMCwgZm5BcmdWYWx1ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVVybFxuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcGFyYW0gez99IHJlc3VsdFZhcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGppdFN0YXRlbWVudHMoc291cmNlVXJsJCQxLCBzdGF0ZW1lbnRzLCByZXN1bHRWYXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gbmV3IEppdEVtaXR0ZXJWaXNpdG9yKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QocmVzdWx0VmFycyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmV0dXJuU3RtdCA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihyZXN1bHRWYXJzLm1hcChmdW5jdGlvbiAocmVzdWx0VmFyKSB7IHJldHVybiB2YXJpYWJsZShyZXN1bHRWYXIpOyB9KSkpO1xuICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cy5jb25jYXQoW3JldHVyblN0bXRdKSwgY3R4KTtcbiAgICByZXR1cm4gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsJCQxLCBjdHgsIGNvbnZlcnRlci5nZXRBcmdzKCkpO1xufVxudmFyIEppdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSml0RW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX2V2YWxBcmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRBcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuX2V2YWxBcmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuX2V2YWxBcmdOYW1lc1tpXV0gPSB0aGlzLl9ldmFsQXJnVmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIGlmIChpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IGlkZW50aWZpZXJOYW1lKGFzdC52YWx1ZSkgfHwgJ3ZhbCc7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMucHVzaChcImppdF9cIiArIG5hbWUgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgdGhpcy5fZXZhbEFyZ05hbWVzW2lkXSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEppdEVtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW50ZXJuYWwgbW9kdWxlIG9mIHRoZSBBbmd1bGFyIGNvbXBpbGVyIHRoYXQgYmVnaW5zIHdpdGggY29tcG9uZW50IHR5cGVzLFxuICogZXh0cmFjdHMgdGVtcGxhdGVzLCBhbmQgZXZlbnR1YWxseSBwcm9kdWNlcyBhIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICogcmVhZHkgZm9yIGxpbmtpbmcgaW50byBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBcXEBzZWN1cml0eSBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3QgZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lc1xuICogZnJvbSBhIHRydXN0ZWQgc291cmNlLiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuICBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gKi9cbnZhciBKaXRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IF9tZXRhZGF0YVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfdGVtcGxhdGVQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9zdHlsZUNvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX2NvbXBpbGVyQ29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBfY29uc29sZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEppdENvbXBpbGVyKF9pbmplY3RvciwgX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF9uZ01vZHVsZUNvbXBpbGVyLCBfY29tcGlsZXJDb25maWcsIF9jb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fY29tcGlsZXJDb25maWcgPSBfY29tcGlsZXJDb25maWc7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaGFyZWRTdHlsZXNoZWV0Q291bnQgPSAwO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSml0Q29tcGlsZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpLnN5bmNSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkuYXN5bmNSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKS5zeW5jUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzKG1vZHVsZVR5cGUsIGZhbHNlKS5hc3luY1Jlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuZ2V0TmdDb250ZW50U2VsZWN0b3JzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oJ0NvbXBpbGVyLmdldE5nQ29udGVudFNlbGVjdG9ycyBpcyBkZXByZWNhdGVkLiBVc2UgQ29tcG9uZW50RmFjdG9yeS5uZ0NvbnRlbnRTZWxlY3RvcnMgaW5zdGVhZCEnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBvbmVudCk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShjb21wb25lbnQpICsgXCIgaXMgbm90IHlldCBjb21waWxlZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbXBNZXRhLnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvYWRpbmdQcm9taXNlID0gdGhpcy5fbG9hZE1vZHVsZXMobW9kdWxlVHlwZSwgaXNTeW5jKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3JlYXRlUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChjcmVhdGVSZXN1bHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBsb2FkaW5nUHJvbWlzZS50aGVuKGNyZWF0ZVJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nUHJvbWlzZSA9IHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNyZWF0ZVJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMoX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSksIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KGNyZWF0ZVJlc3VsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG51bGwsIGxvYWRpbmdQcm9taXNlLnRoZW4oY3JlYXRlUmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFpbk1vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2xvYWRNb2R1bGVzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBsb2FkaW5nUHJvbWlzZSBmb3IgYSBtb2R1bGUgb25seSBpbmNsdWRlcyB0aGUgbG9hZGluZyBvZiB0aGUgZXhwb3J0ZWQgZGlyZWN0aXZlc1xuICAgICAgICAvLyBvZiBpbXBvcnRlZCBtb2R1bGVzLlxuICAgICAgICAvLyBIb3dldmVyLCBmb3IgcnVudGltZSBjb21waWxhdGlvbiwgd2Ugd2FudCB0byB0cmFuc2l0aXZlbHkgY29tcGlsZSBhbGwgbW9kdWxlcyxcbiAgICAgICAgLy8gc28gd2UgYWxzbyBuZWVkIHRvIGNhbGwgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhbGwgbmVzdGVkIG1vZHVsZXMuXG4gICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbE1vZHVsZU1ldGEpIHtcbiAgICAgICAgICAgIGxvYWRpbmdQcm9taXNlcy5wdXNoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShsb2NhbE1vZHVsZU1ldGEucmVmZXJlbmNlLCBpc1N5bmMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeSA9IHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgIGlmICghbmdNb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhXzEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRyYVByb3ZpZGVycyA9IFt0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFByb3ZpZGVyTWV0YWRhdGEobmV3IFByb3ZpZGVyTWV0YShDb21waWxlciwgeyB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9kdWxlQm91bmRDb21waWxlcihfdGhpcywgbW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlKTsgfSB9KSldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShtb2R1bGVNZXRhXzEsIGV4dHJhUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0U3RhdGVtZW50cyhjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtjb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcl0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhuZ01vZHVsZUppdFVybChtb2R1bGVNZXRhXzEpLCBjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtjb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcl0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLnNldChtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBtYWluTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBhbGxDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobWFpbk1vZHVsZSwgYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVCeURpcmVjdGl2ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbE1vZHVsZU1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlU3VtbWFyeS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgbG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQnlEaXJlY3RpdmUuc2V0KGRpcklkZW50aWZpZXIucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZShkaXJNZXRhLCBsb2NhbE1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbENvbXBvbmVudEZhY3Rvcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGUgPSBfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29tcG9uZW50RmFjdG9yaWVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoZGlyTWV0YS5jb21wb25lbnRGYWN0b3J5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsTW9kdWxlTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobG9jYWxNb2R1bGVTdW1tYXJ5LnJlZmVyZW5jZSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlySWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpck1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9IG1vZHVsZUJ5RGlyZWN0aXZlLmdldChlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9IG1vZHVsZUJ5RGlyZWN0aXZlLmdldChlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUsIG1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlRm9yKHR5cGUpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wVHlwZSwgbmdNb2R1bGUpIHtcbiAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgbm90IHBhcnQgb2YgYW55IE5nTW9kdWxlIG9yIHRoZSBtb2R1bGUgaGFzIG5vdCBiZWVuIGltcG9ydGVkIGludG8geW91ciBtb2R1bGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSk7XG4gICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGNvbXBUeXBlKTtcbiAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5ID0gKGNvbXBNZXRhLmNvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdENsYXNzID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50VHlwZShjb21wVHlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGhvc3RDbGFzcywgY29tcE1ldGEsIC8qKiBAdHlwZSB7P30gKi8gKMm1Z2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5KGNvbXBvbmVudEZhY3RvcnkpKSk7XG4gICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID1cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS50eXBlLCBob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLnNldChjb21wVHlwZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZShmYWxzZSwgY29tcE1ldGEudHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGVtcGxhdGUuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBNZXRhID0gdGVtcGxhdGUuY29tcE1ldGE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzQ29tcGlsZVJlc3VsdCA9IHRoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHQuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5zZXQoci5tZXRhLm1vZHVsZVVybCwgcik7IH0pO1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSB0ZW1wbGF0ZS5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZXMgPSB0ZW1wbGF0ZS5uZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgdGVtcGxhdGUubmdNb2R1bGUuc2NoZW1hcywgdGVtcGxhdGVTb3VyY2VVcmwodGVtcGxhdGUubmdNb2R1bGUudHlwZSwgdGVtcGxhdGUuY29tcE1ldGEsIHRlbXBsYXRlLmNvbXBNZXRhLnRlbXBsYXRlKSksIHBhcnNlZFRlbXBsYXRlID0gX2EudGVtcGxhdGUsIHVzZWRQaXBlcyA9IF9hLnBpcGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCB2YXJpYWJsZShzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQuc3R5bGVzVmFyKSwgdXNlZFBpcGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVtZW50cyA9IHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldC5zdGF0ZW1lbnRzLmNvbmNhdChjb21waWxlUmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q2xhc3NBbmRSZW5kZXJlclR5cGVWYXJzID0gY29tcE1ldGEuaXNIb3N0ID9cbiAgICAgICAgICAgIFtjb21waWxlUmVzdWx0LnZpZXdDbGFzc1Zhcl0gOlxuICAgICAgICAgICAgW2NvbXBpbGVSZXN1bHQudmlld0NsYXNzVmFyLCBjb21waWxlUmVzdWx0LnJlbmRlcmVyVHlwZVZhcl07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdDbGFzcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyZXJUeXBlO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgX2IgPSBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHZpZXdDbGFzc0FuZFJlbmRlcmVyVHlwZVZhcnMpLCB2aWV3Q2xhc3MgPSBfYlswXSwgcmVuZGVyZXJUeXBlID0gX2JbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYyA9IGppdFN0YXRlbWVudHModGVtcGxhdGVKaXRVcmwodGVtcGxhdGUubmdNb2R1bGUudHlwZSwgdGVtcGxhdGUuY29tcE1ldGEpLCBzdGF0ZW1lbnRzLCB2aWV3Q2xhc3NBbmRSZW5kZXJlclR5cGVWYXJzKSwgdmlld0NsYXNzID0gX2NbMF0sIHJlbmRlcmVyVHlwZSA9IF9jWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLmNvbXBpbGVkKHZpZXdDbGFzcywgcmVuZGVyZXJUeXBlKTtcbiAgICAgICAgdmFyIF9iLCBfYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVzdWx0XG4gICAgICogQHBhcmFtIHs/fSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXAsIGkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZENvbXBpbGVSZXN1bHQgPSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuZ2V0KGRlcC5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkU3R5bGVzQXJyID0gX3RoaXMuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdChuZXN0ZWRDb21waWxlUmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpO1xuICAgICAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucmVmZXJlbmNlID0gbmVzdGVkU3R5bGVzQXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVzdWx0XG4gICAgICogQHBhcmFtIHs/fSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZUFuZEV2YWxTdHlsZXNDb21waWxlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnByZXRTdGF0ZW1lbnRzKHJlc3VsdC5zdGF0ZW1lbnRzLCBbcmVzdWx0LnN0eWxlc1Zhcl0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGppdFN0YXRlbWVudHMoc2hhcmVkU3R5bGVzaGVldEppdFVybChyZXN1bHQubWV0YSwgdGhpcy5fc2hhcmVkU3R5bGVzaGVldENvdW50KyspLCByZXN1bHQuc3RhdGVtZW50cywgW3Jlc3VsdC5zdHlsZXNWYXJdKVswXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEppdENvbXBpbGVyO1xufSgpKTtcbkppdENvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkppdENvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogSW5qZWN0b3IsIH0sXG4gICAgeyB0eXBlOiBDb21waWxlTWV0YWRhdGFSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IFRlbXBsYXRlUGFyc2VyLCB9LFxuICAgIHsgdHlwZTogU3R5bGVDb21waWxlciwgfSxcbiAgICB7IHR5cGU6IFZpZXdDb21waWxlciwgfSxcbiAgICB7IHR5cGU6IE5nTW9kdWxlQ29tcGlsZXIsIH0sXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICB7IHR5cGU6IMm1Q29uc29sZSwgfSxcbl07IH07XG52YXIgQ29tcGlsZWRUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc0hvc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKGlzSG9zdCwgY29tcFR5cGUsIGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlcykge1xuICAgICAgICB0aGlzLmlzSG9zdCA9IGlzSG9zdDtcbiAgICAgICAgdGhpcy5jb21wVHlwZSA9IGNvbXBUeXBlO1xuICAgICAgICB0aGlzLmNvbXBNZXRhID0gY29tcE1ldGE7XG4gICAgICAgIHRoaXMubmdNb2R1bGUgPSBuZ01vZHVsZTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5fdmlld0NsYXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlld0NsYXNzXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHZpZXdDbGFzcywgcmVuZGVyZXJUeXBlKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDbGFzcyA9IHZpZXdDbGFzcztcbiAgICAgICAgKCh0aGlzLmNvbXBNZXRhLmNvbXBvbmVudFZpZXdUeXBlKSkuc2V0RGVsZWdhdGUodmlld0NsYXNzKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wIGluIHJlbmRlcmVyVHlwZSkge1xuICAgICAgICAgICAgKCh0aGlzLmNvbXBNZXRhLnJlbmRlcmVyVHlwZSkpW3Byb3BdID0gcmVuZGVyZXJUeXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZWRUZW1wbGF0ZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgaWRlbnRpZmllck5hbWUobWV0YS50eXBlKSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGBDb21waWxlcmAgYnkgZGVsZWdhdGluZyB0byB0aGUgSml0Q29tcGlsZXIgdXNpbmcgYSBrbm93biBtb2R1bGUuXG4gKi9cbnZhciBNb2R1bGVCb3VuZENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9kZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kdWxlQm91bmRDb21waWxlcihfZGVsZWdhdGUsIF9uZ01vZHVsZSkge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGUgPSBfbmdNb2R1bGU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZSwgXCJfaW5qZWN0b3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaW5qZWN0b3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlU3luYyhtb2R1bGVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmdldE5nQ29udGVudFNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmdldE5nQ29udGVudFNlbGVjdG9ycyhjb21wb25lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjYWNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50L25nTW9kdWxlLlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGVGb3IodHlwZSk7IH07XG4gICAgcmV0dXJuIE1vZHVsZUJvdW5kQ29tcGlsZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgbWVzc2FnZSBleHRyYWN0ZWQgZnJvbSB0aGUgdGVtcGxhdGVzLlxuICovXG52YXIgTWVzc2FnZUJ1bmRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaHRtbFBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ltcGxpY2l0VGFnc1xuICAgICAqIEBwYXJhbSB7P30gX2ltcGxpY2l0QXR0cnNcbiAgICAgKiBAcGFyYW0gez89fSBfbG9jYWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZUJ1bmRsZShfaHRtbFBhcnNlciwgX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMsIF9sb2NhbGUpIHtcbiAgICAgICAgaWYgKF9sb2NhbGUgPT09IHZvaWQgMCkgeyBfbG9jYWxlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBodG1sXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLnVwZGF0ZUZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbFBhcnNlclJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UoaHRtbCwgdXJsLCB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5QYXJzZXJSZXN1bHQgPSBleHRyYWN0TWVzc2FnZXMoaHRtbFBhcnNlclJlc3VsdC5yb290Tm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX2ltcGxpY2l0VGFncywgdGhpcy5faW1wbGljaXRBdHRycyk7XG4gICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpMThuUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9tZXNzYWdlcykucHVzaC5hcHBseShfYSwgaTE4blBhcnNlclJlc3VsdC5tZXNzYWdlcyk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlczsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlcmlhbGl6ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZXMgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGVyVmlzaXRvciA9IG5ldyBNYXBQbGFjZWhvbGRlck5hbWVzKCk7XG4gICAgICAgIC8vIERlZHVwbGljYXRlIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZWlyIElEXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gc2VyaWFsaXplci5kaWdlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gcGxhY2Vob2xkZXIgbmFtZXMgdXNpbmcgdGhlIHNlcmlhbGl6ZXIgbWFwcGluZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtc2dMaXN0ID0gT2JqZWN0LmtleXMobWVzc2FnZXMpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlciA9IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlc1tpZF0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3JjID0gbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBtYXBwZXIgPyBtYXBwZXJWaXNpdG9yLmNvbnZlcnQoc3JjLm5vZGVzLCBtYXBwZXIpIDogc3JjLm5vZGVzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKG5vZGVzLCB7fSwge30sIHNyYy5tZWFuaW5nLCBzcmMuZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyLndyaXRlKG1zZ0xpc3QsIHRoaXMuX2xvY2FsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUJ1bmRsZTtcbn0oKSk7XG52YXIgTWFwUGxhY2Vob2xkZXJOYW1lcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFBsYWNlaG9sZGVyTmFtZXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwUGxhY2Vob2xkZXJOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtYXBwZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobm9kZXMsIG1hcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWFwcGVyID8gbm9kZXMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KSA6IG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnROYW1lID0gbWFwcGVyLnRvUHVibGljTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZU5hbWUgPSBwaC5jbG9zZU5hbWUgPyBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLmNsb3NlTmFtZSkgOiBwaC5jbG9zZU5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihwaC50YWcsIHBoLmF0dHJzLCBzdGFydE5hbWUsIGNsb3NlTmFtZSwgY2hpbGRyZW4sIHBoLmlzVm9pZCwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBtYXBwZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IG1hcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFBsYWNlaG9sZGVyTmFtZXM7XG59KENsb25lVmlzaXRvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBFeHRyYWN0IGkxOG4gbWVzc2FnZXMgZnJvbSBzb3VyY2UgY29kZVxuICovXG52YXIgRXh0cmFjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlQnVuZGxlXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0cmFjdG9yKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXNzYWdlQnVuZGxlLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sUmVzb2x2ZXIgPSBzdGF0aWNTeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVuZGxlID0gbWVzc2FnZUJ1bmRsZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVJlc29sdmVyID0gbWV0YWRhdGFSZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RmlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4dHJhY3Rvci5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3JhbVN5bWJvbHMgPSBleHRyYWN0UHJvZ3JhbVN5bWJvbHModGhpcy5zdGF0aWNTeW1ib2xSZXNvbHZlciwgcm9vdEZpbGVzLCB0aGlzLmhvc3QpO1xuICAgICAgICB2YXIgX2EgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIHRoaXMuaG9zdCwgdGhpcy5tZXRhZGF0YVJlc29sdmVyKSwgZmlsZXMgPSBfYS5maWxlcywgbmdNb2R1bGVzID0gX2EubmdNb2R1bGVzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIGZhbHNlKTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmaWxlLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcE1ldGFzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcE1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbCA9IGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkoY29tcE1ldGEudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX3RoaXMubWVzc2FnZUJ1bmRsZS51cGRhdGVGcm9tVGVtcGxhdGUoaHRtbCwgZmlsZS5zcmNVcmwsIGludGVycG9sYXRpb25Db25maWcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50b1N0cmluZygpOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubWVzc2FnZUJ1bmRsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0cmFjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChob3N0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbFBhcnNlciA9IG5ldyBJMThOSHRtbFBhcnNlcihuZXcgSHRtbFBhcnNlcigpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsUmVzb2x2ZXIgPSBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbENhY2hlID0gbmV3IFN0YXRpY1N5bWJvbENhY2hlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlSZXNvbHZlciA9IG5ldyBBb3RTdW1tYXJ5UmVzb2x2ZXIoaG9zdCwgc3ltYm9sQ2FjaGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2xSZXNvbHZlciA9IG5ldyBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUmVmbGVjdG9yID0gbmV3IFN0YXRpY1JlZmxlY3RvcihzdW1tYXJ5UmVzb2x2ZXIsIHN0YXRpY1N5bWJvbFJlc29sdmVyKTtcbiAgICAgICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW5zdGFsbChzdGF0aWNSZWZsZWN0b3IpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBuZXcgQ29tcGlsZXJDb25maWcoeyBkZWZhdWx0RW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsIHVzZUppdDogZmFsc2UgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZXIgPSBuZXcgRGlyZWN0aXZlTm9ybWFsaXplcih7IGdldDogZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gaG9zdC5sb2FkUmVzb3VyY2UodXJsKTsgfSB9LCB1cmxSZXNvbHZlciwgaHRtbFBhcnNlciwgY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gbmV3IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlciA9IG5ldyBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihjb25maWcsIG5ldyBOZ01vZHVsZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBEaXJlY3RpdmVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgUGlwZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIHN1bW1hcnlSZXNvbHZlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBub3JtYWxpemVyLCBuZXcgybVDb25zb2xlKCksIHN5bWJvbENhY2hlLCBzdGF0aWNSZWZsZWN0b3IpO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBpbXBsaWNpdCB0YWdzICYgYXR0cmlidXRlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlQnVuZGxlID0gbmV3IE1lc3NhZ2VCdW5kbGUoaHRtbFBhcnNlciwgW10sIHt9LCBsb2NhbGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRyYWN0b3IgPSBuZXcgRXh0cmFjdG9yKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXNzYWdlQnVuZGxlLCByZXNvbHZlcik7XG4gICAgICAgIHJldHVybiB7IGV4dHJhY3RvcjogZXh0cmFjdG9yLCBzdGF0aWNSZWZsZWN0b3I6IHN0YXRpY1JlZmxlY3RvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIEV4dHJhY3Rvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX05PX1JFU09VUkNFX0xPQURFUiA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlc291cmNlTG9hZGVyIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLiBDYW4ndCByZWFkIHRoZSB1cmwgXFxcIlwiICsgdXJsICsgXCJcXFwiXCIpO1xuICAgIH1cbn07XG52YXIgYmFzZUh0bWxQYXJzZXIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0h0bWxQYXJzZXInKTtcbi8qKlxuICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgSml0Q29tcGlsZXJgIGFuZCBpdHMgZGVwZW5kZW5jaWVzIHRvIHVzZSBmb3JcbiAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICovXG52YXIgQ09NUElMRVJfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogybVSZWZsZWN0b3IsIHVzZVZhbHVlOiDJtXJlZmxlY3RvciB9LFxuICAgIHsgcHJvdmlkZTogybVSZWZsZWN0b3JSZWFkZXIsIHVzZUV4aXN0aW5nOiDJtVJlZmxlY3RvciB9LFxuICAgIHsgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZVZhbHVlOiBfTk9fUkVTT1VSQ0VfTE9BREVSIH0sXG4gICAgU3VtbWFyeVJlc29sdmVyLFxuICAgIMm1Q29uc29sZSxcbiAgICBMZXhlcixcbiAgICBQYXJzZXIsXG4gICAge1xuICAgICAgICBwcm92aWRlOiBiYXNlSHRtbFBhcnNlcixcbiAgICAgICAgdXNlQ2xhc3M6IEh0bWxQYXJzZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IEkxOE5IdG1sUGFyc2VyLFxuICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyc2VyLCB0cmFuc2xhdGlvbnMsIGZvcm1hdCwgY29uZmlnLCBjb25zb2xlKSB7IHJldHVybiBuZXcgSTE4Tkh0bWxQYXJzZXIocGFyc2VyLCB0cmFuc2xhdGlvbnMsIGZvcm1hdCwgY29uZmlnLm1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSk7IH0sXG4gICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgIGJhc2VIdG1sUGFyc2VyLFxuICAgICAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KFRSQU5TTEFUSU9OUyldLFxuICAgICAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KFRSQU5TTEFUSU9OU19GT1JNQVQpXSxcbiAgICAgICAgICAgIFtDb21waWxlckNvbmZpZ10sXG4gICAgICAgICAgICBbybVDb25zb2xlXSxcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBIdG1sUGFyc2VyLFxuICAgICAgICB1c2VFeGlzdGluZzogSTE4Tkh0bWxQYXJzZXIsXG4gICAgfSxcbiAgICBUZW1wbGF0ZVBhcnNlcixcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLFxuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLFxuICAgIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgU3R5bGVDb21waWxlcixcbiAgICBWaWV3Q29tcGlsZXIsXG4gICAgTmdNb2R1bGVDb21waWxlcixcbiAgICB7IHByb3ZpZGU6IENvbXBpbGVyQ29uZmlnLCB1c2VWYWx1ZTogbmV3IENvbXBpbGVyQ29uZmlnKCkgfSxcbiAgICBKaXRDb21waWxlcixcbiAgICB7IHByb3ZpZGU6IENvbXBpbGVyLCB1c2VFeGlzdGluZzogSml0Q29tcGlsZXIgfSxcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgeyBwcm92aWRlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIHVzZUV4aXN0aW5nOiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgfSxcbiAgICBVcmxSZXNvbHZlcixcbiAgICBEaXJlY3RpdmVSZXNvbHZlcixcbiAgICBQaXBlUmVzb2x2ZXIsXG4gICAgTmdNb2R1bGVSZXNvbHZlcixcbl07XG52YXIgSml0Q29tcGlsZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRPcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSml0Q29tcGlsZXJGYWN0b3J5KGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21waWxlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1c2VEZWJ1ZzogaXNEZXZNb2RlKCksXG4gICAgICAgICAgICB1c2VKaXQ6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsXG4gICAgICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcsXG4gICAgICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSBbY29tcGlsZXJPcHRpb25zXS5jb25jYXQoZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNvbXBpbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gW107IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0cyA9IF9tZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMuY29uY2F0KG9wdGlvbnMpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICAgICAgICBDT01QSUxFUl9QUk9WSURFUlMsIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDb21waWxlckNvbmZpZyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZXJDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VKaXQ6IG9wdHMudXNlSml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogb3B0cy5kZWZhdWx0RW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogb3B0cy5taXNzaW5nVHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogb3B0cy5lbmFibGVMZWdhY3lUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXBzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdHMucHJvdmlkZXJzXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KENvbXBpbGVyKTtcbiAgICB9O1xuICAgIHJldHVybiBKaXRDb21waWxlckZhY3Rvcnk7XG59KCkpO1xuSml0Q29tcGlsZXJGYWN0b3J5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkppdENvbXBpbGVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtDT01QSUxFUl9PUFRJT05TLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaW5pdFJlZmxlY3RvcigpIHtcbiAgICDJtXJlZmxlY3Rvci5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IMm1UmVmbGVjdGlvbkNhcGFiaWxpdGllcygpO1xufVxuLyoqXG4gKiBBIHBsYXRmb3JtIHRoYXQgaW5jbHVkZWQgY29yZVBsYXRmb3JtIGFuZCB0aGUgY29tcGlsZXIuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBwbGF0Zm9ybUNvcmVEeW5hbWljID0gY3JlYXRlUGxhdGZvcm1GYWN0b3J5KHBsYXRmb3JtQ29yZSwgJ2NvcmVEeW5hbWljJywgW1xuICAgIHsgcHJvdmlkZTogQ09NUElMRVJfT1BUSU9OUywgdXNlVmFsdWU6IHt9LCBtdWx0aTogdHJ1ZSB9LFxuICAgIHsgcHJvdmlkZTogQ29tcGlsZXJGYWN0b3J5LCB1c2VDbGFzczogSml0Q29tcGlsZXJGYWN0b3J5IH0sXG4gICAgeyBwcm92aWRlOiBQTEFURk9STV9JTklUSUFMSVpFUiwgdXNlVmFsdWU6IF9pbml0UmVmbGVjdG9yLCBtdWx0aTogdHJ1ZSB9LFxuXSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb3B0aW9uc0FyclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX21lcmdlT3B0aW9ucyhvcHRpb25zQXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlSml0OiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMudXNlSml0OyB9KSksXG4gICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdEVuY2Fwc3VsYXRpb247IH0pKSxcbiAgICAgICAgcHJvdmlkZXJzOiBfbWVyZ2VBcnJheXMob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMucHJvdmlkZXJzOyB9KSksXG4gICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLm1pc3NpbmdUcmFuc2xhdGlvbjsgfSkpLFxuICAgIH07XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGFyZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9sYXN0RGVmaW5lZChhcmdzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBhcnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbWVyZ2VBcnJheXMocGFydHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0ICYmIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcGFydCk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IGRlZmluZXMgaG93IGltcG9ydCBzdGF0ZW1lbnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEltcG9ydFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBmaWxlIHBhdGggdG8gYSBtb2R1bGUgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGBpbXBvcnQuXG4gICAgICogSS5lLiBgcGF0aC90by9pbXBvcnRlZEZpbGUudHNgIHNob3VsZCBiZSBpbXBvcnRlZCBieSBgcGF0aC90by9jb250YWluaW5nRmlsZS50c2AuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZEZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluaW5nRmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcG9ydFJlc29sdmVyLnByb3RvdHlwZS5maWxlTmFtZVRvTW9kdWxlTmFtZSA9IGZ1bmN0aW9uIChpbXBvcnRlZEZpbGVQYXRoLCBjb250YWluaW5nRmlsZVBhdGgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gU3RhdGljU3ltYm9sIGludG8gYW5vdGhlciBTdGF0aWNTeW1ib2wgdGhhdCBzaG91bGQgYmUgdXNlZFxuICAgICAqIHRvIGdlbmVyYXRlIHRoZSBpbXBvcnQgZnJvbS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW1wb3J0UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN5bWJvbCkgeyB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgYXJpdHkgb2YgYSB0eXBlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbXBvcnRSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZUFyaXR5ID0gZnVuY3Rpb24gKHN5bWJvbCkgeyB9O1xuICAgIHJldHVybiBJbXBvcnRSZXNvbHZlcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBBUElzIG9mIHRoZSBjb21waWxlciBwYWNrYWdlLlxuICpcbiAqIDxkaXYgY2xhc3M9XCJjYWxsb3V0IGlzLWNyaXRpY2FsXCI+XG4gKiAgIDxoZWFkZXI+VW5zdGFibGUgQVBJczwvaGVhZGVyPlxuICogICA8cD5cbiAqICAgICBBbGwgY29tcGlsZXIgYXBpcyBhcmUgY3VycmVudGx5IGNvbnNpZGVyZWQgZXhwZXJpbWVudGFsIGFuZCBwcml2YXRlIVxuICogICA8L3A+XG4gKiAgIDxwPlxuICogICAgIFdlIGV4cGVjdCB0aGUgQVBJcyBpbiB0aGlzIHBhY2thZ2UgdG8ga2VlcCBvbiBjaGFuZ2luZy4gRG8gbm90IHJlbHkgb24gdGhlbS5cbiAqICAgPC9wPlxuICogPC9kaXY+XG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgY29tcGlsZXIgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbmV4cG9ydCB7IFZFUlNJT04sIFRFTVBMQVRFX1RSQU5TRk9STVMsIENvbXBpbGVyQ29uZmlnLCBKaXRDb21waWxlciwgRGlyZWN0aXZlUmVzb2x2ZXIsIFBpcGVSZXNvbHZlciwgTmdNb2R1bGVSZXNvbHZlciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgSW50ZXJwb2xhdGlvbkNvbmZpZywgTmdNb2R1bGVDb21waWxlciwgVmlld0NvbXBpbGVyLCBpc1N5bnRheEVycm9yLCBzeW50YXhFcnJvciwgVGV4dEFzdCwgQm91bmRUZXh0QXN0LCBBdHRyQXN0LCBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCwgQm91bmRFdmVudEFzdCwgUmVmZXJlbmNlQXN0LCBWYXJpYWJsZUFzdCwgRWxlbWVudEFzdCwgRW1iZWRkZWRUZW1wbGF0ZUFzdCwgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCwgRGlyZWN0aXZlQXN0LCBQcm92aWRlckFzdCwgUHJvdmlkZXJBc3RUeXBlLCBOZ0NvbnRlbnRBc3QsIFByb3BlcnR5QmluZGluZ1R5cGUsIHRlbXBsYXRlVmlzaXRBbGwsIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEsIGlkZW50aWZpZXJOYW1lLCBpZGVudGlmaWVyTW9kdWxlVXJsLCB2aWV3Q2xhc3NOYW1lLCByZW5kZXJlclR5cGVOYW1lLCBob3N0Vmlld0NsYXNzTmFtZSwgZGlyV3JhcHBlckNsYXNzTmFtZSwgY29tcG9uZW50RmFjdG9yeU5hbWUsIENvbXBpbGVTdW1tYXJ5S2luZCwgdG9rZW5OYW1lLCB0b2tlblJlZmVyZW5jZSwgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSwgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEsIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSwgY3JlYXRlSG9zdENvbXBvbmVudE1ldGEsIENvbXBpbGVQaXBlTWV0YWRhdGEsIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLCBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEsIFByb3ZpZGVyTWV0YSwgZmxhdHRlbiwgc291cmNlVXJsLCB0ZW1wbGF0ZVNvdXJjZVVybCwgc2hhcmVkU3R5bGVzaGVldEppdFVybCwgbmdNb2R1bGVKaXRVcmwsIHRlbXBsYXRlSml0VXJsLCBjcmVhdGVBb3RDb21waWxlciwgQW90Q29tcGlsZXIsIGFuYWx5emVOZ01vZHVsZXMsIGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcywgZXh0cmFjdFByb2dyYW1TeW1ib2xzLCBHZW5lcmF0ZWRGaWxlLCBTdGF0aWNSZWZsZWN0b3IsIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLCBTdGF0aWNTeW1ib2wsIFN0YXRpY1N5bWJvbENhY2hlLCBSZXNvbHZlZFN0YXRpY1N5bWJvbCwgU3RhdGljU3ltYm9sUmVzb2x2ZXIsIHVuZXNjYXBlSWRlbnRpZmllciwgQW90U3VtbWFyeVJlc29sdmVyLCBTdW1tYXJ5UmVzb2x2ZXIsIENPTVBJTEVSX1BST1ZJREVSUywgSml0Q29tcGlsZXJGYWN0b3J5LCBwbGF0Zm9ybUNvcmVEeW5hbWljLCBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4LCBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyLCBERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSLCBVcmxSZXNvbHZlciwgZ2V0VXJsU2NoZW1lLCBSZXNvdXJjZUxvYWRlciwgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBFeHRyYWN0b3IsIEkxOE5IdG1sUGFyc2VyLCBNZXNzYWdlQnVuZGxlLCBTZXJpYWxpemVyLCBYbGlmZiwgWGxpZmYyLCBYbWIsIFh0YiwgRGlyZWN0aXZlTm9ybWFsaXplciwgUGFyc2VyRXJyb3IsIFBhcnNlU3BhbiwgQVNULCBRdW90ZSwgRW1wdHlFeHByLCBJbXBsaWNpdFJlY2VpdmVyLCBDaGFpbiwgQ29uZGl0aW9uYWwsIFByb3BlcnR5UmVhZCwgUHJvcGVydHlXcml0ZSwgU2FmZVByb3BlcnR5UmVhZCwgS2V5ZWRSZWFkLCBLZXllZFdyaXRlLCBCaW5kaW5nUGlwZSwgTGl0ZXJhbFByaW1pdGl2ZSwgTGl0ZXJhbEFycmF5LCBMaXRlcmFsTWFwLCBJbnRlcnBvbGF0aW9uLCBCaW5hcnksIFByZWZpeE5vdCwgTWV0aG9kQ2FsbCwgU2FmZU1ldGhvZENhbGwsIEZ1bmN0aW9uQ2FsbCwgQVNUV2l0aFNvdXJjZSwgVGVtcGxhdGVCaW5kaW5nLCBSZWN1cnNpdmVBc3RWaXNpdG9yLCBBc3RUcmFuc2Zvcm1lciwgVG9rZW5UeXBlLCBMZXhlciwgVG9rZW4sIEVPRiwgaXNJZGVudGlmaWVyLCBpc1F1b3RlLCBTcGxpdEludGVycG9sYXRpb24sIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0LCBQYXJzZXIsIF9QYXJzZUFTVCwgRVJST1JfQ09MTEVDVE9SX1RPS0VOLCBDb21waWxlTWV0YWRhdGFSZXNvbHZlciwgY29tcG9uZW50TW9kdWxlVXJsLCBUZXh0LCBFeHBhbnNpb24sIEV4cGFuc2lvbkNhc2UsIEF0dHJpYnV0ZSQxIGFzIEF0dHJpYnV0ZSwgRWxlbWVudCwgQ29tbWVudCwgdmlzaXRBbGwsIFBhcnNlVHJlZVJlc3VsdCwgVHJlZUVycm9yLCBIdG1sUGFyc2VyLCBIdG1sVGFnRGVmaW5pdGlvbiwgZ2V0SHRtbFRhZ0RlZmluaXRpb24sIFRhZ0NvbnRlbnRUeXBlLCBzcGxpdE5zTmFtZSwgZ2V0TnNQcmVmaXgsIG1lcmdlTnNBbmROYW1lLCBOQU1FRF9FTlRJVElFUywgSW1wb3J0UmVzb2x2ZXIsIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0LCBUeXBlU2NyaXB0RW1pdHRlciwgUGFyc2VMb2NhdGlvbiwgUGFyc2VTb3VyY2VGaWxlLCBQYXJzZVNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbCwgUGFyc2VFcnJvciwgdHlwZVNvdXJjZVNwYW4sIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgQ3NzU2VsZWN0b3IsIFNlbGVjdG9yTWF0Y2hlciwgU2VsZWN0b3JMaXN0Q29udGV4dCwgU2VsZWN0b3JDb250ZXh0LCBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSwgU3R5bGVzQ29tcGlsZVJlc3VsdCwgQ29tcGlsZWRTdHlsZXNoZWV0LCBTdHlsZUNvbXBpbGVyLCBUZW1wbGF0ZVBhcnNlRXJyb3IsIFRlbXBsYXRlUGFyc2VSZXN1bHQsIFRlbXBsYXRlUGFyc2VyLCBzcGxpdENsYXNzZXMsIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvciwgcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVyLmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuZXM1LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9jb21waWxlci9AYW5ndWxhci9jb21waWxlci5lczUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 172:
/* exports provided: AppComponent */
/* exports used: AppComponent */
/*!******************************************!*\
  !*** ./angular2App/app/app.component.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AppComponent; });\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\nvar AppComponent = (function () {\r\n    function AppComponent() {\r\n    }\r\n    return AppComponent;\r\n}());\r\nAppComponent = __decorate([\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */])({\r\n        selector: 'my-app',\r\n        templateUrl: './app.component.html'\r\n    })\r\n], AppComponent);\r\n\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYW5ndWxhcjJBcHAvYXBwL2FwcC5jb21wb25lbnQudHM/MmNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuXHJcbiAgICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hcHAuY29tcG9uZW50Lmh0bWwnKVxyXG5cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hbmd1bGFyMkFwcC9hcHAvYXBwLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVBBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 173:
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./angular2App/app/main.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polyfills__ = __webpack_require__(/*! ../polyfills */ 89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vendor__ = __webpack_require__(/*! ../vendor */ 90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser_dynamic__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ 140);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_app_module__ = __webpack_require__(/*! ../app/app.module */ 142);\n\r\n\r\n\r\n\r\n__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__angular_platform_browser_dynamic__[\"a\" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_3__app_app_module__[\"a\" /* AppModule */]);\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYW5ndWxhcjJBcHAvYXBwL21haW4udHM/YjExOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3BvbHlmaWxscyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yJztcclxuXHJcbmltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xyXG5cclxuaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi4vYXBwL2FwcC5tb2R1bGUnO1xyXG5cclxucGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYW5ndWxhcjJBcHAvYXBwL21haW4udHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

},[173]);